var tipuesearch = {"pages":[{"title":" LSDA-Hubbard-Fortran ","text":"LSDA-Hubbard-Fortran [TOC] LSDA-Hubbard-Fortran A modern Fortran implementation of Local Spin Density Approximation (LSDA)\nfor solving the 1D Hubbard model using the Bethe Ansatz. Overview This code implements density functional theory (DFT) in the local spin density approximation\nfor the one-dimensional Hubbard model. The exchange-correlation functional is computed\nfrom exact Bethe Ansatz solutions using bicubic spline interpolation. Key Features Exact Bethe Ansatz solver using Newton-Raphson with analytical Jacobian Exchange-correlation functional via 2D bicubic spline interpolation Self-consistent Kohn-Sham solver with adaptive mixing 7 types of external potentials : uniform, harmonic, barriers, disorder, quasiperiodic, impurities High-performance linear algebra using LAPACK (DSYEVD/ZHEEVD) Comprehensive test suite with 252+ tests (100% pass rate) Production-ready : Validated against C++ reference with energy agreement < 1e-8 Physical Model The 1D Hubbard Hamiltonian: where:\n- $t = 1$ (hopping parameter, energy unit)\n- $U$ = Hubbard interaction (repulsive $U > 0$, attractive $U < 0$)\n- $V&#94;{\\text{ext}}$ = External potential Code Architecture Module Hierarchy types / - Core data structures and constants ├── lsda_types - System parameters , results types ├── lsda_constants - Physical / numerical constants └── lsda_errors - Error codes and handling bethe_ansatz / - Exact Bethe Ansatz solver ├── bethe_equations - Lieb - Wu equations ├── nonlinear_solvers - Newton - Raphson , Broyden ├── continuation - Continuation in U parameter ├── table_io - XC table I / O ( ASCII / binary ) └── bethe_tables - Generate XC tables xc_functional / - Exchange - correlation functional ├── spline2d - 2 D bicubic spline interpolation └── xc_lsda - LSDA functional interface potentials / - External potentials ├── potential_uniform - Constant potential ├── potential_harmonic - Harmonic trap ├── potential_impurity - Impurity potentials ├── potential_random - Disorder potentials ├── potential_barrier - Rectangular barriers ├── potential_quasiperiodic - Aubry - André - Harper └── potential_factory - Factory pattern hamiltonian / - Hamiltonian construction ├── hamiltonian_builder - Tight - binding Hamiltonian └── boundary_conditions - Open / periodic / twisted BC diagonalization / - Eigensolvers ├── lapack_wrapper - LAPACK interface └── degeneracy_handler - Handle degenerate states density / - Density calculation └── density_calculator - Density from eigenstates convergence / - SCF convergence ├── convergence_monitor - Track convergence ├── mixing_schemes - Linear mixing └── adaptive_mixing - Adaptive mixing parameter kohn_sham / - Main SCF loop └── kohn_sham_cycle - Self - consistent solver io / - Input / Output ├── input_parser - Parse namelist input └── output_writer - Write results Building and Testing See the main README.md for build instructions. Physics Background Bethe Ansatz The Bethe Ansatz provides exact solutions for the 1D Hubbard model via the Lieb-Wu equations: DFT-LSDA Mapping The Kohn-Sham equations are solved self-consistently: where $V_{\\text{eff},\\sigma} = V_{\\text{ext}} + U n_{\\bar{\\sigma}} + V_{xc,\\sigma}[n_\\uparrow, n_\\downarrow]$ References E.H. Lieb and F.Y. Wu, Phys. Rev. Lett. 20 , 1445 (1968) - Original Bethe Ansatz F.H.L. Essler et al., The One-Dimensional Hubbard Model (Cambridge, 2005) K. Capelle and V.L. Campo, Phys. Rep. 528 , 91 (2013) - DFT for model Hamiltonians License MIT License - see LICENSE file for details. Documentation generated with FORD Developer Info Guilherme Canella Computational Physics Researcher","tags":"home","url":"index.html"},{"title":"scf_params_t – LSDA-Hubbard-Fortran ","text":"type, public :: scf_params_t Components Type Visibility Attributes Name Initial integer, public :: max_iter = ITER_MAX real(kind=dp), public :: density_tol = SCF_DENSITY_TOL real(kind=dp), public :: energy_tol = SCF_ENERGY_TOL real(kind=dp), public :: mixing_alpha = MIX_ALPHA logical, public :: verbose = .false. logical, public :: store_history = .true. logical, public :: use_adaptive_mixing = .true. Source Code type :: scf_params_t integer :: max_iter = ITER_MAX ! Maximum SCF iterations real ( dp ) :: density_tol = SCF_DENSITY_TOL ! Convergence tolerance for density real ( dp ) :: energy_tol = SCF_ENERGY_TOL ! Convergence tolerance for energy real ( dp ) :: mixing_alpha = MIX_ALPHA ! Linear mixing parameter (used if use_adaptive_mixing = .false.) logical :: verbose = . false . ! Print convergence info logical :: store_history = . true . ! Store convergence history logical :: use_adaptive_mixing = . true . ! Use adaptive mixing (C++ behavior) end type scf_params_t","tags":"","url":"type/scf_params_t.html"},{"title":"scf_results_t – LSDA-Hubbard-Fortran ","text":"type, public :: scf_results_t Inherits type~~scf_results_t~~InheritsGraph type~scf_results_t scf_results_t type~convergence_history_t convergence_history_t type~scf_results_t->type~convergence_history_t history Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: converged integer, public :: n_iterations real(kind=dp), public :: final_density_error real(kind=dp), public :: final_energy real(kind=dp), public, allocatable :: density_up (:) real(kind=dp), public, allocatable :: density_down (:) real(kind=dp), public, allocatable :: eigvals (:) type( convergence_history_t ), public :: history Source Code type :: scf_results_t logical :: converged ! Did SCF converge? integer :: n_iterations ! Number of iterations performed real ( dp ) :: final_density_error ! Final ||Δn||₂ real ( dp ) :: final_energy ! Final total energy real ( dp ), allocatable :: density_up (:) ! Converged spin-up density real ( dp ), allocatable :: density_down (:) ! Converged spin-down density real ( dp ), allocatable :: eigvals (:) ! Final eigenvalues (both spins) type ( convergence_history_t ) :: history ! Convergence history end type scf_results_t","tags":"","url":"type/scf_results_t.html"},{"title":"spline2d_t – LSDA-Hubbard-Fortran ","text":"type, public :: spline2d_t Inherited by type~~spline2d_t~~InheritedByGraph type~spline2d_t spline2d_t type~xc_lsda_t xc_lsda_t type~xc_lsda_t->type~spline2d_t spl_exc, spl_vxc_up, spl_vxc_down Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: n_x Number of points in x (n) direction integer, public :: n_y_max Maximum number of points in y (m) direction real(kind=dp), public, allocatable :: x (:) Grid points in x direction: x(n_x) real(kind=dp), public, allocatable :: y (:,:) Grid points in y direction: y(n_y, n_x) - varies with x! real(kind=dp), public, allocatable :: f (:,:) Function values: f(n_y, n_x) integer, public, allocatable :: n_y (:) Number of y points for each x: n_y(n_x) real(kind=dp), public, allocatable :: d2f_dy2 (:,:) Second derivatives in y: d2f_dy2(n_y, n_x) logical, public :: initialized = .false. Initialization flag Source Code type , public :: spline2d_t integer :: n_x !< Number of points in x (n) direction integer :: n_y_max !< Maximum number of points in y (m) direction real ( dp ), allocatable :: x (:) !< Grid points in x direction: x(n_x) real ( dp ), allocatable :: y (:,:) !< Grid points in y direction: y(n_y, n_x) - varies with x! real ( dp ), allocatable :: f (:,:) !< Function values: f(n_y, n_x) integer , allocatable :: n_y (:) !< Number of y points for each x: n_y(n_x) real ( dp ), allocatable :: d2f_dy2 (:,:) !< Second derivatives in y: d2f_dy2(n_y, n_x) logical :: initialized = . false . !< Initialization flag end type spline2d_t","tags":"","url":"type/spline2d_t.html"},{"title":"input_params_t – LSDA-Hubbard-Fortran ","text":"type, public :: input_params_t Input parameters type Components Type Visibility Attributes Name Initial integer, public :: L = 10 integer, public :: Nup = 5 integer, public :: Ndown = 5 real(kind=dp), public :: U = 4.0_dp character(len=20), public :: bc_type = 'periodic' real(kind=dp), public :: phase = 0.0_dp character(len=20), public :: potential_type = 'uniform' real(kind=dp), public :: V0 = 0.0_dp real(kind=dp), public :: pot_center = 0.0_dp real(kind=dp), public :: pot_width = 1.0_dp real(kind=dp), public :: spring_constant = 0.001_dp real(kind=dp), public :: concentration = 50.0_dp integer, public :: pot_seed = -1 character(len=500), public :: imp_positions_str = '' real(kind=dp), public :: disorder_strength = 2.0_dp character(len=20), public :: distribution = 'gaussian' integer, public :: position = 50 integer, public :: width = 5 real(kind=dp), public :: barrier_width = 3.0_dp real(kind=dp), public :: well_depth = -3.0_dp real(kind=dp), public :: well_width = 20.0_dp integer, public :: position1 = 35 integer, public :: width1 = 3 integer, public :: position2 = 65 integer, public :: width2 = 3 integer, public :: max_iter = ITER_MAX real(kind=dp), public :: density_tol = SCF_DENSITY_TOL real(kind=dp), public :: energy_tol = SCF_ENERGY_TOL real(kind=dp), public :: mixing_alpha = MIX_ALPHA logical, public :: verbose = .true. logical, public :: store_history = .true. logical, public :: use_adaptive_mixing = .true. character(len=100), public :: output_prefix = 'lsda_output' logical, public :: save_density = .true. logical, public :: save_eigenvalues = .true. logical, public :: save_wavefunction = .false. Source Code type , public :: input_params_t ! System parameters integer :: L = 10 integer :: Nup = 5 integer :: Ndown = 5 real ( dp ) :: U = 4.0_dp character ( len = 20 ) :: bc_type = 'periodic' real ( dp ) :: phase = 0.0_dp ! Potential parameters character ( len = 20 ) :: potential_type = 'uniform' real ( dp ) :: V0 = 0.0_dp real ( dp ) :: pot_center = 0.0_dp real ( dp ) :: pot_width = 1.0_dp real ( dp ) :: spring_constant = 0.001_dp ! For harmonic potential (k) real ( dp ) :: concentration = 5 0.0_dp ! For random impurities (%) integer :: pot_seed = - 1 ! Random seed (-1 = system time) character ( len = 500 ) :: imp_positions_str = '' ! For impurity_multiple: '10, 25, 40, 55' real ( dp ) :: disorder_strength = 2.0_dp ! For random disorder (W or sigma) character ( len = 20 ) :: distribution = 'gaussian' ! For random: 'uniform' or 'gaussian' integer :: position = 50 ! For barrier_single: center position integer :: width = 5 ! For barrier_single: width real ( dp ) :: barrier_width = 3.0_dp ! For barrier_double: width of each barrier (Lb) real ( dp ) :: well_depth = - 3.0_dp ! For barrier_double: potential in well (Vwell, typically negative) real ( dp ) :: well_width = 2 0.0_dp ! For barrier_double: width of well between barriers (Lwell) integer :: position1 = 35 ! DEPRECATED for barrier_double integer :: width1 = 3 ! DEPRECATED for barrier_double integer :: position2 = 65 ! DEPRECATED for barrier_double integer :: width2 = 3 ! DEPRECATED for barrier_double ! SCF parameters integer :: max_iter = ITER_MAX real ( dp ) :: density_tol = SCF_DENSITY_TOL real ( dp ) :: energy_tol = SCF_ENERGY_TOL real ( dp ) :: mixing_alpha = MIX_ALPHA logical :: verbose = . true . logical :: store_history = . true . logical :: use_adaptive_mixing = . true . ! Use adaptive mixing (C++ behavior) ! Output parameters character ( len = 100 ) :: output_prefix = 'lsda_output' logical :: save_density = . true . logical :: save_eigenvalues = . true . logical :: save_wavefunction = . false . end type input_params_t","tags":"","url":"type/input_params_t.html"},{"title":"xc_lsda_t – LSDA-Hubbard-Fortran ","text":"type, public :: xc_lsda_t LSDA XC functional type containing splines for exc, vxc_up, vxc_down Inherits type~~xc_lsda_t~~InheritsGraph type~xc_lsda_t xc_lsda_t type~spline2d_t spline2d_t type~xc_lsda_t->type~spline2d_t spl_exc, spl_vxc_up, spl_vxc_down Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=dp), public :: U = 0.0_dp Hubbard U parameter type( spline2d_t ), public :: spl_exc Spline for e_xc(n, m) type( spline2d_t ), public :: spl_vxc_up Spline for V_xc&#94;up(n, m) type( spline2d_t ), public :: spl_vxc_down Spline for V_xc&#94;dn(n, m) logical, public :: initialized = .false. Initialization flag Source Code type , public :: xc_lsda_t real ( dp ) :: U = 0.0_dp !< Hubbard U parameter type ( spline2d_t ) :: spl_exc !< Spline for e_xc(n, m) type ( spline2d_t ) :: spl_vxc_up !< Spline for V_xc&#94;up(n, m) type ( spline2d_t ) :: spl_vxc_down !< Spline for V_xc&#94;dn(n, m) logical :: initialized = . false . !< Initialization flag end type xc_lsda_t","tags":"","url":"type/xc_lsda_t.html"},{"title":"convergence_history_t – LSDA-Hubbard-Fortran ","text":"type, public :: convergence_history_t Inherited by type~~convergence_history_t~~InheritedByGraph type~convergence_history_t convergence_history_t type~scf_results_t scf_results_t type~scf_results_t->type~convergence_history_t history Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: max_iter integer, public :: current_iter real(kind=dp), public, allocatable :: density_norms (:) real(kind=dp), public, allocatable :: energies (:) Source Code type :: convergence_history_t integer :: max_iter integer :: current_iter real ( dp ), allocatable :: density_norms (:) real ( dp ), allocatable :: energies (:) end type convergence_history_t","tags":"","url":"type/convergence_history_t.html"},{"title":"system_params_t – LSDA-Hubbard-Fortran ","text":"type, public :: system_params_t System parameters for LSDA-Hubbard calculations Components Type Visibility Attributes Name Initial integer, public :: L Number of lattice sites integer, public :: Nup Number of spin-up electrons (N↑) integer, public :: Ndown Number of spin-down electrons (N↓) integer, public :: bc Boundary conditions: 0=open, 1=periodic, 2=twisted real(kind=dp), public :: U Hubbard interaction strength (in units of hopping t=1) real(kind=dp), public :: phase Twist angle for twisted BC (in units of π), only used if bc=2 Source Code type :: system_params_t integer :: L !< Number of lattice sites integer :: Nup !< Number of spin-up electrons (N↑) integer :: Ndown !< Number of spin-down electrons (N↓) integer :: bc !< Boundary conditions: 0=open, 1=periodic, 2=twisted real ( dp ) :: U !< Hubbard interaction strength (in units of hopping t=1) real ( dp ) :: phase !< Twist angle for twisted BC (in units of π), only used if bc=2 end type system_params_t","tags":"","url":"type/system_params_t.html"},{"title":"grid_params_t – LSDA-Hubbard-Fortran ","text":"type, public :: grid_params_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: n_min = 0.1_dp Minimum density real(kind=dp), public :: n_max = 2.0_dp Maximum density integer, public :: n_points = 50 Number of density points integer, public :: m_points = 51 Number of magnetization points (per n) integer, public :: L = 100 System size real(kind=dp), public :: delta_n = 1.0e-4_dp Finite difference increment Source Code type , public :: grid_params_t real ( dp ) :: n_min = 0.1_dp !< Minimum density real ( dp ) :: n_max = 2.0_dp !< Maximum density integer :: n_points = 50 !< Number of density points integer :: m_points = 51 !< Number of magnetization points (per n) integer :: L = 100 !< System size real ( dp ) :: delta_n = 1.0e-4_dp !< Finite difference increment end type grid_params_t","tags":"","url":"type/grid_params_t.html"},{"title":"xc_potentials_t – LSDA-Hubbard-Fortran ","text":"type, public :: xc_potentials_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: v_xc_up real(kind=dp), public :: v_xc_down Source Code type , public :: xc_potentials_t real ( dp ) :: v_xc_up , v_xc_down end type xc_potentials_t","tags":"","url":"type/xc_potentials_t.html"},{"title":"xc_table_t – LSDA-Hubbard-Fortran ","text":"type, public :: xc_table_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: U integer, public :: n_points_n integer, public :: n_points_m real(kind=dp), public, allocatable :: n_grid (:) real(kind=dp), public, allocatable :: m_grid (:,:) real(kind=dp), public, allocatable :: exc (:,:) real(kind=dp), public, allocatable :: vxc_up (:,:) real(kind=dp), public, allocatable :: vxc_down (:,:) Source Code type :: xc_table_t real ( dp ) :: U integer :: n_points_n integer :: n_points_m real ( dp ), allocatable :: n_grid (:) real ( dp ), allocatable :: m_grid (:,:) real ( dp ), allocatable :: exc (:,:) real ( dp ), allocatable :: vxc_up (:,:) real ( dp ), allocatable :: vxc_down (:,:) end type xc_table_t","tags":"","url":"type/xc_table_t.html"},{"title":"adaptive_mix_t – LSDA-Hubbard-Fortran ","text":"type, public :: adaptive_mix_t Adaptive mixing control parameters Components Type Visibility Attributes Name Initial integer, public :: iter = 0 Current iteration integer, public :: count_sc = 0 Count within energy band integer, public :: count_bot = 0 Count when hitting bottom integer, public :: count_top = 0 Count when hitting top integer, public :: count_sc_max = 10 Max iterations in band before UpMix real(kind=dp), public :: mix = INITIAL_MIX Current mixing parameter (C++ convention) real(kind=dp), public :: energy_top = 0.0_dp Upper energy bound real(kind=dp), public :: energy_bot = 0.0_dp Lower energy bound real(kind=dp), public :: energy_new = 0.0_dp Current energy real(kind=dp), public :: energy_old = 0.0_dp Previous energy real(kind=dp), public :: tol = 1.0e-8_dp Convergence tolerance logical, public :: converged = .false. Convergence flag Source Code type , public :: adaptive_mix_t integer :: iter = 0 !< Current iteration integer :: count_sc = 0 !< Count within energy band integer :: count_bot = 0 !< Count when hitting bottom integer :: count_top = 0 !< Count when hitting top integer :: count_sc_max = 10 !< Max iterations in band before UpMix real ( dp ) :: mix = INITIAL_MIX !< Current mixing parameter (C++ convention) real ( dp ) :: energy_top = 0.0_dp !< Upper energy bound real ( dp ) :: energy_bot = 0.0_dp !< Lower energy bound real ( dp ) :: energy_new = 0.0_dp !< Current energy real ( dp ) :: energy_old = 0.0_dp !< Previous energy real ( dp ) :: tol = 1.0e-8_dp !< Convergence tolerance logical :: converged = . false . !< Convergence flag end type adaptive_mix_t","tags":"","url":"type/adaptive_mix_t.html"},{"title":"write_results – LSDA-Hubbard-Fortran","text":"public  subroutine write_results(results, sys_params, inputs, ierr) Write all simulation results Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(in) :: results type( system_params_t ), intent(in) :: sys_params type( input_params_t ), intent(in) :: inputs integer, intent(out) :: ierr Calls proc~~write_results~~CallsGraph proc~write_results write_results proc~write_convergence_history write_convergence_history proc~write_results->proc~write_convergence_history proc~write_density_profile write_density_profile proc~write_results->proc~write_density_profile proc~write_eigenvalues write_eigenvalues proc~write_results->proc~write_eigenvalues proc~write_summary write_summary proc~write_results->proc~write_summary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine write_results ( results , sys_params , inputs , ierr ) type ( scf_results_t ), intent ( in ) :: results type ( system_params_t ), intent ( in ) :: sys_params type ( input_params_t ), intent ( in ) :: inputs integer , intent ( out ) :: ierr character ( len = 256 ) :: prefix ierr = ERROR_SUCCESS prefix = trim ( inputs % output_prefix ) call write_summary ( results , sys_params , inputs , ierr ) if ( ierr /= ERROR_SUCCESS ) return if ( inputs % save_density ) then call write_density_profile ( results , sys_params , prefix , ierr ) if ( ierr /= ERROR_SUCCESS ) return end if if ( inputs % save_eigenvalues ) then call write_eigenvalues ( results , sys_params , prefix , ierr ) if ( ierr /= ERROR_SUCCESS ) return end if if ( inputs % store_history . and . allocated ( results % history % density_norms )) then call write_convergence_history ( results , prefix , ierr ) if ( ierr /= ERROR_SUCCESS ) return end if end subroutine write_results","tags":"","url":"proc/write_results.html"},{"title":"write_summary – LSDA-Hubbard-Fortran","text":"public  subroutine write_summary(results, sys_params, inputs, ierr) Write summary to stdout and file Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(in) :: results type( system_params_t ), intent(in) :: sys_params type( input_params_t ), intent(in) :: inputs integer, intent(out) :: ierr Called by proc~~write_summary~~CalledByGraph proc~write_summary write_summary proc~write_results write_results proc~write_results->proc~write_summary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine write_summary ( results , sys_params , inputs , ierr ) type ( scf_results_t ), intent ( in ) :: results type ( system_params_t ), intent ( in ) :: sys_params type ( input_params_t ), intent ( in ) :: inputs integer , intent ( out ) :: ierr character ( len = 256 ) :: filename integer :: io_unit , io_stat real ( dp ) :: total_density ierr = ERROR_SUCCESS print '(A)' , \"\" print '(A)' , \"==========================================\" print '(A)' , \"         SIMULATION RESULTS\" print '(A)' , \"==========================================\" print '(A)' , \"\" print '(A)' , \"System Parameters:\" print '(A,I0)' , \"  L (sites):        \" , sys_params % L print '(A,I0)' , \"  N_up:             \" , sys_params % Nup print '(A,I0)' , \"  N_down:           \" , sys_params % Ndown print '(A,I0)' , \"  N_total:          \" , sys_params % Nup + sys_params % Ndown print '(A,F0.4)' , \"  U:                \" , sys_params % U if ( sys_params % bc == 2 ) then print '(A,F0.4)' , \"  Phase:            \" , sys_params % phase end if print '(A)' , \"\" print '(A)' , \"SCF Convergence:\" if ( results % converged ) then print '(A)' , \"  Status:           ✓ CONVERGED\" else print '(A)' , \"  Status:           ✗ NOT CONVERGED\" end if print '(A,I0)' , \"  Iterations:       \" , results % n_iterations print '(A,ES12.4)' , \"  Final |Δn|:       \" , results % final_density_error if ( allocated ( results % density_up )) then print '(A,F20.12)' , \"  Final Energy per site: \" , results % final_energy / size ( results % density_up ) else print '(A,F20.12)' , \"  Final Energy per site: \" , results % final_energy end if print '(A)' , \"\" if ( allocated ( results % density_up )) then total_density = sum ( results % density_up ) + sum ( results % density_down ) print '(A)' , \"Density Check:\" print '(A,F12.6)' , \"  ∫n_up dx:         \" , sum ( results % density_up ) print '(A,F12.6)' , \"  ∫n_down dx:       \" , sum ( results % density_down ) print '(A,F12.6)' , \"  ∫n_total dx:      \" , total_density print '(A,F12.6)' , \"  Expected N:       \" , real ( sys_params % Nup + sys_params % Ndown , dp ) print '(A,ES12.4)' , \"  Error:            \" , abs ( total_density - real ( sys_params % Nup + sys_params % Ndown , dp )) print '(A)' , \"\" end if print '(A)' , \"Output Files:\" print '(A,A)' , \"  Prefix:           \" , trim ( inputs % output_prefix ) if ( inputs % save_density ) then print '(A,A)' , \"  Density:          \" , trim ( inputs % output_prefix ) // \"_density.dat\" end if if ( inputs % save_eigenvalues ) then print '(A,A)' , \"  Eigenvalues:      \" , trim ( inputs % output_prefix ) // \"_eigenvalues.dat\" end if if ( inputs % store_history ) then print '(A,A)' , \"  Convergence:      \" , trim ( inputs % output_prefix ) // \"_convergence.dat\" end if print '(A)' , \"\" print '(A)' , \"==========================================\" print '(A)' , \"\" filename = trim ( inputs % output_prefix ) // \"_summary.txt\" open ( newunit = io_unit , file = filename , status = 'replace' , iostat = io_stat ) if ( io_stat /= 0 ) then print * , \"WARNING: Could not write summary file: \" , trim ( filename ) ierr = ERROR_FILE_WRITE return end if write ( io_unit , '(A)' ) \"LSDA-Hubbard Simulation Summary\" write ( io_unit , '(A)' ) \"================================\" write ( io_unit , '(A)' ) \"\" write ( io_unit , '(A,I0)' ) \"L = \" , sys_params % L write ( io_unit , '(A,I0)' ) \"Nup = \" , sys_params % Nup write ( io_unit , '(A,I0)' ) \"Ndown = \" , sys_params % Ndown write ( io_unit , '(A,F0.4)' ) \"U = \" , sys_params % U write ( io_unit , '(A)' ) \"\" if ( results % converged ) then write ( io_unit , '(A)' ) \"SCF: CONVERGED\" else write ( io_unit , '(A)' ) \"SCF: NOT CONVERGED\" end if write ( io_unit , '(A,I0)' ) \"Iterations: \" , results % n_iterations write ( io_unit , '(A,ES12.4)' ) \"Final |Δn|: \" , results % final_density_error if ( allocated ( results % density_up )) then write ( io_unit , '(A,F20.12)' ) \"Final Energy: \" , results % final_energy / size ( results % density_up ) else write ( io_unit , '(A,F20.12)' ) \"Final Energy: \" , results % final_energy end if close ( io_unit ) ierr = ERROR_SUCCESS end subroutine write_summary","tags":"","url":"proc/write_summary.html"},{"title":"write_density_profile – LSDA-Hubbard-Fortran","text":"public  subroutine write_density_profile(results, sys_params, prefix, ierr) Write density profile to file Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(in) :: results type( system_params_t ), intent(in) :: sys_params character(len=*), intent(in) :: prefix integer, intent(out) :: ierr Called by proc~~write_density_profile~~CalledByGraph proc~write_density_profile write_density_profile proc~write_results write_results proc~write_results->proc~write_density_profile Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine write_density_profile ( results , sys_params , prefix , ierr ) type ( scf_results_t ), intent ( in ) :: results type ( system_params_t ), intent ( in ) :: sys_params character ( len =* ), intent ( in ) :: prefix integer , intent ( out ) :: ierr character ( len = 256 ) :: filename integer :: io_unit , io_stat , i ierr = ERROR_SUCCESS if (. not . allocated ( results % density_up )) then print * , \"WARNING: Density not available, skipping density output\" return end if filename = trim ( prefix ) // \"_density.dat\" open ( newunit = io_unit , file = filename , status = 'replace' , iostat = io_stat ) if ( io_stat /= 0 ) then print * , \"ERROR: Could not write density file: \" , trim ( filename ) ierr = ERROR_FILE_WRITE return end if write ( io_unit , '(A)' ) \"# Density profile from LSDA-Hubbard calculation\" write ( io_unit , '(A,I0)' ) \"# L = \" , sys_params % L write ( io_unit , '(A,I0)' ) \"# Nup = \" , sys_params % Nup write ( io_unit , '(A,I0)' ) \"# Ndown = \" , sys_params % Ndown write ( io_unit , '(A,F0.4)' ) \"# U = \" , sys_params % U write ( io_unit , '(A)' ) \"#\" write ( io_unit , '(A)' ) \"# Columns: site  n_up  n_down  n_total\" do i = 1 , sys_params % L write ( io_unit , '(I6,3ES20.10)' ) i , results % density_up ( i ), & results % density_down ( i ), & results % density_up ( i ) + results % density_down ( i ) end do close ( io_unit ) print '(A,A)' , \"  Density profile written to: \" , trim ( filename ) ierr = ERROR_SUCCESS end subroutine write_density_profile","tags":"","url":"proc/write_density_profile.html"},{"title":"write_eigenvalues – LSDA-Hubbard-Fortran","text":"public  subroutine write_eigenvalues(results, sys_params, prefix, ierr) Write eigenvalues to file Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(in) :: results type( system_params_t ), intent(in) :: sys_params character(len=*), intent(in) :: prefix integer, intent(out) :: ierr Called by proc~~write_eigenvalues~~CalledByGraph proc~write_eigenvalues write_eigenvalues proc~write_results write_results proc~write_results->proc~write_eigenvalues Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine write_eigenvalues ( results , sys_params , prefix , ierr ) type ( scf_results_t ), intent ( in ) :: results type ( system_params_t ), intent ( in ) :: sys_params character ( len =* ), intent ( in ) :: prefix integer , intent ( out ) :: ierr character ( len = 256 ) :: filename integer :: io_unit , io_stat , i , L ierr = ERROR_SUCCESS if (. not . allocated ( results % eigvals )) then print * , \"WARNING: Eigenvalues not available, skipping eigenvalue output\" return end if L = sys_params % L filename = trim ( prefix ) // \"_eigenvalues.dat\" open ( newunit = io_unit , file = filename , status = 'replace' , iostat = io_stat ) if ( io_stat /= 0 ) then print * , \"ERROR: Could not write eigenvalues file: \" , trim ( filename ) ierr = ERROR_FILE_WRITE return end if ! Write header write ( io_unit , '(A)' ) \"# Eigenvalues from LSDA-Hubbard calculation\" write ( io_unit , '(A,I0)' ) \"# L = \" , L write ( io_unit , '(A,I0)' ) \"# Nup = \" , sys_params % Nup write ( io_unit , '(A,I0)' ) \"# Ndown = \" , sys_params % Ndown write ( io_unit , '(A,F0.4)' ) \"# U = \" , sys_params % U write ( io_unit , '(A)' ) \"#\" write ( io_unit , '(A)' ) \"# First L eigenvalues: spin-up\" write ( io_unit , '(A)' ) \"# Last L eigenvalues: spin-down\" write ( io_unit , '(A)' ) \"#\" write ( io_unit , '(A)' ) \"# Columns: index  spin  eigenvalue  occupied\" do i = 1 , L if ( i <= sys_params % Nup ) then write ( io_unit , '(I6,A8,ES20.10,A8)' ) i , \"up\" , results % eigvals ( i ), \"yes\" else write ( io_unit , '(I6,A8,ES20.10,A8)' ) i , \"up\" , results % eigvals ( i ), \"no\" end if end do do i = 1 , L if ( i <= sys_params % Ndown ) then write ( io_unit , '(I6,A8,ES20.10,A8)' ) i , \"down\" , results % eigvals ( L + i ), \"yes\" else write ( io_unit , '(I6,A8,ES20.10,A8)' ) i , \"down\" , results % eigvals ( L + i ), \"no\" end if end do close ( io_unit ) print '(A,A)' , \"  Eigenvalues written to: \" , trim ( filename ) ierr = ERROR_SUCCESS end subroutine write_eigenvalues","tags":"","url":"proc/write_eigenvalues.html"},{"title":"write_convergence_history – LSDA-Hubbard-Fortran","text":"public  subroutine write_convergence_history(results, prefix, ierr) Write convergence history to file Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(in) :: results character(len=*), intent(in) :: prefix integer, intent(out) :: ierr Called by proc~~write_convergence_history~~CalledByGraph proc~write_convergence_history write_convergence_history proc~write_results write_results proc~write_results->proc~write_convergence_history Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine write_convergence_history ( results , prefix , ierr ) type ( scf_results_t ), intent ( in ) :: results character ( len =* ), intent ( in ) :: prefix integer , intent ( out ) :: ierr character ( len = 256 ) :: filename integer :: io_unit , io_stat , i ierr = ERROR_SUCCESS if (. not . allocated ( results % history % density_norms )) then return end if filename = trim ( prefix ) // \"_convergence.dat\" open ( newunit = io_unit , file = filename , status = 'replace' , iostat = io_stat ) if ( io_stat /= 0 ) then print * , \"ERROR: Could not write convergence file: \" , trim ( filename ) ierr = ERROR_FILE_WRITE return end if write ( io_unit , '(A)' ) \"# SCF convergence history\" write ( io_unit , '(A)' ) \"#\" write ( io_unit , '(A)' ) \"# Columns: iteration  |Δn|  energy\" do i = 1 , results % history % current_iter write ( io_unit , '(I6,2ES20.10)' ) i , & results % history % density_norms ( i ), & results % history % energies ( i ) end do close ( io_unit ) print '(A,A)' , \"  Convergence history written to: \" , trim ( filename ) ierr = ERROR_SUCCESS end subroutine write_convergence_history","tags":"","url":"proc/write_convergence_history.html"},{"title":"compute_total_energy – LSDA-Hubbard-Fortran","text":"public  subroutine compute_total_energy(eigvals_up, eigvals_down, n_up, n_down, density_up, density_down, V_ext, xc_func, U, L, total_energy, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigvals_up (:) real(kind=dp), intent(in) :: eigvals_down (:) integer, intent(in) :: n_up integer, intent(in) :: n_down real(kind=dp), intent(in) :: density_up (:) real(kind=dp), intent(in) :: density_down (:) real(kind=dp), intent(in) :: V_ext (:) type( xc_lsda_t ), intent(in) :: xc_func real(kind=dp), intent(in) :: U integer, intent(in) :: L real(kind=dp), intent(out) :: total_energy integer, intent(out) :: ierr Calls proc~~compute_total_energy~~CallsGraph proc~compute_total_energy compute_total_energy proc~get_exc get_exc proc~compute_total_energy->proc~get_exc proc~get_vxc get_vxc proc~compute_total_energy->proc~get_vxc proc~apply_symmetry_transform apply_symmetry_transform proc~get_exc->proc~apply_symmetry_transform proc~convert_to_nm convert_to_nm proc~get_exc->proc~convert_to_nm proc~determine_region determine_region proc~get_exc->proc~determine_region proc~spline2d_eval spline2d_eval proc~get_exc->proc~spline2d_eval proc~get_vxc->proc~apply_symmetry_transform proc~get_vxc->proc~convert_to_nm proc~get_vxc->proc~determine_region proc~get_vxc->proc~spline2d_eval d2y_tmp d2y_tmp proc~spline2d_eval->d2y_tmp f_tmp f_tmp proc~spline2d_eval->f_tmp proc~find_interval find_interval proc~spline2d_eval->proc~find_interval proc~spline1d_eval spline1d_eval proc~spline2d_eval->proc~spline1d_eval y_tmp y_tmp proc~spline2d_eval->y_tmp proc~spline1d_eval->proc~find_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_total_energy~~CalledByGraph proc~compute_total_energy compute_total_energy proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~compute_total_energy proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~compute_total_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_total_energy ( eigvals_up , eigvals_down , n_up , n_down , density_up , density_down , & V_ext , xc_func , U , L , total_energy , ierr ) real ( dp ), intent ( in ) :: eigvals_up (:), eigvals_down (:) integer , intent ( in ) :: n_up , n_down real ( dp ), intent ( in ) :: density_up (:), density_down (:), V_ext (:) type ( xc_lsda_t ), intent ( in ) :: xc_func real ( dp ), intent ( in ) :: U integer , intent ( in ) :: L real ( dp ), intent ( out ) :: total_energy integer , intent ( out ) :: ierr real ( dp ) :: E_band , E_hartree , E_xc_total , V_xc_correction real ( dp ) :: exc_val , V_xc_up , V_xc_down integer :: i ! 1. Band energy (sum of occupied eigenvalues) E_band = sum ( eigvals_up ( 1 : n_up )) + sum ( eigvals_down ( 1 : n_down )) ! 2. Hartree energy: -U*Σ(n_up*n_down) !    Double-counting correction (matches C++ lsdaks.cc lines 676-679) !    Derivation: eigenvalues include V_eff = V_ext + U*n_other + V_xc !    When we sum v_eff*n for both spins, we get 2*U*n_up*n_down !    But we only want U*n_up*n_down, so we SUBTRACT U*n_up*n_down E_hartree = 0.0_dp do i = 1 , L E_hartree = E_hartree + density_up ( i ) * density_down ( i ) end do E_hartree = - U * E_hartree ! Negative sign! ! 3. Exchange-correlation energy and potential correction E_xc_total = 0.0_dp V_xc_correction = 0.0_dp do i = 1 , L call get_exc ( xc_func , density_up ( i ), density_down ( i ), exc_val , ierr ) if ( ierr /= ERROR_SUCCESS ) then return end if call get_vxc ( xc_func , density_up ( i ), density_down ( i ), & V_xc_up , V_xc_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then return end if ! Note: exc_val is already the total XC energy at site i, not per particle! ! C++ just adds exc[i], not exc[i]*n_total[i] E_xc_total = E_xc_total + exc_val ! V_xc correction for double-counting V_xc_correction = V_xc_correction + V_xc_up * density_up ( i ) + V_xc_down * density_down ( i ) end do ! Total: E_band + E_hartree + E_xc - V_xc (matches C++ lsdaks.cc line 676-679) total_energy = E_band + E_hartree + E_xc_total - V_xc_correction ierr = ERROR_SUCCESS end subroutine compute_total_energy","tags":"","url":"proc/compute_total_energy.html"},{"title":"validate_kohn_sham_cycle_inputs – LSDA-Hubbard-Fortran","text":"private  subroutine validate_kohn_sham_cycle_inputs(params, scf_params, V_ext, ierr) Arguments Type Intent Optional Attributes Name type( system_params_t ), intent(in) :: params type( scf_params_t ), intent(in) :: scf_params real(kind=dp), intent(in) :: V_ext (:) integer, intent(out) :: ierr Called by proc~~validate_kohn_sham_cycle_inputs~~CalledByGraph proc~validate_kohn_sham_cycle_inputs validate_kohn_sham_cycle_inputs proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~validate_kohn_sham_cycle_inputs proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~validate_kohn_sham_cycle_inputs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine validate_kohn_sham_cycle_inputs ( params , scf_params , V_ext , ierr ) type ( system_params_t ), intent ( in ) :: params type ( scf_params_t ), intent ( in ) :: scf_params real ( dp ), intent ( in ) :: V_ext (:) integer , intent ( out ) :: ierr integer :: L , Nup , Ndown L = params % L Nup = params % Nup Ndown = params % Ndown if ( L <= 0 . or . Nup < 0 . or . Ndown < 0 . or . ( Nup + Ndown ) > 2 * L ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( V_ext ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( scf_params % max_iter <= 0 . or . scf_params % mixing_alpha < 0.0_dp . or . & scf_params % mixing_alpha > 1.0_dp ) then ierr = ERROR_INVALID_INPUT return end if ierr = ERROR_SUCCESS end subroutine validate_kohn_sham_cycle_inputs","tags":"","url":"proc/validate_kohn_sham_cycle_inputs.html"},{"title":"run_kohn_sham_scf_real – LSDA-Hubbard-Fortran","text":"public  subroutine run_kohn_sham_scf_real(params, scf_params, V_ext, xc_func, results, ierr) Arguments Type Intent Optional Attributes Name type( system_params_t ), intent(in) :: params type( scf_params_t ), intent(in) :: scf_params real(kind=dp), intent(in) :: V_ext (:) type( xc_lsda_t ), intent(in) :: xc_func type( scf_results_t ), intent(out) :: results integer, intent(out) :: ierr Calls proc~~run_kohn_sham_scf_real~~CallsGraph proc~run_kohn_sham_scf_real run_kohn_sham_scf_real interface~compute_density_spin compute_density_spin proc~run_kohn_sham_scf_real->interface~compute_density_spin proc~adaptive_mix_get_alpha adaptive_mix_get_alpha proc~run_kohn_sham_scf_real->proc~adaptive_mix_get_alpha proc~adaptive_mix_init adaptive_mix_init proc~run_kohn_sham_scf_real->proc~adaptive_mix_init proc~adaptive_mix_update adaptive_mix_update proc~run_kohn_sham_scf_real->proc~adaptive_mix_update proc~build_hamiltonian build_hamiltonian proc~run_kohn_sham_scf_real->proc~build_hamiltonian proc~check_scf_convergence check_scf_convergence proc~run_kohn_sham_scf_real->proc~check_scf_convergence proc~compute_density_difference compute_density_difference proc~run_kohn_sham_scf_real->proc~compute_density_difference proc~compute_density_norm compute_density_norm proc~run_kohn_sham_scf_real->proc~compute_density_norm proc~compute_total_energy compute_total_energy proc~run_kohn_sham_scf_real->proc~compute_total_energy proc~diagonalize_symmetric_real diagonalize_symmetric_real proc~run_kohn_sham_scf_real->proc~diagonalize_symmetric_real proc~get_vxc get_vxc proc~run_kohn_sham_scf_real->proc~get_vxc proc~init_convergence_history init_convergence_history proc~run_kohn_sham_scf_real->proc~init_convergence_history proc~update_convergence_history update_convergence_history proc~run_kohn_sham_scf_real->proc~update_convergence_history proc~validate_kohn_sham_cycle_inputs validate_kohn_sham_cycle_inputs proc~run_kohn_sham_scf_real->proc~validate_kohn_sham_cycle_inputs proc~compute_density_spin_complex compute_density_spin_complex interface~compute_density_spin->proc~compute_density_spin_complex proc~compute_density_spin_real compute_density_spin_real interface~compute_density_spin->proc~compute_density_spin_real proc~dw_mix dw_mix proc~adaptive_mix_update->proc~dw_mix proc~reset_counts reset_counts proc~adaptive_mix_update->proc~reset_counts proc~up_mix up_mix proc~adaptive_mix_update->proc~up_mix proc~apply_boundary_conditions apply_boundary_conditions proc~build_hamiltonian->proc~apply_boundary_conditions proc~validate_hamiltonian_inputs validate_hamiltonian_inputs proc~build_hamiltonian->proc~validate_hamiltonian_inputs proc~check_scf_convergence->proc~compute_density_norm proc~compute_total_energy->proc~get_vxc proc~get_exc get_exc proc~compute_total_energy->proc~get_exc interface~dsyevd DSYEVD proc~diagonalize_symmetric_real->interface~dsyevd proc~validate_diagonalization_inputs validate_diagonalization_inputs proc~diagonalize_symmetric_real->proc~validate_diagonalization_inputs proc~apply_symmetry_transform apply_symmetry_transform proc~get_vxc->proc~apply_symmetry_transform proc~convert_to_nm convert_to_nm proc~get_vxc->proc~convert_to_nm proc~determine_region determine_region proc~get_vxc->proc~determine_region proc~spline2d_eval spline2d_eval proc~get_vxc->proc~spline2d_eval proc~validate_bc_parameters validate_bc_parameters proc~apply_boundary_conditions->proc~validate_bc_parameters proc~get_exc->proc~apply_symmetry_transform proc~get_exc->proc~convert_to_nm proc~get_exc->proc~determine_region proc~get_exc->proc~spline2d_eval d2y_tmp d2y_tmp proc~spline2d_eval->d2y_tmp f_tmp f_tmp proc~spline2d_eval->f_tmp proc~find_interval find_interval proc~spline2d_eval->proc~find_interval proc~spline1d_eval spline1d_eval proc~spline2d_eval->proc~spline1d_eval y_tmp y_tmp proc~spline2d_eval->y_tmp proc~spline1d_eval->proc~find_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine run_kohn_sham_scf_real ( params , scf_params , V_ext , xc_func , results , ierr ) type ( system_params_t ), intent ( in ) :: params type ( scf_params_t ), intent ( in ) :: scf_params real ( dp ), intent ( in ) :: V_ext (:) type ( xc_lsda_t ), intent ( in ) :: xc_func type ( scf_results_t ), intent ( out ) :: results integer , intent ( out ) :: ierr integer :: iter , i , L , Nup , Ndown real ( dp ) :: density_error , total_energy logical :: is_converged type ( adaptive_mix_t ) :: mix_ctrl real ( dp ) :: current_alpha real ( dp ), allocatable :: n_up_in (:), n_down_in (:), n_up_out (:), n_down_out (:), V_xc_up (:), & V_xc_down (:), H_up (:,:), H_down (:,:), eigvals_up (:), & eigvals_down (:), eigvecs_up (:,:), eigvecs_down (:,:), delta_n_up (:), delta_n_down (:), & delta_n_total (:), V_eff_up (:), V_eff_down (:), V_eff_up_calc (:), V_eff_down_calc (:), & V_zero (:) call validate_kohn_sham_cycle_inputs ( params , scf_params , V_ext , ierr ) if ( ierr /= ERROR_SUCCESS ) then return end if L = params % L Nup = params % Nup Ndown = params % Ndown allocate ( n_up_in ( L ), n_down_in ( L ), n_up_out ( L ), n_down_out ( L ), V_xc_up ( L ), V_xc_down ( L ), & H_up ( L , L ), H_down ( L , L ), eigvals_up ( L ), eigvals_down ( L ), & eigvecs_up ( L , L ), eigvecs_down ( L , L ), delta_n_up ( L ), delta_n_down ( L ), delta_n_total ( L ), & V_eff_up ( L ), V_eff_down ( L ), V_eff_up_calc ( L ), V_eff_down_calc ( L ), V_zero ( L )) ! Initialize zero array for Hamiltonian builder V_zero (:) = 0.0_dp call init_convergence_history ( results % history , scf_params % max_iter , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for history init deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc ) return end if ! Initialize densities (uniform guess) n_up_in (:) = real ( params % Nup , dp ) / real ( params % L , dp ) n_down_in (:) = real ( params % Ndown , dp ) / real ( params % L , dp ) ! Initialize effective potentials from initial density guess ! This matches C++ initial_guess() function (lsdaks.cc lines 520-521) ! V_eff = V_ext + U*n_other + V_xc do i = 1 , params % L ! Get V_xc from initial uniform density call get_vxc ( xc_func , n_up_in ( i ), n_down_in ( i ), V_xc_up ( i ), V_xc_down ( i ), ierr ) if ( ierr /= ERROR_SUCCESS ) then deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if ! Initialize V_eff = V_ext + U*n_other + V_xc (like C++) V_eff_up ( i ) = V_ext ( i ) + params % U * n_down_in ( i ) + V_xc_up ( i ) V_eff_down ( i ) = V_ext ( i ) + params % U * n_up_in ( i ) + V_xc_down ( i ) end do ! ================================= ! Initialize adaptive mixing (if enabled) ! ================================= if ( scf_params % use_adaptive_mixing ) then call adaptive_mix_init ( mix_ctrl , scf_params % energy_tol ) if ( scf_params % verbose ) then print '(A)' , \"  Using adaptive mixing (C++ behavior)\" end if else if ( scf_params % verbose ) then print '(A,F6.4)' , \"  Using fixed mixing alpha = \" , scf_params % mixing_alpha end if end if ! ================= ! STEP 1: SCF loop ! ================= do iter = 1 , scf_params % max_iter ! ------------------------------------------------- ! 1a. Compute V_xc from current densities ! ------------------------------------------------- do i = 1 , params % L call get_vxc ( xc_func , n_up_in ( i ), n_down_in ( i ), V_xc_up ( i ), V_xc_down ( i ), ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for V_xc calculation deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if end do ! ------------------------------------------------------------- ! 1b. Calculate effective potentials V_eff = V_ext + U*n_other + V_xc ! (This is what C++ calls \"v_ext[σ][j] + u*dens[other][j] + Vxc[σ][j]\") ! ------------------------------------------------------------- do i = 1 , params % L ! V_eff_up_calc = V_ext + U*n_down + V_xc_up V_eff_up_calc ( i ) = V_ext ( i ) + params % U * n_down_in ( i ) + V_xc_up ( i ) ! V_eff_down_calc = V_ext + U*n_up + V_xc_down V_eff_down_calc ( i ) = V_ext ( i ) + params % U * n_up_in ( i ) + V_xc_down ( i ) end do ! ------------------------------------------------------------- ! 1c. Mix potentials (C++ convention: Mix = weight of OLD) ! V_eff_new = Mix*V_eff_old + (1-Mix)*V_eff_calc ! ------------------------------------------------------------- if ( scf_params % use_adaptive_mixing ) then ! Adaptive mixing uses the Mix parameter (updated each iteration) ! Convert to fortran alpha: alpha = 1 - Mix current_alpha = adaptive_mix_get_alpha ( mix_ctrl ) ! Apply mixing: V = (1-α)*V_old + α*V_calc = Mix*V_old + (1-Mix)*V_calc ! Since alpha = 1-Mix, we have: V = Mix*V_old + (1-Mix)*V_calc ✓ do i = 1 , params % L V_eff_up ( i ) = ( 1.0_dp - current_alpha ) * V_eff_up ( i ) + current_alpha * V_eff_up_calc ( i ) V_eff_down ( i ) = ( 1.0_dp - current_alpha ) * V_eff_down ( i ) + current_alpha * V_eff_down_calc ( i ) end do else ! Fixed mixing: alpha = weight of new current_alpha = scf_params % mixing_alpha do i = 1 , params % L V_eff_up ( i ) = ( 1.0_dp - current_alpha ) * V_eff_up ( i ) + current_alpha * V_eff_up_calc ( i ) V_eff_down ( i ) = ( 1.0_dp - current_alpha ) * V_eff_down ( i ) + current_alpha * V_eff_down_calc ( i ) end do end if ! ------------------------------------- ! 1d. Build Hamiltonians with mixed V_eff ! (C++ passes v_eff to hamiltonian_ks) ! ------------------------------------- call build_hamiltonian ( params % L , V_eff_up , V_zero , params % bc , params % phase , H_up , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Hamiltonian Nup build deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if call build_hamiltonian ( params % L , V_eff_down , V_zero , params % bc , params % phase , H_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Hamiltonian Ndown build deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if ! --------------------------------- ! 1d. Diagonalize both Hamiltonians ! --------------------------------- call diagonalize_symmetric_real ( H_up , params % L , eigvals_up , eigvecs_up , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for diagonalization Nup Hamiltonian deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if call diagonalize_symmetric_real ( H_down , params % L , eigvals_down , eigvecs_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for diagonalization Ndown Hamiltonian deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ---------------------------------------------- ! 1e. Compute new densities from eigenvectors ! ---------------------------------------------- call compute_density_spin ( eigvecs_up , params % L , params % Nup , n_up_out , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for density calculation Nup deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if call compute_density_spin ( eigvecs_down , params % L , params % Ndown , n_down_out , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for density calculation Ndown deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ---------------------------------------------- ! 1f. Compute density differences ! ---------------------------------------------- call compute_density_difference ( n_up_out , n_up_in , params % L , delta_n_up , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Nup density difference deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if call compute_density_difference ( n_down_out , n_down_in , params % L , delta_n_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Ndown density difference deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------------------ ! 1g. Compute total density error ! ------------------------------ delta_n_total = delta_n_up + delta_n_down call compute_density_norm ( delta_n_total , params % L , L2 , density_error , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for total density up norm deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------------ ! 1h. Compute total energy ! ------------------------ call compute_total_energy ( eigvals_up , eigvals_down , params % Nup , params % Ndown , n_up_out , n_down_out , & V_ext , xc_func , params % U , params % L , total_energy , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for total energy calculation deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------ ! 1i. Store history ! ------------------ if ( scf_params % store_history ) then call update_convergence_history ( iter , density_error , total_energy , results % history , ierr ) end if if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for history update deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------------------ ! 1j. Update adaptive mixing (if enabled) ! ------------------------------ if ( scf_params % use_adaptive_mixing ) then call adaptive_mix_update ( mix_ctrl , total_energy ) current_alpha = adaptive_mix_get_alpha ( mix_ctrl ) if ( scf_params % verbose ) then print '(A,I4,A,ES12.4,A,F16.8,A,F7.5)' , \"  Iter \" , iter , \"  |Δn| = \" , density_error , & \"  E_tot = \" , total_energy , \"  α = \" , current_alpha end if ! Check convergence: density-based (primary) OR energy-based (fallback) ! With potential mixing, density converges even if energy oscillates slightly call check_scf_convergence ( delta_n_total , params % L , scf_params % density_tol , & is_converged , ierr ) if ( ierr /= ERROR_SUCCESS . or . . not . is_converged ) then ! Density not converged OR error - fall back to energy-based check is_converged = mix_ctrl % converged end if else current_alpha = scf_params % mixing_alpha if ( scf_params % verbose ) then print '(A,I4,A,ES12.4,A,F16.8)' , \"  Iter \" , iter , \"  |Δn| = \" , density_error , & \"  E_tot = \" , total_energy end if ! 1k. Check convergence (fixed mixing) call check_scf_convergence ( delta_n_total , params % L , scf_params % density_tol , & is_converged , ierr ) end if ! Validate convergence check if (. not . scf_params % use_adaptive_mixing . and . ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for convergence check deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if if ( is_converged ) then ! SUCCESS: Converged! results % converged = . true . results % n_iterations = iter results % final_density_error = density_error results % final_energy = total_energy ! Store final densities and eigenvalues allocate ( results % density_up ( params % L )) allocate ( results % density_down ( params % L )) allocate ( results % eigvals ( 2 * params % L )) results % density_up = n_up_out results % density_down = n_down_out results % eigvals ( 1 : params % L ) = eigvals_up results % eigvals ( params % L + 1 : 2 * params % L ) = eigvals_down ierr = ERROR_SUCCESS return ! return SCF LOOP end if ! ----------------------------------------------------------------------- ! 1l. Copy densities directly (NO MIXING!) ! ----------------------------------------------------------------------- ! C++ code does: dens[0][i] = next_dens[0][i]  (line 695-696 in lsdaks.cc) ! Mixing is applied to POTENTIALS, not densities! n_up_in = n_up_out n_down_in = n_down_out end do ! ======================== ! STEP 2: Did not converge ! ======================== results % converged = . false . results % n_iterations = scf_params % max_iter results % final_density_error = density_error results % final_energy = total_energy ierr = ERROR_CONVERGENCE_FAILED deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) end subroutine run_kohn_sham_scf_real","tags":"","url":"proc/run_kohn_sham_scf_real.html"},{"title":"run_kohn_sham_scf_complex – LSDA-Hubbard-Fortran","text":"public  subroutine run_kohn_sham_scf_complex(params, scf_params, V_ext, xc_func, results, ierr) Arguments Type Intent Optional Attributes Name type( system_params_t ), intent(in) :: params type( scf_params_t ), intent(in) :: scf_params real(kind=dp), intent(in) :: V_ext (:) type( xc_lsda_t ), intent(in) :: xc_func type( scf_results_t ), intent(out) :: results integer, intent(out) :: ierr Calls proc~~run_kohn_sham_scf_complex~~CallsGraph proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex interface~compute_density_spin compute_density_spin proc~run_kohn_sham_scf_complex->interface~compute_density_spin proc~adaptive_mix_get_alpha adaptive_mix_get_alpha proc~run_kohn_sham_scf_complex->proc~adaptive_mix_get_alpha proc~adaptive_mix_init adaptive_mix_init proc~run_kohn_sham_scf_complex->proc~adaptive_mix_init proc~adaptive_mix_update adaptive_mix_update proc~run_kohn_sham_scf_complex->proc~adaptive_mix_update proc~build_hamiltonian_complex build_hamiltonian_complex proc~run_kohn_sham_scf_complex->proc~build_hamiltonian_complex proc~check_scf_convergence check_scf_convergence proc~run_kohn_sham_scf_complex->proc~check_scf_convergence proc~compute_density_difference compute_density_difference proc~run_kohn_sham_scf_complex->proc~compute_density_difference proc~compute_density_norm compute_density_norm proc~run_kohn_sham_scf_complex->proc~compute_density_norm proc~compute_total_energy compute_total_energy proc~run_kohn_sham_scf_complex->proc~compute_total_energy proc~diagonalize_hermitian_complex diagonalize_hermitian_complex proc~run_kohn_sham_scf_complex->proc~diagonalize_hermitian_complex proc~get_vxc get_vxc proc~run_kohn_sham_scf_complex->proc~get_vxc proc~init_convergence_history init_convergence_history proc~run_kohn_sham_scf_complex->proc~init_convergence_history proc~update_convergence_history update_convergence_history proc~run_kohn_sham_scf_complex->proc~update_convergence_history proc~validate_kohn_sham_cycle_inputs validate_kohn_sham_cycle_inputs proc~run_kohn_sham_scf_complex->proc~validate_kohn_sham_cycle_inputs proc~compute_density_spin_complex compute_density_spin_complex interface~compute_density_spin->proc~compute_density_spin_complex proc~compute_density_spin_real compute_density_spin_real interface~compute_density_spin->proc~compute_density_spin_real proc~dw_mix dw_mix proc~adaptive_mix_update->proc~dw_mix proc~reset_counts reset_counts proc~adaptive_mix_update->proc~reset_counts proc~up_mix up_mix proc~adaptive_mix_update->proc~up_mix proc~apply_boundary_conditions_complex apply_boundary_conditions_complex proc~build_hamiltonian_complex->proc~apply_boundary_conditions_complex proc~validate_hamiltonian_inputs validate_hamiltonian_inputs proc~build_hamiltonian_complex->proc~validate_hamiltonian_inputs proc~check_scf_convergence->proc~compute_density_norm proc~compute_total_energy->proc~get_vxc proc~get_exc get_exc proc~compute_total_energy->proc~get_exc interface~zheevd ZHEEVD proc~diagonalize_hermitian_complex->interface~zheevd proc~apply_symmetry_transform apply_symmetry_transform proc~get_vxc->proc~apply_symmetry_transform proc~convert_to_nm convert_to_nm proc~get_vxc->proc~convert_to_nm proc~determine_region determine_region proc~get_vxc->proc~determine_region proc~spline2d_eval spline2d_eval proc~get_vxc->proc~spline2d_eval proc~validate_bc_parameters validate_bc_parameters proc~apply_boundary_conditions_complex->proc~validate_bc_parameters proc~get_exc->proc~apply_symmetry_transform proc~get_exc->proc~convert_to_nm proc~get_exc->proc~determine_region proc~get_exc->proc~spline2d_eval d2y_tmp d2y_tmp proc~spline2d_eval->d2y_tmp f_tmp f_tmp proc~spline2d_eval->f_tmp proc~find_interval find_interval proc~spline2d_eval->proc~find_interval proc~spline1d_eval spline1d_eval proc~spline2d_eval->proc~spline1d_eval y_tmp y_tmp proc~spline2d_eval->y_tmp proc~spline1d_eval->proc~find_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine run_kohn_sham_scf_complex ( params , scf_params , V_ext , xc_func , results , ierr ) type ( system_params_t ), intent ( in ) :: params type ( scf_params_t ), intent ( in ) :: scf_params real ( dp ), intent ( in ) :: V_ext (:) type ( xc_lsda_t ), intent ( in ) :: xc_func type ( scf_results_t ), intent ( out ) :: results integer , intent ( out ) :: ierr integer :: iter , i , L , Nup , Ndown real ( dp ) :: density_error , total_energy logical :: is_converged type ( adaptive_mix_t ) :: mix_ctrl real ( dp ) :: current_alpha real ( dp ), allocatable :: n_up_in (:), n_down_in (:), n_up_out (:), n_down_out (:), V_xc_up (:), & V_xc_down (:), eigvals_up (:), eigvals_down (:), delta_n_up (:), delta_n_down (:), & delta_n_total (:), V_eff_up (:), V_eff_down (:), V_eff_up_calc (:), V_eff_down_calc (:), & V_zero (:) complex ( dp ), allocatable :: H_up (:,:), H_down (:,:), eigvecs_up (:,:), eigvecs_down (:,:) call validate_kohn_sham_cycle_inputs ( params , scf_params , V_ext , ierr ) if ( ierr /= ERROR_SUCCESS ) then return end if L = params % L Nup = params % Nup Ndown = params % Ndown allocate ( n_up_in ( L ), n_down_in ( L ), n_up_out ( L ), n_down_out ( L ), V_xc_up ( L ), V_xc_down ( L ), & H_up ( L , L ), H_down ( L , L ), eigvals_up ( L ), eigvals_down ( L ), & eigvecs_up ( L , L ), eigvecs_down ( L , L ), delta_n_up ( L ), delta_n_down ( L ), delta_n_total ( L ), & V_eff_up ( L ), V_eff_down ( L ), V_eff_up_calc ( L ), V_eff_down_calc ( L ), V_zero ( L )) ! Initialize zero array for Hamiltonian builder V_zero (:) = 0.0_dp call init_convergence_history ( results % history , scf_params % max_iter , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for history init deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if ! Initialize densities (uniform guess) n_up_in (:) = real ( params % Nup , dp ) / real ( params % L , dp ) n_down_in (:) = real ( params % Ndown , dp ) / real ( params % L , dp ) ! Initialize effective potentials from initial density guess ! This matches C++ initial_guess() function (lsdaks.cc lines 520-521) ! V_eff = V_ext + U*n_other + V_xc do i = 1 , params % L ! Get V_xc from initial uniform density call get_vxc ( xc_func , n_up_in ( i ), n_down_in ( i ), V_xc_up ( i ), V_xc_down ( i ), ierr ) if ( ierr /= ERROR_SUCCESS ) then deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if ! Initialize V_eff = V_ext + U*n_other + V_xc (like C++) V_eff_up ( i ) = V_ext ( i ) + params % U * n_down_in ( i ) + V_xc_up ( i ) V_eff_down ( i ) = V_ext ( i ) + params % U * n_up_in ( i ) + V_xc_down ( i ) end do ! ================================= ! Initialize adaptive mixing (if enabled) ! ================================= if ( scf_params % use_adaptive_mixing ) then call adaptive_mix_init ( mix_ctrl , scf_params % energy_tol ) if ( scf_params % verbose ) then print '(A)' , \"  Using adaptive mixing (C++ behavior)\" end if else if ( scf_params % verbose ) then print '(A,F6.4)' , \"  Using fixed mixing alpha = \" , scf_params % mixing_alpha end if end if ! ================= ! STEP 1: SCF loop ! ================= do iter = 1 , scf_params % max_iter ! ------------------------------------------------- ! 1a. Compute V_xc from current densities ! ------------------------------------------------- do i = 1 , params % L call get_vxc ( xc_func , n_up_in ( i ), n_down_in ( i ), V_xc_up ( i ), V_xc_down ( i ), ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for V_xc calculation deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if end do ! ------------------------------------------------------------- ! 1b. Calculate effective potentials V_eff = V_ext + U*n_other + V_xc ! (This is what C++ calls \"v_ext[σ][j] + u*dens[other][j] + Vxc[σ][j]\") ! ------------------------------------------------------------- do i = 1 , params % L ! V_eff_up_calc = V_ext + U*n_down + V_xc_up V_eff_up_calc ( i ) = V_ext ( i ) + params % U * n_down_in ( i ) + V_xc_up ( i ) ! V_eff_down_calc = V_ext + U*n_up + V_xc_down V_eff_down_calc ( i ) = V_ext ( i ) + params % U * n_up_in ( i ) + V_xc_down ( i ) end do ! ------------------------------------------------------------- ! 1c. Mix potentials (C++ convention: Mix = weight of OLD) ! V_eff_new = Mix*V_eff_old + (1-Mix)*V_eff_calc ! ------------------------------------------------------------- if ( scf_params % use_adaptive_mixing ) then ! Adaptive mixing uses the Mix parameter (updated each iteration) ! Convert to fortran alpha: alpha = 1 - Mix current_alpha = adaptive_mix_get_alpha ( mix_ctrl ) ! Apply mixing: V = (1-α)*V_old + α*V_calc = Mix*V_old + (1-Mix)*V_calc ! Since alpha = 1-Mix, we have: V = Mix*V_old + (1-Mix)*V_calc ✓ do i = 1 , params % L V_eff_up ( i ) = ( 1.0_dp - current_alpha ) * V_eff_up ( i ) + current_alpha * V_eff_up_calc ( i ) V_eff_down ( i ) = ( 1.0_dp - current_alpha ) * V_eff_down ( i ) + current_alpha * V_eff_down_calc ( i ) end do else ! Fixed mixing: alpha = weight of new current_alpha = scf_params % mixing_alpha do i = 1 , params % L V_eff_up ( i ) = ( 1.0_dp - current_alpha ) * V_eff_up ( i ) + current_alpha * V_eff_up_calc ( i ) V_eff_down ( i ) = ( 1.0_dp - current_alpha ) * V_eff_down ( i ) + current_alpha * V_eff_down_calc ( i ) end do end if ! ------------------------------------- ! 1d. Build Hamiltonians with mixed V_eff ! (C++ passes v_eff to hamiltonian_ks) ! ------------------------------------- call build_hamiltonian_complex ( params % L , V_eff_up , V_zero , params % bc , params % phase , H_up , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Hamiltonian Nup build deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if call build_hamiltonian_complex ( params % L , V_eff_down , V_zero , params % bc , params % phase , H_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Hamiltonian Ndown build deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if ! --------------------------------- ! 1d. Diagonalize both Hamiltonians ! --------------------------------- call diagonalize_hermitian_complex ( H_up , params % L , eigvals_up , eigvecs_up , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for diagonalization Nup Hamiltonian deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if call diagonalize_hermitian_complex ( H_down , params % L , eigvals_down , eigvecs_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for diagonalization Ndown Hamiltonian deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ---------------------------------------------- ! 1e. Compute new densities from eigenvectors ! ---------------------------------------------- call compute_density_spin ( eigvecs_up , params % L , params % Nup , n_up_out , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for density calculation Nup deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if call compute_density_spin ( eigvecs_down , params % L , params % Ndown , n_down_out , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for density calculation Ndown deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ---------------------------------------------- ! 1f. Compute density differences ! ---------------------------------------------- call compute_density_difference ( n_up_out , n_up_in , params % L , delta_n_up , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Nup density difference deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if call compute_density_difference ( n_down_out , n_down_in , params % L , delta_n_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Ndown density difference deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------------------ ! 1g. Compute total density error ! ------------------------------ delta_n_total = delta_n_up + delta_n_down call compute_density_norm ( delta_n_total , params % L , L2 , density_error , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for total density up norm deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------------ ! 1h. Compute total energy ! ------------------------ call compute_total_energy ( eigvals_up , eigvals_down , params % Nup , params % Ndown , n_up_out , n_down_out , & V_ext , xc_func , params % U , params % L , total_energy , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for total energy calculation deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------ ! 1i. Store history ! ------------------ if ( scf_params % store_history ) then call update_convergence_history ( iter , density_error , total_energy , results % history , ierr ) end if if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for history update deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------------------ ! 1j. Update adaptive mixing (if enabled) ! ------------------------------ if ( scf_params % use_adaptive_mixing ) then call adaptive_mix_update ( mix_ctrl , total_energy ) current_alpha = adaptive_mix_get_alpha ( mix_ctrl ) if ( scf_params % verbose ) then print '(A,I4,A,ES12.4,A,F16.8,A,F7.5)' , \"  Iter \" , iter , \"  |Δn| = \" , density_error , & \"  E_tot = \" , total_energy , \"  α = \" , current_alpha end if ! Check convergence: density-based (primary) OR energy-based (fallback) ! With potential mixing, density converges even if energy oscillates slightly call check_scf_convergence ( delta_n_total , params % L , scf_params % density_tol , & is_converged , ierr ) if ( ierr /= ERROR_SUCCESS . or . . not . is_converged ) then ! Density not converged OR error - fall back to energy-based check is_converged = mix_ctrl % converged end if else current_alpha = scf_params % mixing_alpha if ( scf_params % verbose ) then print '(A,I4,A,ES12.4,A,F16.8)' , \"  Iter \" , iter , \"  |Δn| = \" , density_error , & \"  E_tot = \" , total_energy end if ! 1k. Check convergence (fixed mixing) call check_scf_convergence ( delta_n_total , params % L , scf_params % density_tol , & is_converged , ierr ) end if ! Validate convergence check if (. not . scf_params % use_adaptive_mixing . and . ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for convergence check deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if if ( is_converged ) then ! SUCCESS: Converged! results % converged = . true . results % n_iterations = iter results % final_density_error = density_error results % final_energy = total_energy ! Store final densities and eigenvalues allocate ( results % density_up ( params % L )) allocate ( results % density_down ( params % L )) allocate ( results % eigvals ( 2 * params % L )) results % density_up = n_up_out results % density_down = n_down_out results % eigvals ( 1 : params % L ) = eigvals_up results % eigvals ( params % L + 1 : 2 * params % L ) = eigvals_down ierr = ERROR_SUCCESS return ! return SCF LOOP end if ! ----------------------------------------------------------------------- ! 1l. Copy densities directly (NO MIXING!) ! ----------------------------------------------------------------------- ! C++ code does: dens[0][i] = next_dens[0][i]  (line 695-696 in lsdaks.cc) ! Mixing is applied to POTENTIALS, not densities! n_up_in = n_up_out n_down_in = n_down_out end do ! ======================== ! STEP 2: Did not converge ! ======================== results % converged = . false . results % n_iterations = scf_params % max_iter results % final_density_error = density_error results % final_energy = total_energy ierr = ERROR_CONVERGENCE_FAILED deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) end subroutine run_kohn_sham_scf_complex","tags":"","url":"proc/run_kohn_sham_scf_complex.html"},{"title":"init_scf_results – LSDA-Hubbard-Fortran","text":"public  subroutine init_scf_results(results, L, store_history, max_iter, ierr) Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(out) :: results integer, intent(in) :: L logical, intent(in) :: store_history integer, intent(in) :: max_iter integer, intent(out) :: ierr Calls proc~~init_scf_results~~CallsGraph proc~init_scf_results init_scf_results proc~init_convergence_history init_convergence_history proc~init_scf_results->proc~init_convergence_history Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine init_scf_results ( results , L , store_history , max_iter , ierr ) type ( scf_results_t ), intent ( out ) :: results integer , intent ( in ) :: L , max_iter logical , intent ( in ) :: store_history integer , intent ( out ) :: ierr results % converged = . false . results % n_iterations = 0 results % final_density_error = 0.0_dp results % final_energy = 0.0_dp if ( store_history ) then call init_convergence_history ( results % history , max_iter , ierr ) end if ierr = ERROR_SUCCESS end subroutine init_scf_results","tags":"","url":"proc/init_scf_results.html"},{"title":"cleanup_scf_results – LSDA-Hubbard-Fortran","text":"public  subroutine cleanup_scf_results(results, ierr) Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(inout) :: results integer, intent(out) :: ierr Calls proc~~cleanup_scf_results~~CallsGraph proc~cleanup_scf_results cleanup_scf_results proc~cleanup_convergence_history cleanup_convergence_history proc~cleanup_scf_results->proc~cleanup_convergence_history Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine cleanup_scf_results ( results , ierr ) type ( scf_results_t ), intent ( inout ) :: results integer , intent ( out ) :: ierr if ( allocated ( results % density_up )) deallocate ( results % density_up ) if ( allocated ( results % density_down )) deallocate ( results % density_down ) if ( allocated ( results % eigvals )) deallocate ( results % eigvals ) call cleanup_convergence_history ( results % history , ierr ) end subroutine cleanup_scf_results","tags":"","url":"proc/cleanup_scf_results.html"},{"title":"line_search – LSDA-Hubbard-Fortran","text":"public  function line_search(x, dx, F_old, I, J, L, U) result(alpha) Armijo backtracking line search for Newton-Raphson Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: dx (:) real(kind=dp), intent(in) :: F_old (:) real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U Return Value real(kind=dp) Calls proc~~line_search~~CallsGraph proc~line_search line_search proc~compute_residual compute_residual proc~line_search->proc~compute_residual proc~theta theta proc~compute_residual->proc~theta proc~theta_capital Theta_capital proc~compute_residual->proc~theta_capital Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~line_search~~CalledByGraph proc~line_search line_search proc~solve_newton solve_newton proc~solve_newton->proc~line_search proc~compute_e_xc compute_E_xc proc~compute_e_xc->proc~solve_newton proc~sweep_u_backward sweep_U_backward proc~sweep_u_backward->proc~solve_newton proc~sweep_u_forward sweep_U_forward proc~sweep_u_forward->proc~solve_newton proc~compute_v_xc_numerical compute_V_xc_numerical proc~compute_v_xc_numerical->proc~compute_e_xc proc~generate_xc_table generate_xc_table proc~generate_xc_table->proc~compute_e_xc proc~generate_xc_table->proc~compute_v_xc_numerical proc~sweep_u_bidirectional sweep_U_bidirectional proc~sweep_u_bidirectional->proc~sweep_u_backward proc~sweep_u_bidirectional->proc~sweep_u_forward proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/line_search.html"},{"title":"solve_linear_system – LSDA-Hubbard-Fortran","text":"public  subroutine solve_linear_system(A, x, b) Solves linear system A·x = b using LAPACK DGESV Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(out) :: x (:) real(kind=dp), intent(in) :: b (:) Calls proc~~solve_linear_system~~CallsGraph proc~solve_linear_system solve_linear_system interface~dgesv DGESV proc~solve_linear_system->interface~dgesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~solve_linear_system~~CalledByGraph proc~solve_linear_system solve_linear_system proc~solve_newton solve_newton proc~solve_newton->proc~solve_linear_system proc~compute_e_xc compute_E_xc proc~compute_e_xc->proc~solve_newton proc~sweep_u_backward sweep_U_backward proc~sweep_u_backward->proc~solve_newton proc~sweep_u_forward sweep_U_forward proc~sweep_u_forward->proc~solve_newton proc~compute_v_xc_numerical compute_V_xc_numerical proc~compute_v_xc_numerical->proc~compute_e_xc proc~generate_xc_table generate_xc_table proc~generate_xc_table->proc~compute_e_xc proc~generate_xc_table->proc~compute_v_xc_numerical proc~sweep_u_bidirectional sweep_U_bidirectional proc~sweep_u_bidirectional->proc~sweep_u_backward proc~sweep_u_bidirectional->proc~sweep_u_forward proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/solve_linear_system.html"},{"title":"solve_newton – LSDA-Hubbard-Fortran","text":"public  subroutine solve_newton(x, I, J, L, U, converged) Newton-Raphson solver for Bethe Ansatz equations Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: x (:) real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U logical, intent(out) :: converged Calls proc~~solve_newton~~CallsGraph proc~solve_newton solve_newton proc~compute_jacobian compute_jacobian proc~solve_newton->proc~compute_jacobian proc~compute_residual compute_residual proc~solve_newton->proc~compute_residual proc~line_search line_search proc~solve_newton->proc~line_search proc~solve_linear_system solve_linear_system proc~solve_newton->proc~solve_linear_system proc~theta theta proc~compute_residual->proc~theta proc~theta_capital Theta_capital proc~compute_residual->proc~theta_capital proc~line_search->proc~compute_residual interface~dgesv DGESV proc~solve_linear_system->interface~dgesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~solve_newton~~CalledByGraph proc~solve_newton solve_newton proc~compute_e_xc compute_E_xc proc~compute_e_xc->proc~solve_newton proc~sweep_u_backward sweep_U_backward proc~sweep_u_backward->proc~solve_newton proc~sweep_u_forward sweep_U_forward proc~sweep_u_forward->proc~solve_newton proc~compute_v_xc_numerical compute_V_xc_numerical proc~compute_v_xc_numerical->proc~compute_e_xc proc~generate_xc_table generate_xc_table proc~generate_xc_table->proc~compute_e_xc proc~generate_xc_table->proc~compute_v_xc_numerical proc~sweep_u_bidirectional sweep_U_bidirectional proc~sweep_u_bidirectional->proc~sweep_u_backward proc~sweep_u_bidirectional->proc~sweep_u_forward proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/solve_newton.html"},{"title":"DGESV – LSDA-Hubbard-Fortran","text":"interface LAPACK interface for solving linear systems A·x = b Called by interface~~dgesv~~CalledByGraph interface~dgesv DGESV proc~solve_linear_system solve_linear_system proc~solve_linear_system->interface~dgesv proc~solve_newton solve_newton proc~solve_newton->proc~solve_linear_system proc~compute_e_xc compute_E_xc proc~compute_e_xc->proc~solve_newton proc~sweep_u_backward sweep_U_backward proc~sweep_u_backward->proc~solve_newton proc~sweep_u_forward sweep_U_forward proc~sweep_u_forward->proc~solve_newton proc~compute_v_xc_numerical compute_V_xc_numerical proc~compute_v_xc_numerical->proc~compute_e_xc proc~generate_xc_table generate_xc_table proc~generate_xc_table->proc~compute_e_xc proc~generate_xc_table->proc~compute_v_xc_numerical proc~sweep_u_bidirectional sweep_U_bidirectional proc~sweep_u_bidirectional->proc~sweep_u_backward proc~sweep_u_bidirectional->proc~sweep_u_forward proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private  subroutine DGESV(N, NRHS, A, LDA, IPIV, B, LDB, INFO) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: NRHS real(kind=dp), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA integer, intent(out) :: IPIV (*) real(kind=dp), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB integer, intent(out) :: INFO","tags":"","url":"interface/dgesv.html"},{"title":"theta – LSDA-Hubbard-Fortran","text":"public  function theta(x, U) result(res) charge-spin scattering function θ(x, U) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: U Return Value real(kind=dp) Called by proc~~theta~~CalledByGraph proc~theta theta proc~compute_residual compute_residual proc~compute_residual->proc~theta proc~compute_e_xc compute_E_xc proc~compute_e_xc->proc~compute_residual proc~solve_newton solve_newton proc~compute_e_xc->proc~solve_newton proc~line_search line_search proc~line_search->proc~compute_residual proc~solve_newton->proc~compute_residual proc~solve_newton->proc~line_search proc~compute_v_xc_numerical compute_V_xc_numerical proc~compute_v_xc_numerical->proc~compute_e_xc proc~generate_xc_table generate_xc_table proc~generate_xc_table->proc~compute_e_xc proc~generate_xc_table->proc~compute_v_xc_numerical proc~sweep_u_backward sweep_U_backward proc~sweep_u_backward->proc~solve_newton proc~sweep_u_forward sweep_U_forward proc~sweep_u_forward->proc~solve_newton proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table proc~sweep_u_bidirectional sweep_U_bidirectional proc~sweep_u_bidirectional->proc~sweep_u_backward proc~sweep_u_bidirectional->proc~sweep_u_forward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function theta ( x , U ) result ( res ) real ( dp ), intent ( in ) :: x , U real ( dp ) :: res if ( abs ( U ) < U_SMALL ) then res = PI * sign ( 1.0_dp , x ) else res = 2.0_dp * atan ( ( 2.0_dp * x ) / U ) end if end function theta","tags":"","url":"proc/theta.html"},{"title":"Theta_capital – LSDA-Hubbard-Fortran","text":"public  function Theta_capital(x, U) result(res) spin-spin scattering function Θ(x, U) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: U Return Value real(kind=dp) Called by proc~~theta_capital~~CalledByGraph proc~theta_capital Theta_capital proc~compute_residual compute_residual proc~compute_residual->proc~theta_capital proc~compute_e_xc compute_E_xc proc~compute_e_xc->proc~compute_residual proc~solve_newton solve_newton proc~compute_e_xc->proc~solve_newton proc~line_search line_search proc~line_search->proc~compute_residual proc~solve_newton->proc~compute_residual proc~solve_newton->proc~line_search proc~compute_v_xc_numerical compute_V_xc_numerical proc~compute_v_xc_numerical->proc~compute_e_xc proc~generate_xc_table generate_xc_table proc~generate_xc_table->proc~compute_e_xc proc~generate_xc_table->proc~compute_v_xc_numerical proc~sweep_u_backward sweep_U_backward proc~sweep_u_backward->proc~solve_newton proc~sweep_u_forward sweep_U_forward proc~sweep_u_forward->proc~solve_newton proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table proc~sweep_u_bidirectional sweep_U_bidirectional proc~sweep_u_bidirectional->proc~sweep_u_backward proc~sweep_u_bidirectional->proc~sweep_u_forward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function Theta_capital ( x , U ) result ( res ) real ( dp ), intent ( in ) :: x , U real ( dp ) :: res if ( abs ( U ) < U_SMALL ) then res = PI * sign ( 1.0_dp , x ) else res = 2.0_dp * atan2 ( x , U ) end if end function Theta_capital","tags":"","url":"proc/theta_capital.html"},{"title":"dtheta_dx – LSDA-Hubbard-Fortran","text":"public  function dtheta_dx(x, U) result(res) Derivative of the charge-spin scattering function θ with respect to x Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: U Return Value real(kind=dp) Source Code function dtheta_dx ( x , U ) result ( res ) real ( dp ), intent ( in ) :: x , U real ( dp ) :: res , denom denom = U ** 2 + 4.0_dp * x ** 2 if ( abs ( U ) < U_SMALL ) then res = 0.0_dp else res = ( 4.0_dp * U ) / denom end if end function dtheta_dx","tags":"","url":"proc/dtheta_dx.html"},{"title":"dTheta_capital_dx – LSDA-Hubbard-Fortran","text":"public  function dTheta_capital_dx(x, U) result(res) Derivative of the function Θ with respect to x Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: U Return Value real(kind=dp) Source Code function dTheta_capital_dx ( x , U ) result ( res ) real ( dp ), intent ( in ) :: x , U real ( dp ) :: res , denom denom = U ** 2 + x ** 2 if ( abs ( U ) < U_SMALL ) then res = 0.0_dp else res = ( 2.0_dp * U ) / denom end if end function dTheta_capital_dx","tags":"","url":"proc/dtheta_capital_dx.html"},{"title":"dtheta_dU – LSDA-Hubbard-Fortran","text":"public  function dtheta_dU(x, U) result(res) Derivative of the charge-spin scattering function θ with respect to U Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: U Return Value real(kind=dp) Called by proc~~dtheta_du~~CalledByGraph proc~dtheta_du dtheta_dU proc~compute_dfdu compute_dFdU proc~compute_dfdu->proc~dtheta_du Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function dtheta_dU ( x , U ) result ( res ) real ( dp ), intent ( in ) :: x , U real ( dp ) :: res , denom if ( abs ( U ) < U_SMALL ) then res = 0.0_dp else denom = U ** 2 + 4.0_dp * x ** 2 res = - ( 4.0_dp * x ) / denom end if end function dtheta_dU","tags":"","url":"proc/dtheta_du.html"},{"title":"dTheta_capital_dU – LSDA-Hubbard-Fortran","text":"public  function dTheta_capital_dU(x, U) result(res) Derivative of the spin-spin scattering function Θ with respect to U Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: U Return Value real(kind=dp) Called by proc~~dtheta_capital_du~~CalledByGraph proc~dtheta_capital_du dTheta_capital_dU proc~compute_dfdu compute_dFdU proc~compute_dfdu->proc~dtheta_capital_du Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function dTheta_capital_dU ( x , U ) result ( res ) real ( dp ), intent ( in ) :: x , U real ( dp ) :: res , denom if ( abs ( U ) < U_SMALL ) then res = 0.0_dp else denom = U ** 2 + x ** 2 res = - ( 2.0_dp * x ) / denom end if end function dTheta_capital_dU","tags":"","url":"proc/dtheta_capital_du.html"},{"title":"compute_residual – LSDA-Hubbard-Fortran","text":"public  function compute_residual(k, Lambda, I, J_capital, L, U) result(F) Computes the residual vector F(x) for the Lieb-Wu equations of the 1D Hubbard model. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k (:) real(kind=dp), intent(in) :: Lambda (:) real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J_capital (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U Return Value real(kind=dp), (size(k)+size(Lambda)) Calls proc~~compute_residual~~CallsGraph proc~compute_residual compute_residual proc~theta theta proc~compute_residual->proc~theta proc~theta_capital Theta_capital proc~compute_residual->proc~theta_capital Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_residual~~CalledByGraph proc~compute_residual compute_residual proc~compute_e_xc compute_E_xc proc~compute_e_xc->proc~compute_residual proc~solve_newton solve_newton proc~compute_e_xc->proc~solve_newton proc~line_search line_search proc~line_search->proc~compute_residual proc~solve_newton->proc~compute_residual proc~solve_newton->proc~line_search proc~compute_v_xc_numerical compute_V_xc_numerical proc~compute_v_xc_numerical->proc~compute_e_xc proc~generate_xc_table generate_xc_table proc~generate_xc_table->proc~compute_e_xc proc~generate_xc_table->proc~compute_v_xc_numerical proc~sweep_u_backward sweep_U_backward proc~sweep_u_backward->proc~solve_newton proc~sweep_u_forward sweep_U_forward proc~sweep_u_forward->proc~solve_newton proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table proc~sweep_u_bidirectional sweep_U_bidirectional proc~sweep_u_bidirectional->proc~sweep_u_backward proc~sweep_u_bidirectional->proc~sweep_u_forward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function compute_residual ( k , Lambda , I , J_capital , L , U ) result ( F ) real ( dp ), intent ( in ) :: k (:), Lambda (:), I (:), J_capital (:), U integer , intent ( in ) :: L integer :: j , alpha , beta , Nup , M real ( dp ) :: summ , summ1 , summ2 real ( dp ) :: F ( size ( k ) + size ( Lambda )) Nup = size ( k ) M = size ( Lambda ) ! Special case: U ≈ 0 if ( abs ( U ) < U_SMALL ) then ! For U=0, the exact solution is k_j = 2π·I_j/L ! Residual must be exactly zero F ( 1 : Nup ) = k - TWOPI * I / real ( L , dp ) F ( Nup + 1 : Nup + M ) = 0.0_dp ! Lambda is arbitrary return end if ! General case: U > 0 ! Charge equations: F&#94;k do j = 1 , Nup summ = 0.0_dp do alpha = 1 , M summ = summ + theta ( k ( j ) - Lambda ( alpha ), U ) end do F ( j ) = k ( j ) - ( TWOPI * I ( j )) / L - summ / L end do ! Spin equations: F&#94;Lambda do alpha = 1 , M summ1 = 0.0_dp summ2 = 0.0_dp do j = 1 , Nup summ1 = summ1 + theta ( Lambda ( alpha ) - k ( j ), U ) end do do beta = 1 , M if ( beta /= alpha ) then summ2 = summ2 + Theta_capital ( Lambda ( alpha ) - Lambda ( beta ), U ) end if end do F ( Nup + alpha ) = ( TWOPI * J_capital ( alpha )) / L - summ1 + summ2 end do end function compute_residual","tags":"","url":"proc/compute_residual.html"},{"title":"compute_jacobian – LSDA-Hubbard-Fortran","text":"public  function compute_jacobian(k, Lambda, L, U) result(Jacobian) Computes the Jacobian matrix J = ∂F/∂x for the Lieb-Wu equations. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k (:) real(kind=dp), intent(in) :: Lambda (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U Return Value real(kind=dp), (size(k)+size(Lambda),size(k)+size(Lambda)) Called by proc~~compute_jacobian~~CalledByGraph proc~compute_jacobian compute_jacobian proc~solve_newton solve_newton proc~solve_newton->proc~compute_jacobian proc~compute_e_xc compute_E_xc proc~compute_e_xc->proc~solve_newton proc~sweep_u_backward sweep_U_backward proc~sweep_u_backward->proc~solve_newton proc~sweep_u_forward sweep_U_forward proc~sweep_u_forward->proc~solve_newton proc~compute_v_xc_numerical compute_V_xc_numerical proc~compute_v_xc_numerical->proc~compute_e_xc proc~generate_xc_table generate_xc_table proc~generate_xc_table->proc~compute_e_xc proc~generate_xc_table->proc~compute_v_xc_numerical proc~sweep_u_bidirectional sweep_U_bidirectional proc~sweep_u_bidirectional->proc~sweep_u_backward proc~sweep_u_bidirectional->proc~sweep_u_forward proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/compute_jacobian.html"},{"title":"compute_dFdU – LSDA-Hubbard-Fortran","text":"public  function compute_dFdU(k, Lambda, I, J_capital, L, U) result(dFdU) Computes the derivative of the residual vector with respect to U: ∂F/∂U Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k (:) real(kind=dp), intent(in) :: Lambda (:) real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J_capital (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U Return Value real(kind=dp), (size(k)+size(Lambda)) Calls proc~~compute_dfdu~~CallsGraph proc~compute_dfdu compute_dFdU proc~dtheta_capital_du dTheta_capital_dU proc~compute_dfdu->proc~dtheta_capital_du proc~dtheta_du dtheta_dU proc~compute_dfdu->proc~dtheta_du Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function compute_dFdU ( k , Lambda , I , J_capital , L , U ) result ( dFdU ) real ( dp ), intent ( in ) :: k (:), Lambda (:), I (:), J_capital (:), U integer , intent ( in ) :: L integer :: j , alpha , beta , Nup , M real ( dp ) :: summ , summ1 , summ2 real ( dp ) :: dFdU ( size ( k ) + size ( Lambda )) Nup = size ( k ) M = size ( Lambda ) ! Special case: U ≈ 0 if ( abs ( U ) < U_SMALL ) then ! For U=0, F does not depend on U → dF/dU = 0 dFdU = 0.0_dp return end if ! General case: U > 0 ! Charge equations: dF&#94;k/dU do j = 1 , Nup summ = 0.0_dp do alpha = 1 , M summ = summ + dtheta_dU ( k ( j ) - Lambda ( alpha ), U ) end do dFdU ( j ) = - ( 1.0_dp / L ) * summ end do ! Spin equations: dF&#94;Lambda/dU do alpha = 1 , M summ1 = 0.0_dp summ2 = 0.0_dp do j = 1 , Nup summ1 = summ1 + dtheta_dU ( Lambda ( alpha ) - k ( j ), U ) end do do beta = 1 , M if ( beta /= alpha ) then summ2 = summ2 + dTheta_capital_dU ( Lambda ( alpha ) - Lambda ( beta ), U ) end if end do dFdU ( Nup + alpha ) = - summ1 + summ2 end do end function compute_dFdU","tags":"","url":"proc/compute_dfdu.html"},{"title":"compute_energy – LSDA-Hubbard-Fortran","text":"public  function compute_energy(k) result(E) Computes the ground state energy from Bethe Ansatz rapidities Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k (:) Return Value real(kind=dp) Called by proc~~compute_energy~~CalledByGraph proc~compute_energy compute_energy proc~compute_e_xc compute_E_xc proc~compute_e_xc->proc~compute_energy proc~sweep_u_backward sweep_U_backward proc~sweep_u_backward->proc~compute_energy proc~sweep_u_forward sweep_U_forward proc~sweep_u_forward->proc~compute_energy proc~compute_v_xc_numerical compute_V_xc_numerical proc~compute_v_xc_numerical->proc~compute_e_xc proc~generate_xc_table generate_xc_table proc~generate_xc_table->proc~compute_e_xc proc~generate_xc_table->proc~compute_v_xc_numerical proc~sweep_u_bidirectional sweep_U_bidirectional proc~sweep_u_bidirectional->proc~sweep_u_backward proc~sweep_u_bidirectional->proc~sweep_u_forward proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function compute_energy ( k ) result ( E ) real ( dp ), intent ( in ) :: k (:) real ( dp ) :: E E = - 2.0_dp * SUM ( COS ( k )) end function compute_energy","tags":"","url":"proc/compute_energy.html"},{"title":"initialize_quantum_numbers – LSDA-Hubbard-Fortran","text":"public  subroutine initialize_quantum_numbers(Nup, M, I, J_capital) Initialize quantum numbers for the ground state Arguments Type Intent Optional Attributes Name integer, intent(in) :: Nup integer, intent(in) :: M real(kind=dp), intent(out) :: I (:) real(kind=dp), intent(out) :: J_capital (:) Called by proc~~initialize_quantum_numbers~~CalledByGraph proc~initialize_quantum_numbers initialize_quantum_numbers proc~compute_e_xc compute_E_xc proc~compute_e_xc->proc~initialize_quantum_numbers proc~compute_v_xc_numerical compute_V_xc_numerical proc~compute_v_xc_numerical->proc~compute_e_xc proc~generate_xc_table generate_xc_table proc~generate_xc_table->proc~compute_e_xc proc~generate_xc_table->proc~compute_v_xc_numerical proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_quantum_numbers ( Nup , M , I , J_capital ) integer , intent ( in ) :: Nup , M real ( dp ), intent ( out ) :: I (:), J_capital (:) real ( dp ) :: offset_I , offset_J integer :: j , alpha offset_I = ( Nup + 1 ) / 2.0_dp offset_J = ( M + 1 ) / 2.0_dp do j = 1 , Nup I ( j ) = real ( j , dp ) - offset_I end do do alpha = 1 , M J_capital ( alpha ) = real ( alpha , dp ) - offset_J end do end subroutine initialize_quantum_numbers","tags":"","url":"proc/initialize_quantum_numbers.html"},{"title":"apply_potential_quasiperiodic – LSDA-Hubbard-Fortran","text":"public  subroutine apply_potential_quasiperiodic(lambda, beta, phi, L, V, ierr) Uses lsda_errors proc~~apply_potential_quasiperiodic~~UsesGraph proc~apply_potential_quasiperiodic apply_potential_quasiperiodic module~lsda_errors lsda_errors proc~apply_potential_quasiperiodic->module~lsda_errors module~lsda_constants lsda_constants module~lsda_errors->module~lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Quasiperiodic potential: V(i) = λ cos(2πβi + φ) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda real(kind=dp), intent(in) :: beta real(kind=dp), intent(in) :: phi integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr Called by proc~~apply_potential_quasiperiodic~~CalledByGraph proc~apply_potential_quasiperiodic apply_potential_quasiperiodic proc~create_potential create_potential proc~create_potential->proc~apply_potential_quasiperiodic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine apply_potential_quasiperiodic ( lambda , beta , phi , L , V , ierr ) use lsda_errors , only : ERROR_SUCCESS , ERROR_NEGATIVE_VALUE , ERROR_OUT_OF_BOUNDS real ( dp ), intent ( in ) :: lambda real ( dp ), intent ( in ) :: beta real ( dp ), intent ( in ) :: phi integer , intent ( in ) :: L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr integer :: i real ( dp ) :: argument ! Initialize V = 0.0_dp ierr = ERROR_SUCCESS ! Validate lambda (potential strength) if ( lambda < 0.0_dp ) then ierr = ERROR_NEGATIVE_VALUE return end if ! Validate beta (quasiperiodic frequency) if ( beta <= 0.0_dp ) then ierr = ERROR_NEGATIVE_VALUE return end if ! Validate L if ( L < 1 ) then ierr = ERROR_OUT_OF_BOUNDS return end if ! Calculate potential at each site ! Use i-1 to make the physical site index start at 0 do i = 1 , L argument = TWOPI * beta * real ( i - 1 , dp ) + phi V ( i ) = lambda * cos ( argument ) end do end subroutine apply_potential_quasiperiodic","tags":"","url":"proc/apply_potential_quasiperiodic.html"},{"title":"find_interval – LSDA-Hubbard-Fortran","text":"private  function find_interval(x_grid, n, x) result(i) Find interval containing x in monotonic array Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x_grid (0:) integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value integer Called by proc~~find_interval~~CalledByGraph proc~find_interval find_interval proc~spline1d_eval spline1d_eval proc~spline1d_eval->proc~find_interval proc~spline2d_eval spline2d_eval proc~spline2d_eval->proc~find_interval proc~spline2d_eval->proc~spline1d_eval proc~get_exc get_exc proc~get_exc->proc~spline2d_eval proc~get_vxc get_vxc proc~get_vxc->proc~spline2d_eval proc~compute_total_energy compute_total_energy proc~compute_total_energy->proc~get_exc proc~compute_total_energy->proc~get_vxc proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~get_vxc proc~run_kohn_sham_scf_complex->proc~compute_total_energy proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~get_vxc proc~run_kohn_sham_scf_real->proc~compute_total_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function find_interval ( x_grid , n , x ) result ( i ) real ( dp ), intent ( in ) :: x_grid ( 0 :), x integer , intent ( in ) :: n integer :: left , right , mid , i if ( x <= x_grid ( 0 )) then i = 0 return end if if ( x >= x_grid ( n - 1 )) then i = n - 2 return end if left = 0 right = n - 1 do while ( right - left > 1 ) mid = ( left + right ) / 2 if ( x < x_grid ( mid )) then right = mid else left = mid end if end do i = left end function find_interval","tags":"","url":"proc/find_interval.html"},{"title":"spline1d_eval – LSDA-Hubbard-Fortran","text":"private  function spline1d_eval(x_grid, y_grid, d2y, n, x) result(y_interp) Evaluate cubic spline at point x given coefficients Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x_grid (0:) real(kind=dp), intent(in) :: y_grid (0:) real(kind=dp), intent(in) :: d2y (0:) integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) Calls proc~~spline1d_eval~~CallsGraph proc~spline1d_eval spline1d_eval proc~find_interval find_interval proc~spline1d_eval->proc~find_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~spline1d_eval~~CalledByGraph proc~spline1d_eval spline1d_eval proc~spline2d_eval spline2d_eval proc~spline2d_eval->proc~spline1d_eval proc~get_exc get_exc proc~get_exc->proc~spline2d_eval proc~get_vxc get_vxc proc~get_vxc->proc~spline2d_eval proc~compute_total_energy compute_total_energy proc~compute_total_energy->proc~get_exc proc~compute_total_energy->proc~get_vxc proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~get_vxc proc~run_kohn_sham_scf_complex->proc~compute_total_energy proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~get_vxc proc~run_kohn_sham_scf_real->proc~compute_total_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function spline1d_eval ( x_grid , y_grid , d2y , n , x ) result ( y_interp ) real ( dp ), intent ( in ) :: x_grid ( 0 :), y_grid ( 0 :), d2y ( 0 :), x integer , intent ( in ) :: n real ( dp ) :: y_interp , h , a , b integer :: i if ( n == 0 ) then y_interp = y_grid ( 0 ) return end if i = find_interval ( x_grid , n + 1 , x ) if ( i < 0 ) i = 0 if ( i >= n ) i = n - 1 h = x_grid ( i + 1 ) - x_grid ( i ) if ( abs ( h ) < 1.0e-15_dp ) then y_interp = y_grid ( i ) return end if a = ( x_grid ( i + 1 ) - x ) / h b = 1.0_dp - a y_interp = a * y_grid ( i ) + b * y_grid ( i + 1 ) + & (( a ** 3 - a ) * h ** 2 / 6.0_dp ) * d2y ( i ) + & (( b ** 3 - b ) * h ** 2 / 6.0_dp ) * d2y ( i + 1 ) end function spline1d_eval","tags":"","url":"proc/spline1d_eval.html"},{"title":"spline2d_eval – LSDA-Hubbard-Fortran","text":"public  function spline2d_eval(spl, x, y) result(f_interp) Evaluate 2D spline at point (x, y) Arguments Type Intent Optional Attributes Name type( spline2d_t ), intent(in) :: spl real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: y Return Value real(kind=dp) Calls proc~~spline2d_eval~~CallsGraph proc~spline2d_eval spline2d_eval d2y_tmp d2y_tmp proc~spline2d_eval->d2y_tmp f_tmp f_tmp proc~spline2d_eval->f_tmp proc~find_interval find_interval proc~spline2d_eval->proc~find_interval proc~spline1d_eval spline1d_eval proc~spline2d_eval->proc~spline1d_eval y_tmp y_tmp proc~spline2d_eval->y_tmp proc~spline1d_eval->proc~find_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~spline2d_eval~~CalledByGraph proc~spline2d_eval spline2d_eval proc~get_exc get_exc proc~get_exc->proc~spline2d_eval proc~get_vxc get_vxc proc~get_vxc->proc~spline2d_eval proc~compute_total_energy compute_total_energy proc~compute_total_energy->proc~get_exc proc~compute_total_energy->proc~get_vxc proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~get_vxc proc~run_kohn_sham_scf_complex->proc~compute_total_energy proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~get_vxc proc~run_kohn_sham_scf_real->proc~compute_total_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function spline2d_eval ( spl , x , y ) result ( f_interp ) type ( spline2d_t ), intent ( in ) :: spl real ( dp ), intent ( in ) :: x , y real ( dp ) :: f_interp , f_left , f_right , t integer :: i_x if (. not . spl % initialized ) then print * , \"ERROR: spline2d not initialized!\" f_interp = 0.0_dp return end if i_x = find_interval ( spl % x , spl % n_x , x ) ! Convert 0-based index to 1-based for Fortran arrays i_x = i_x + 1 if ( spl % n_x == 1 ) then ! Single x point - evaluate 1D spline in y direction block integer :: ny1 real ( dp ) :: y_tmp ( 0 : spl % n_y ( 1 ) - 1 ), f_tmp ( 0 : spl % n_y ( 1 ) - 1 ), d2y_tmp ( 0 : spl % n_y ( 1 ) - 1 ) ny1 = spl % n_y ( 1 ) y_tmp = spl % y ( 1 : ny1 , 1 ) f_tmp = spl % f ( 1 : ny1 , 1 ) d2y_tmp = spl % d2f_dy2 ( 1 : ny1 , 1 ) f_interp = spline1d_eval ( y_tmp , f_tmp , d2y_tmp , ny1 - 1 , y ) end block return end if ! Clamp i_x to valid range if ( i_x < 1 ) i_x = 1 if ( i_x >= spl % n_x ) i_x = spl % n_x - 1 ! Evaluate at left endpoint (i_x) block integer :: ny_left real ( dp ), allocatable :: y_tmp (:), f_tmp (:), d2y_tmp (:) ny_left = spl % n_y ( i_x ) allocate ( y_tmp ( 0 : ny_left - 1 ), f_tmp ( 0 : ny_left - 1 ), d2y_tmp ( 0 : ny_left - 1 )) y_tmp = spl % y ( 1 : ny_left , i_x ) f_tmp = spl % f ( 1 : ny_left , i_x ) d2y_tmp = spl % d2f_dy2 ( 1 : ny_left , i_x ) f_left = spline1d_eval ( y_tmp , f_tmp , d2y_tmp , ny_left - 1 , y ) deallocate ( y_tmp , f_tmp , d2y_tmp ) end block ! Evaluate at right endpoint (i_x+1) block integer :: ny_right real ( dp ), allocatable :: y_tmp (:), f_tmp (:), d2y_tmp (:) ny_right = spl % n_y ( i_x + 1 ) allocate ( y_tmp ( 0 : ny_right - 1 ), f_tmp ( 0 : ny_right - 1 ), d2y_tmp ( 0 : ny_right - 1 )) y_tmp = spl % y ( 1 : ny_right , i_x + 1 ) f_tmp = spl % f ( 1 : ny_right , i_x + 1 ) d2y_tmp = spl % d2f_dy2 ( 1 : ny_right , i_x + 1 ) f_right = spline1d_eval ( y_tmp , f_tmp , d2y_tmp , ny_right - 1 , y ) deallocate ( y_tmp , f_tmp , d2y_tmp ) end block t = ( x - spl % x ( i_x )) / ( spl % x ( i_x + 1 ) - spl % x ( i_x )) f_interp = ( 1.0_dp - t ) * f_left + t * f_right end function spline2d_eval","tags":"","url":"proc/spline2d_eval.html"},{"title":"spline1d_coeff – LSDA-Hubbard-Fortran","text":"private  subroutine spline1d_coeff(x, y, n, d2y, bc_type, dy0, dyn) Compute cubic spline coefficients (second derivatives) for 1D data Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (0:) real(kind=dp), intent(in) :: y (0:) integer, intent(in) :: n real(kind=dp), intent(out) :: d2y (0:) character(len=*), intent(in) :: bc_type real(kind=dp), intent(in) :: dy0 real(kind=dp), intent(in) :: dyn Called by proc~~spline1d_coeff~~CalledByGraph proc~spline1d_coeff spline1d_coeff proc~spline2d_init spline2d_init proc~spline2d_init->proc~spline1d_coeff proc~xc_lsda_init xc_lsda_init proc~xc_lsda_init->proc~spline2d_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine spline1d_coeff ( x , y , n , d2y , bc_type , dy0 , dyn ) real ( dp ), intent ( in ) :: x ( 0 :), y ( 0 :), dy0 , dyn integer , intent ( in ) :: n real ( dp ), intent ( out ) :: d2y ( 0 :) character ( len =* ), intent ( in ) :: bc_type real ( dp ), allocatable :: a (:), b (:) real ( dp ) :: h0 , h1 integer :: i allocate ( a ( 0 : n ), b ( 0 : n )) if ( trim ( bc_type ) == 'clamped' ) then a ( 0 ) = ( x ( 1 ) - x ( 0 )) / 3.0_dp b ( 0 ) = ( y ( 1 ) - y ( 0 )) / ( x ( 1 ) - x ( 0 )) - dy0 do i = 1 , n - 1 a ( i ) = ( x ( i + 1 ) - x ( i - 1 )) / 3.0_dp b ( i ) = ( y ( i + 1 ) - y ( i )) / ( x ( i + 1 ) - x ( i )) - & ( y ( i ) - y ( i - 1 )) / ( x ( i ) - x ( i - 1 )) end do a ( n ) = ( x ( n ) - x ( n - 1 )) / 3.0_dp b ( n ) = dyn - ( y ( n ) - y ( n - 1 )) / ( x ( n ) - x ( n - 1 )) else a ( 0 ) = 1.0_dp b ( 0 ) = 0.0_dp do i = 1 , n - 1 a ( i ) = ( x ( i + 1 ) - x ( i - 1 )) / 3.0_dp b ( i ) = ( y ( i + 1 ) - y ( i )) / ( x ( i + 1 ) - x ( i )) - & ( y ( i ) - y ( i - 1 )) / ( x ( i ) - x ( i - 1 )) end do a ( n ) = 1.0_dp b ( n ) = 0.0_dp end if ! Forward elimination (Thomas algorithm for tridiagonal system) do i = 1 , n - 1 h0 = x ( i ) - x ( i - 1 ) h1 = x ( i + 1 ) - x ( i ) if ( trim ( bc_type ) == 'clamped' ) then a ( i ) = a ( i ) - h0 * h0 / a ( i - 1 ) / 3 6.0_dp b ( i ) = b ( i ) - b ( i - 1 ) / a ( i - 1 ) * h0 / 6.0_dp else if ( i == 1 ) then cycle end if a ( i ) = a ( i ) - h0 * h0 / a ( i - 1 ) / 3 6.0_dp b ( i ) = b ( i ) - b ( i - 1 ) / a ( i - 1 ) * h0 / 6.0_dp end if end do if ( trim ( bc_type ) == 'clamped' ) then h0 = x ( n ) - x ( n - 1 ) a ( n ) = h0 / 3.0_dp * ( 1.0_dp - h0 / a ( n - 1 ) / 1 2.0_dp ) b ( n ) = b ( n ) - b ( n - 1 ) / a ( n - 1 ) * h0 / 6.0_dp end if ! Back substitution d2y ( n ) = b ( n ) / a ( n ) do i = n - 1 , 1 , - 1 h1 = ( x ( i + 1 ) - x ( i )) / 6.0_dp d2y ( i ) = ( b ( i ) - h1 * d2y ( i + 1 )) / a ( i ) end do if ( trim ( bc_type ) == 'clamped' ) then d2y ( 0 ) = b ( 0 ) / a ( 0 ) - d2y ( 1 ) / 2.0_dp else d2y ( 0 ) = 0.0_dp end if deallocate ( a , b ) end subroutine spline1d_coeff","tags":"","url":"proc/spline1d_coeff.html"},{"title":"spline2d_init – LSDA-Hubbard-Fortran","text":"public  subroutine spline2d_init(spl, x_grid, y_grid, f_values, n_y_pts) Initialize 2D spline from grid data Arguments Type Intent Optional Attributes Name type( spline2d_t ), intent(out) :: spl real(kind=dp), intent(in) :: x_grid (:) real(kind=dp), intent(in) :: y_grid (:,:) real(kind=dp), intent(in) :: f_values (:,:) integer, intent(in) :: n_y_pts (:) Calls proc~~spline2d_init~~CallsGraph proc~spline2d_init spline2d_init d2y_temp d2y_temp proc~spline2d_init->d2y_temp f_temp f_temp proc~spline2d_init->f_temp proc~spline1d_coeff spline1d_coeff proc~spline2d_init->proc~spline1d_coeff y_temp y_temp proc~spline2d_init->y_temp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~spline2d_init~~CalledByGraph proc~spline2d_init spline2d_init proc~xc_lsda_init xc_lsda_init proc~xc_lsda_init->proc~spline2d_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine spline2d_init ( spl , x_grid , y_grid , f_values , n_y_pts ) type ( spline2d_t ), intent ( out ) :: spl real ( dp ), intent ( in ) :: x_grid (:), y_grid (:,:), f_values (:,:) integer , intent ( in ) :: n_y_pts (:) integer :: i , nx , ny_max , ny nx = size ( x_grid ) ny_max = size ( y_grid , 1 ) spl % n_x = nx spl % n_y_max = ny_max allocate ( spl % x ( nx )) allocate ( spl % y ( ny_max , nx )) allocate ( spl % f ( ny_max , nx )) allocate ( spl % n_y ( nx )) allocate ( spl % d2f_dy2 ( ny_max , nx )) spl % x = x_grid spl % y = y_grid spl % f = f_values spl % n_y = n_y_pts do i = 1 , nx ny = spl % n_y ( i ) if ( ny > 1 ) then ! Create temporary 0-indexed arrays for spline1d_coeff block real ( dp ) :: y_temp ( 0 : ny - 1 ), f_temp ( 0 : ny - 1 ), d2y_temp ( 0 : ny - 1 ) y_temp = spl % y ( 1 : ny , i ) f_temp = spl % f ( 1 : ny , i ) call spline1d_coeff ( y_temp , f_temp , ny - 1 , d2y_temp , 'natural' , 0.0_dp , 0.0_dp ) spl % d2f_dy2 ( 1 : ny , i ) = d2y_temp end block else spl % d2f_dy2 ( 1 , i ) = 0.0_dp end if end do spl % initialized = . true . end subroutine spline2d_init","tags":"","url":"proc/spline2d_init.html"},{"title":"spline2d_destroy – LSDA-Hubbard-Fortran","text":"public  subroutine spline2d_destroy(spl) Clean up spline object Arguments Type Intent Optional Attributes Name type( spline2d_t ), intent(inout) :: spl Called by proc~~spline2d_destroy~~CalledByGraph proc~spline2d_destroy spline2d_destroy proc~xc_lsda_destroy xc_lsda_destroy proc~xc_lsda_destroy->proc~spline2d_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine spline2d_destroy ( spl ) type ( spline2d_t ), intent ( inout ) :: spl if ( allocated ( spl % x )) deallocate ( spl % x ) if ( allocated ( spl % y )) deallocate ( spl % y ) if ( allocated ( spl % f )) deallocate ( spl % f ) if ( allocated ( spl % n_y )) deallocate ( spl % n_y ) if ( allocated ( spl % d2f_dy2 )) deallocate ( spl % d2f_dy2 ) spl % initialized = . false . end subroutine spline2d_destroy","tags":"","url":"proc/spline2d_destroy.html"},{"title":"apply_potential_uniform – LSDA-Hubbard-Fortran","text":"public  subroutine apply_potential_uniform(V0, L, V, ierr) Uses lsda_errors proc~~apply_potential_uniform~~UsesGraph proc~apply_potential_uniform apply_potential_uniform module~lsda_errors lsda_errors proc~apply_potential_uniform->module~lsda_errors module~lsda_constants lsda_constants module~lsda_errors->module~lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Uniform potential: V(i) = V₀ for all i Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V0 integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr Called by proc~~apply_potential_uniform~~CalledByGraph proc~apply_potential_uniform apply_potential_uniform proc~create_potential create_potential proc~create_potential->proc~apply_potential_uniform Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine apply_potential_uniform ( V0 , L , V , ierr ) use lsda_errors , only : ERROR_SUCCESS real ( dp ), intent ( in ) :: V0 integer , intent ( in ) :: L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr V = V0 ierr = ERROR_SUCCESS end subroutine apply_potential_uniform","tags":"","url":"proc/apply_potential_uniform.html"},{"title":"parse_inputs – LSDA-Hubbard-Fortran","text":"public  subroutine parse_inputs(inputs, ierr) Parse inputs from command line or namelist file Arguments Type Intent Optional Attributes Name type( input_params_t ), intent(out) :: inputs integer, intent(out) :: ierr Calls proc~~parse_inputs~~CallsGraph proc~parse_inputs parse_inputs proc~parse_integer_arg parse_integer_arg proc~parse_inputs->proc~parse_integer_arg proc~parse_real_arg parse_real_arg proc~parse_inputs->proc~parse_real_arg proc~print_help print_help proc~parse_inputs->proc~print_help proc~read_namelist_file read_namelist_file proc~parse_inputs->proc~read_namelist_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine parse_inputs ( inputs , ierr ) type ( input_params_t ), intent ( out ) :: inputs integer , intent ( out ) :: ierr character ( len = 256 ) :: arg , input_file integer :: nargs , i logical :: use_input_file ierr = ERROR_SUCCESS use_input_file = . false . ! Initialize with defaults inputs = input_params_t () ! Check command line arguments nargs = command_argument_count () if ( nargs == 0 ) then ! No arguments: try default input file input_file = 'input.txt' inquire ( file = input_file , exist = use_input_file ) if (. not . use_input_file ) then print * , \"WARNING: No input file or arguments provided.\" print * , \"Using default parameters.\" return end if else ! Parse command line i = 1 do while ( i <= nargs ) call get_command_argument ( i , arg ) select case ( trim ( arg )) case ( '--input' , '-i' ) if ( i + 1 > nargs ) then print * , \"ERROR: --input requires a filename\" ierr = ERROR_INVALID_INPUT return end if call get_command_argument ( i + 1 , input_file ) use_input_file = . true . i = i + 2 case ( '--L' ) call parse_integer_arg ( i , nargs , inputs % L , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--Nup' ) call parse_integer_arg ( i , nargs , inputs % Nup , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--Ndown' ) call parse_integer_arg ( i , nargs , inputs % Ndown , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--U' ) call parse_real_arg ( i , nargs , inputs % U , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--bc' ) if ( i + 1 > nargs ) then print * , \"ERROR: --bc requires a value (open/periodic/twisted)\" ierr = ERROR_INVALID_INPUT return end if call get_command_argument ( i + 1 , inputs % bc_type ) i = i + 2 case ( '--phase' ) call parse_real_arg ( i , nargs , inputs % phase , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--potential' ) if ( i + 1 > nargs ) then print * , \"ERROR: --potential requires a type\" ierr = ERROR_INVALID_INPUT return end if call get_command_argument ( i + 1 , inputs % potential_type ) i = i + 2 case ( '--V0' ) call parse_real_arg ( i , nargs , inputs % V0 , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--concentration' ) call parse_real_arg ( i , nargs , inputs % concentration , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--verbose' ) inputs % verbose = . true . i = i + 1 case ( '--quiet' ) inputs % verbose = . false . i = i + 1 case ( '--help' , '-h' ) call print_help () ierr = - 1 ! Signal to exit gracefully return case default print * , \"WARNING: Unknown argument: \" , trim ( arg ) i = i + 1 end select end do end if ! Read namelist file if specified if ( use_input_file ) then call read_namelist_file ( input_file , inputs , ierr ) if ( ierr /= ERROR_SUCCESS ) return end if end subroutine parse_inputs","tags":"","url":"proc/parse_inputs.html"},{"title":"read_namelist_file – LSDA-Hubbard-Fortran","text":"private  subroutine read_namelist_file(filename, inputs, ierr) Read parameters from namelist file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( input_params_t ), intent(inout) :: inputs integer, intent(out) :: ierr Called by proc~~read_namelist_file~~CalledByGraph proc~read_namelist_file read_namelist_file proc~parse_inputs parse_inputs proc~parse_inputs->proc~read_namelist_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Namelists Namelist system Variables Name Type Default Description L integer None Nup integer None Ndown integer None U real(kind=dp) None bc character(len=20) None phase real(kind=dp) None Namelist potential Variables Name Type Default Description potential_type character(len=20) None V0 real(kind=dp) None pot_center real(kind=dp) None pot_width real(kind=dp) None concentration real(kind=dp) None pot_seed integer None imp_positions_str character(len=500) None disorder_strength real(kind=dp) None distribution character(len=20) None position integer None width integer None barrier_width real(kind=dp) None well_depth real(kind=dp) None well_width real(kind=dp) None position1 integer None width1 integer None position2 integer None width2 integer None Namelist scf Variables Name Type Default Description max_iter integer None density_tol real(kind=dp) None energy_tol real(kind=dp) None mixing_alpha real(kind=dp) None verbose logical None store_history logical None use_adaptive_mixing logical None Namelist output Variables Name Type Default Description output_prefix character(len=100) None save_density logical None save_eigenvalues logical None save_wavefunction logical None Source Code subroutine read_namelist_file ( filename , inputs , ierr ) character ( len =* ), intent ( in ) :: filename type ( input_params_t ), intent ( inout ) :: inputs integer , intent ( out ) :: ierr integer :: io_unit , io_stat logical :: file_exists ! System namelist variables integer :: L , Nup , Ndown real ( dp ) :: U , phase character ( len = 20 ) :: bc ! Potential namelist variables character ( len = 20 ) :: potential_type real ( dp ) :: V0 , pot_center , pot_width , concentration , disorder_strength real ( dp ) :: barrier_width , well_depth , well_width integer :: pot_seed , position , width , position1 , width1 , position2 , width2 character ( len = 500 ) :: imp_positions_str character ( len = 20 ) :: distribution ! SCF namelist variables integer :: max_iter real ( dp ) :: density_tol , energy_tol , mixing_alpha logical :: verbose , store_history , use_adaptive_mixing ! Output namelist variables character ( len = 100 ) :: output_prefix logical :: save_density , save_eigenvalues , save_wavefunction namelist / system / L , Nup , Ndown , U , bc , phase namelist / potential / potential_type , V0 , pot_center , pot_width , & concentration , pot_seed , imp_positions_str , & disorder_strength , distribution , position , width , & barrier_width , well_depth , well_width , & position1 , width1 , position2 , width2 namelist / scf / max_iter , density_tol , energy_tol , mixing_alpha , & verbose , store_history , use_adaptive_mixing namelist / output / output_prefix , save_density , save_eigenvalues , & save_wavefunction ierr = ERROR_SUCCESS ! Check if file exists inquire ( file = filename , exist = file_exists ) if (. not . file_exists ) then print * , \"ERROR: Input file not found: \" , trim ( filename ) ierr = ERROR_FILE_NOT_FOUND return end if ! Initialize namelist variables with current values L = inputs % L Nup = inputs % Nup Ndown = inputs % Ndown U = inputs % U bc = inputs % bc_type phase = inputs % phase potential_type = inputs % potential_type V0 = inputs % V0 pot_center = inputs % pot_center pot_width = inputs % pot_width concentration = inputs % concentration pot_seed = inputs % pot_seed imp_positions_str = inputs % imp_positions_str disorder_strength = inputs % disorder_strength distribution = inputs % distribution position = inputs % position width = inputs % width barrier_width = inputs % barrier_width well_depth = inputs % well_depth well_width = inputs % well_width position1 = inputs % position1 width1 = inputs % width1 position2 = inputs % position2 width2 = inputs % width2 max_iter = inputs % max_iter density_tol = inputs % density_tol energy_tol = inputs % energy_tol mixing_alpha = inputs % mixing_alpha verbose = inputs % verbose store_history = inputs % store_history use_adaptive_mixing = inputs % use_adaptive_mixing output_prefix = inputs % output_prefix save_density = inputs % save_density save_eigenvalues = inputs % save_eigenvalues save_wavefunction = inputs % save_wavefunction ! Open and read file open ( newunit = io_unit , file = filename , status = 'old' , iostat = io_stat ) if ( io_stat /= 0 ) then print * , \"ERROR: Could not open file: \" , trim ( filename ) ierr = ERROR_FILE_NOT_FOUND return end if ! Read namelists (silently skip missing sections) read ( io_unit , nml = system , iostat = io_stat ) rewind ( io_unit ) read ( io_unit , nml = potential , iostat = io_stat ) rewind ( io_unit ) read ( io_unit , nml = scf , iostat = io_stat ) rewind ( io_unit ) read ( io_unit , nml = output , iostat = io_stat ) close ( io_unit ) ! Update inputs structure inputs % L = L inputs % Nup = Nup inputs % Ndown = Ndown inputs % U = U inputs % bc_type = bc inputs % phase = phase inputs % potential_type = potential_type inputs % V0 = V0 inputs % pot_center = pot_center inputs % pot_width = pot_width inputs % concentration = concentration inputs % pot_seed = pot_seed inputs % imp_positions_str = imp_positions_str inputs % disorder_strength = disorder_strength inputs % distribution = distribution inputs % position = position inputs % width = width inputs % barrier_width = barrier_width inputs % well_depth = well_depth inputs % well_width = well_width inputs % position1 = position1 inputs % width1 = width1 inputs % position2 = position2 inputs % width2 = width2 inputs % max_iter = max_iter inputs % density_tol = density_tol inputs % energy_tol = energy_tol inputs % mixing_alpha = mixing_alpha inputs % verbose = verbose inputs % store_history = store_history inputs % use_adaptive_mixing = use_adaptive_mixing inputs % output_prefix = output_prefix inputs % save_density = save_density inputs % save_eigenvalues = save_eigenvalues inputs % save_wavefunction = save_wavefunction end subroutine read_namelist_file","tags":"","url":"proc/read_namelist_file.html"},{"title":"validate_inputs – LSDA-Hubbard-Fortran","text":"public  subroutine validate_inputs(inputs, ierr) Validate input parameters Arguments Type Intent Optional Attributes Name type( input_params_t ), intent(in) :: inputs integer, intent(out) :: ierr Source Code subroutine validate_inputs ( inputs , ierr ) type ( input_params_t ), intent ( in ) :: inputs integer , intent ( out ) :: ierr ierr = ERROR_SUCCESS ! Validate system parameters if ( inputs % L <= 0 ) then print * , \"ERROR: L must be positive, got L =\" , inputs % L ierr = ERROR_INVALID_INPUT return end if if ( inputs % Nup < 0 . or . inputs % Ndown < 0 ) then print * , \"ERROR: Nup and Ndown must be non-negative\" ierr = ERROR_INVALID_INPUT return end if if ( inputs % Nup + inputs % Ndown > 2 * inputs % L ) then print * , \"ERROR: N = Nup + Ndown cannot exceed 2L (Pauli exclusion)\" print * , \"  N =\" , inputs % Nup + inputs % Ndown , \", 2L =\" , 2 * inputs % L ierr = ERROR_INVALID_INPUT return end if ! Validate boundary conditions select case ( trim ( inputs % bc_type )) case ( 'open' , 'periodic' , 'twisted' ) ! Valid case default print * , \"ERROR: Invalid boundary condition: \" , trim ( inputs % bc_type ) print * , \"  Valid options: open, periodic, twisted\" ierr = ERROR_INVALID_INPUT return end select ! Validate concentration for impurity potential if ( trim ( inputs % potential_type ) == 'impurity' ) then if ( inputs % concentration <= 0.0_dp . or . & inputs % concentration > 10 0.0_dp ) then print * , \"ERROR: concentration must be in (0, 100], got:\" , & inputs % concentration ierr = ERROR_INVALID_INPUT return end if end if ! Validate SCF parameters if ( inputs % max_iter <= 0 ) then print * , \"ERROR: max_iter must be positive\" ierr = ERROR_INVALID_INPUT return end if if ( inputs % mixing_alpha <= 0.0_dp . or . inputs % mixing_alpha > 1.0_dp ) then print * , \"ERROR: mixing_alpha must be in (0, 1]\" ierr = ERROR_INVALID_INPUT return end if end subroutine validate_inputs","tags":"","url":"proc/validate_inputs.html"},{"title":"convert_to_system_params – LSDA-Hubbard-Fortran","text":"public  subroutine convert_to_system_params(inputs, sys_params, ierr) Convert input_params_t to system_params_t Arguments Type Intent Optional Attributes Name type( input_params_t ), intent(in) :: inputs type( system_params_t ), intent(out) :: sys_params integer, intent(out) :: ierr Source Code subroutine convert_to_system_params ( inputs , sys_params , ierr ) type ( input_params_t ), intent ( in ) :: inputs type ( system_params_t ), intent ( out ) :: sys_params integer , intent ( out ) :: ierr ierr = ERROR_SUCCESS sys_params % L = inputs % L sys_params % Nup = inputs % Nup sys_params % Ndown = inputs % Ndown sys_params % U = inputs % U sys_params % phase = inputs % phase ! Convert BC string to integer select case ( trim ( inputs % bc_type )) case ( 'open' ) sys_params % bc = BC_OPEN case ( 'periodic' ) sys_params % bc = BC_PERIODIC case ( 'twisted' ) sys_params % bc = BC_TWISTED case default ierr = ERROR_INVALID_INPUT end select end subroutine convert_to_system_params","tags":"","url":"proc/convert_to_system_params.html"},{"title":"convert_to_scf_params – LSDA-Hubbard-Fortran","text":"public  subroutine convert_to_scf_params(inputs, scf_params) Convert input_params_t to scf_params_t Arguments Type Intent Optional Attributes Name type( input_params_t ), intent(in) :: inputs type( scf_params_t ), intent(out) :: scf_params Source Code subroutine convert_to_scf_params ( inputs , scf_params ) type ( input_params_t ), intent ( in ) :: inputs type ( scf_params_t ), intent ( out ) :: scf_params scf_params % max_iter = inputs % max_iter scf_params % density_tol = inputs % density_tol scf_params % energy_tol = inputs % energy_tol scf_params % mixing_alpha = inputs % mixing_alpha scf_params % verbose = inputs % verbose scf_params % store_history = inputs % store_history scf_params % use_adaptive_mixing = inputs % use_adaptive_mixing end subroutine convert_to_scf_params","tags":"","url":"proc/convert_to_scf_params.html"},{"title":"parse_integer_arg – LSDA-Hubbard-Fortran","text":"private  subroutine parse_integer_arg(current_idx, nargs, value, ierr) Parse integer argument from command line Arguments Type Intent Optional Attributes Name integer, intent(in) :: current_idx integer, intent(in) :: nargs integer, intent(out) :: value integer, intent(out) :: ierr Called by proc~~parse_integer_arg~~CalledByGraph proc~parse_integer_arg parse_integer_arg proc~parse_inputs parse_inputs proc~parse_inputs->proc~parse_integer_arg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine parse_integer_arg ( current_idx , nargs , value , ierr ) integer , intent ( in ) :: current_idx , nargs integer , intent ( out ) :: value integer , intent ( out ) :: ierr character ( len = 256 ) :: arg , arg_name integer :: io_stat if ( current_idx + 1 > nargs ) then call get_command_argument ( current_idx , arg_name ) print * , \"ERROR: \" , trim ( arg_name ), \" requires a value\" ierr = ERROR_INVALID_INPUT return end if call get_command_argument ( current_idx + 1 , arg ) read ( arg , * , iostat = io_stat ) value if ( io_stat /= 0 ) then call get_command_argument ( current_idx , arg_name ) print * , \"ERROR: Invalid integer for \" , trim ( arg_name ), \": \" , trim ( arg ) ierr = ERROR_INVALID_INPUT else ierr = ERROR_SUCCESS end if end subroutine parse_integer_arg","tags":"","url":"proc/parse_integer_arg.html"},{"title":"parse_real_arg – LSDA-Hubbard-Fortran","text":"private  subroutine parse_real_arg(current_idx, nargs, value, ierr) Parse real argument from command line Arguments Type Intent Optional Attributes Name integer, intent(in) :: current_idx integer, intent(in) :: nargs real(kind=dp), intent(out) :: value integer, intent(out) :: ierr Called by proc~~parse_real_arg~~CalledByGraph proc~parse_real_arg parse_real_arg proc~parse_inputs parse_inputs proc~parse_inputs->proc~parse_real_arg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine parse_real_arg ( current_idx , nargs , value , ierr ) integer , intent ( in ) :: current_idx , nargs real ( dp ), intent ( out ) :: value integer , intent ( out ) :: ierr character ( len = 256 ) :: arg , arg_name integer :: io_stat if ( current_idx + 1 > nargs ) then call get_command_argument ( current_idx , arg_name ) print * , \"ERROR: \" , trim ( arg_name ), \" requires a value\" ierr = ERROR_INVALID_INPUT return end if call get_command_argument ( current_idx + 1 , arg ) read ( arg , * , iostat = io_stat ) value if ( io_stat /= 0 ) then call get_command_argument ( current_idx , arg_name ) print * , \"ERROR: Invalid real number for \" , trim ( arg_name ), \": \" , trim ( arg ) ierr = ERROR_INVALID_INPUT else ierr = ERROR_SUCCESS end if end subroutine parse_real_arg","tags":"","url":"proc/parse_real_arg.html"},{"title":"print_help – LSDA-Hubbard-Fortran","text":"private  subroutine print_help() Print help message Arguments None Called by proc~~print_help~~CalledByGraph proc~print_help print_help proc~parse_inputs parse_inputs proc~parse_inputs->proc~print_help Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine print_help () print '(A)' , \"\" print '(A)' , \"LSDA-Hubbard: 1D Hubbard Model DFT-LSDA Calculator\" print '(A)' , \"==================================================\" print '(A)' , \"\" print '(A)' , \"Usage:\" print '(A)' , \"  fpm run lsdaks -- --input <file>     # Read from namelist file\" print '(A)' , \"  fpm run lsdaks -- [options]          # Command line mode\" print '(A)' , \"\" print '(A)' , \"System Parameters:\" print '(A)' , \"  --L <int>         Number of lattice sites (default: 10)\" print '(A)' , \"  --Nup <int>       Number of spin-up electrons (default: 5)\" print '(A)' , \"  --Ndown <int>     Number of spin-down electrons (default: 5)\" print '(A)' , \"  --U <real>        Hubbard interaction strength (default: 4.0)\" print '(A)' , \"  --bc <type>       Boundary conditions: open/periodic/twisted (default: periodic)\" print '(A)' , \"  --phase <real>    Twist angle for twisted BC (default: 0.0)\" print '(A)' , \"\" print '(A)' , \"Potential:\" print '(A)' , \"  --potential <type>    Type: uniform/harmonic/impurity/... (default: uniform)\" print '(A)' , \"  --V0 <real>           Potential strength (default: 0.0)\" print '(A)' , \"  --concentration <real> Impurity concentration in % (default: 50.0)\" print '(A)' , \"\" print '(A)' , \"Output:\" print '(A)' , \"  --verbose         Print SCF progress (default: on)\" print '(A)' , \"  --quiet           Suppress SCF progress\" print '(A)' , \"\" print '(A)' , \"Other:\" print '(A)' , \"  --help, -h        Show this help message\" print '(A)' , \"\" print '(A)' , \"Examples:\" print '(A)' , \"  fpm run lsdaks -- --L 10 --Nup 5 --Ndown 5 --U 4.0\" print '(A)' , \"  fpm run lsdaks -- --input my_simulation.txt\" print '(A)' , \"\" end subroutine print_help","tags":"","url":"proc/print_help.html"},{"title":"apply_potential_harmonic – LSDA-Hubbard-Fortran","text":"public  subroutine apply_potential_harmonic(k, L, V, ierr) Uses lsda_errors proc~~apply_potential_harmonic~~UsesGraph proc~apply_potential_harmonic apply_potential_harmonic module~lsda_errors lsda_errors proc~apply_potential_harmonic->module~lsda_errors module~lsda_constants lsda_constants module~lsda_errors->module~lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Harmonic trap potential: V(i) = k * (i - i_center)² Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr Called by proc~~apply_potential_harmonic~~CalledByGraph proc~apply_potential_harmonic apply_potential_harmonic proc~create_potential create_potential proc~create_potential->proc~apply_potential_harmonic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine apply_potential_harmonic ( k , L , V , ierr ) use lsda_errors , only : ERROR_SUCCESS real ( dp ), intent ( in ) :: k integer , intent ( in ) :: L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr real ( dp ) :: i_center integer :: i i_center = real ( L + 1 , dp ) / 2.0_dp ! NOTE: NO 0.5 factor! This matches C++ original code exactly. V = [( k * ( real ( i , dp ) - i_center ) ** 2 , i = 1 , L )] ierr = ERROR_SUCCESS end subroutine apply_potential_harmonic","tags":"","url":"proc/apply_potential_harmonic.html"},{"title":"determine_region – LSDA-Hubbard-Fortran","text":"private  function determine_region(n_up, n_dw) result(region) Determine symmetry region for (n_up, n_dw) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw Return Value integer Called by proc~~determine_region~~CalledByGraph proc~determine_region determine_region proc~get_exc get_exc proc~get_exc->proc~determine_region proc~get_vxc get_vxc proc~get_vxc->proc~determine_region proc~compute_total_energy compute_total_energy proc~compute_total_energy->proc~get_exc proc~compute_total_energy->proc~get_vxc proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~get_vxc proc~run_kohn_sham_scf_complex->proc~compute_total_energy proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~get_vxc proc~run_kohn_sham_scf_real->proc~compute_total_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function determine_region ( n_up , n_dw ) result ( region ) real ( dp ), intent ( in ) :: n_up , n_dw integer :: region real ( dp ) :: n , m real ( dp ), parameter :: TOL = 1.0e-12_dp ! Tolerance for boundary cases n = n_up + n_dw m = n_up - n_dw ! Use tolerances to handle floating-point errors at n = 1.0 boundary ! This is critical for half-filling cases where n = n_up + n_down = 1.0 if ( m >= - TOL . and . n <= 1.0_dp + TOL ) then region = 1 else if ( m < - TOL . and . n <= 1.0_dp + TOL ) then region = 2 else if ( m < - TOL . and . n > 1.0_dp + TOL ) then region = 3 else region = 4 ! m ≥ 0 and n > 1 end if end function determine_region","tags":"","url":"proc/determine_region.html"},{"title":"xc_lsda_init – LSDA-Hubbard-Fortran","text":"public  subroutine xc_lsda_init(xc, table_file, ierr) Initialize XC functional from table file Arguments Type Intent Optional Attributes Name type( xc_lsda_t ), intent(out) :: xc character(len=*), intent(in) :: table_file integer, intent(out) :: ierr Calls proc~~xc_lsda_init~~CallsGraph proc~xc_lsda_init xc_lsda_init proc~deallocate_table deallocate_table proc~xc_lsda_init->proc~deallocate_table proc~read_fortran_table read_fortran_table proc~xc_lsda_init->proc~read_fortran_table proc~spline2d_init spline2d_init proc~xc_lsda_init->proc~spline2d_init proc~read_fortran_table->proc~deallocate_table d2y_temp d2y_temp proc~spline2d_init->d2y_temp f_temp f_temp proc~spline2d_init->f_temp proc~spline1d_coeff spline1d_coeff proc~spline2d_init->proc~spline1d_coeff y_temp y_temp proc~spline2d_init->y_temp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine xc_lsda_init ( xc , table_file , ierr ) type ( xc_lsda_t ), intent ( out ) :: xc character ( len =* ), intent ( in ) :: table_file integer , intent ( out ) :: ierr type ( xc_table_t ) :: table integer :: io_stat integer , allocatable :: n_y_pts (:) integer :: i ierr = ERROR_SUCCESS call read_fortran_table ( table_file , table , io_stat ) if ( io_stat /= 0 ) then print * , \"ERROR: Failed to read table file: \" , trim ( table_file ) ierr = ERROR_FILE_READ return end if xc % U = table % U ! Create n_y_pts array (same for all n_grid points in current implementation) allocate ( n_y_pts ( table % n_points_n )) do i = 1 , table % n_points_n n_y_pts ( i ) = table % n_points_m end do call spline2d_init ( xc % spl_exc , table % n_grid , table % m_grid , & table % exc , n_y_pts ) call spline2d_init ( xc % spl_vxc_up , table % n_grid , table % m_grid , & table % vxc_up , n_y_pts ) call spline2d_init ( xc % spl_vxc_down , table % n_grid , table % m_grid , & table % vxc_down , n_y_pts ) deallocate ( n_y_pts ) if (. not . xc % spl_exc % initialized . or . & . not . xc % spl_vxc_up % initialized . or . & . not . xc % spl_vxc_down % initialized ) then ierr = ERROR_SPLINE_INITIALIZATION_FAILED call deallocate_table ( table ) return end if xc % initialized = . true . call deallocate_table ( table ) end subroutine xc_lsda_init","tags":"","url":"proc/xc_lsda_init.html"},{"title":"get_exc – LSDA-Hubbard-Fortran","text":"public  subroutine get_exc(xc, n_up, n_dw, exc, ierr) Get exchange-correlation energy per particle at (n_up, n_dw) Arguments Type Intent Optional Attributes Name type( xc_lsda_t ), intent(in) :: xc real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw real(kind=dp), intent(out) :: exc integer, intent(out) :: ierr Calls proc~~get_exc~~CallsGraph proc~get_exc get_exc proc~apply_symmetry_transform apply_symmetry_transform proc~get_exc->proc~apply_symmetry_transform proc~convert_to_nm convert_to_nm proc~get_exc->proc~convert_to_nm proc~determine_region determine_region proc~get_exc->proc~determine_region proc~spline2d_eval spline2d_eval proc~get_exc->proc~spline2d_eval d2y_tmp d2y_tmp proc~spline2d_eval->d2y_tmp f_tmp f_tmp proc~spline2d_eval->f_tmp proc~find_interval find_interval proc~spline2d_eval->proc~find_interval proc~spline1d_eval spline1d_eval proc~spline2d_eval->proc~spline1d_eval y_tmp y_tmp proc~spline2d_eval->y_tmp proc~spline1d_eval->proc~find_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_exc~~CalledByGraph proc~get_exc get_exc proc~compute_total_energy compute_total_energy proc~compute_total_energy->proc~get_exc proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~compute_total_energy proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~compute_total_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_exc ( xc , n_up , n_dw , exc , ierr ) type ( xc_lsda_t ), intent ( in ) :: xc real ( dp ), intent ( in ) :: n_up , n_dw real ( dp ), intent ( out ) :: exc integer , intent ( out ) :: ierr integer :: region real ( dp ) :: n_up_map , n_dw_map , n , m ! Check initialization if (. not . xc % initialized ) then exc = 0.0_dp ierr = ERROR_INVALID_INPUT return end if ! Special case: U = 0 (free Fermi gas) if ( abs ( xc % U ) < U_SMALL ) then exc = 0.0_dp ierr = ERROR_SUCCESS return end if ! Check density bounds ! Note: Particle-hole symmetry allows n_up, n_down > 1.0 ! Maximum total density is n_up + n_down ≤ 2 (Pauli exclusion) ! Use small tolerance to handle floating-point roundoff (e.g., 1.0+1.0 = 2.0000...009) if ( n_up < - 1.0e-12_dp . or . n_dw < - 1.0e-12_dp . or . & ( n_up + n_dw ) > 2.0_dp + 1.0e-10_dp ) then exc = 0.0_dp ierr = ERROR_OUT_OF_BOUNDS return end if ! Special case: both densities zero if ( n_up < 1.0e-12_dp . and . n_dw < 1.0e-12_dp ) then exc = 0.0_dp ierr = ERROR_SUCCESS return end if ! Determine region and apply symmetry region = determine_region ( n_up , n_dw ) call apply_symmetry_transform ( region , n_up , n_dw , n_up_map , n_dw_map ) ! Clip to valid range to handle numerical errors near boundaries ! This is especially important for n ≈ 2.0 where particle-hole transform ! can produce small negative values due to roundoff n_up_map = max ( 0.0_dp , min ( 1.0_dp , n_up_map )) n_dw_map = max ( 0.0_dp , min ( 1.0_dp , n_dw_map )) call convert_to_nm ( n_up_map , n_dw_map , n , m ) ! Evaluate spline exc = spline2d_eval ( xc % spl_exc , n , m ) ierr = ERROR_SUCCESS end subroutine get_exc","tags":"","url":"proc/get_exc.html"},{"title":"get_vxc – LSDA-Hubbard-Fortran","text":"public  subroutine get_vxc(xc, n_up, n_dw, v_xc_up, v_xc_dw, ierr) Get exchange-correlation potentials at (n_up, n_dw) Arguments Type Intent Optional Attributes Name type( xc_lsda_t ), intent(in) :: xc real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw real(kind=dp), intent(out) :: v_xc_up real(kind=dp), intent(out) :: v_xc_dw integer, intent(out) :: ierr Calls proc~~get_vxc~~CallsGraph proc~get_vxc get_vxc proc~apply_symmetry_transform apply_symmetry_transform proc~get_vxc->proc~apply_symmetry_transform proc~convert_to_nm convert_to_nm proc~get_vxc->proc~convert_to_nm proc~determine_region determine_region proc~get_vxc->proc~determine_region proc~spline2d_eval spline2d_eval proc~get_vxc->proc~spline2d_eval d2y_tmp d2y_tmp proc~spline2d_eval->d2y_tmp f_tmp f_tmp proc~spline2d_eval->f_tmp proc~find_interval find_interval proc~spline2d_eval->proc~find_interval proc~spline1d_eval spline1d_eval proc~spline2d_eval->proc~spline1d_eval y_tmp y_tmp proc~spline2d_eval->y_tmp proc~spline1d_eval->proc~find_interval Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_vxc~~CalledByGraph proc~get_vxc get_vxc proc~compute_total_energy compute_total_energy proc~compute_total_energy->proc~get_vxc proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~get_vxc proc~run_kohn_sham_scf_complex->proc~compute_total_energy proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~get_vxc proc~run_kohn_sham_scf_real->proc~compute_total_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_vxc ( xc , n_up , n_dw , v_xc_up , v_xc_dw , ierr ) type ( xc_lsda_t ), intent ( in ) :: xc real ( dp ), intent ( in ) :: n_up , n_dw real ( dp ), intent ( out ) :: v_xc_up , v_xc_dw integer , intent ( out ) :: ierr integer :: region real ( dp ) :: n_up_map , n_dw_map , n , m real ( dp ) :: v_up_base , v_dw_base ! Check initialization if (. not . xc % initialized ) then v_xc_up = 0.0_dp v_xc_dw = 0.0_dp ierr = ERROR_INVALID_INPUT return end if ! Special case: U = 0 (free Fermi gas) if ( abs ( xc % U ) < U_SMALL ) then v_xc_up = 0.0_dp v_xc_dw = 0.0_dp ierr = ERROR_SUCCESS return end if ! Check density bounds ! Note: Particle-hole symmetry allows n_up, n_down > 1.0 ! Maximum total density is n_up + n_down ≤ 2 (Pauli exclusion) ! Use small tolerance to handle floating-point roundoff (e.g., 1.0+1.0 = 2.0000...009) if ( n_up < - 1.0e-12_dp . or . n_dw < - 1.0e-12_dp . or . & ( n_up + n_dw ) > 2.0_dp + 1.0e-10_dp ) then v_xc_up = 0.0_dp v_xc_dw = 0.0_dp ierr = ERROR_OUT_OF_BOUNDS return end if ! Special case: both densities zero if ( n_up < 1.0e-12_dp . and . n_dw < 1.0e-12_dp ) then v_xc_up = 0.0_dp v_xc_dw = 0.0_dp ierr = ERROR_SUCCESS return end if ! Determine region and apply symmetry region = determine_region ( n_up , n_dw ) call apply_symmetry_transform ( region , n_up , n_dw , n_up_map , n_dw_map ) ! Clip to valid range to handle numerical errors near boundaries n_up_map = max ( 0.0_dp , min ( 1.0_dp , n_up_map )) n_dw_map = max ( 0.0_dp , min ( 1.0_dp , n_dw_map )) call convert_to_nm ( n_up_map , n_dw_map , n , m ) ! Evaluate splines v_up_base = spline2d_eval ( xc % spl_vxc_up , n , m ) v_dw_base = spline2d_eval ( xc % spl_vxc_down , n , m ) ! Apply region-specific transformations select case ( region ) case ( 1 ) ! Region I (m ≥ 0, n ≤ 1): Direct v_xc_up = v_up_base v_xc_dw = v_dw_base case ( 2 ) ! Region II (m < 0, n ≤ 1): Spin exchange v_xc_up = v_dw_base v_xc_dw = v_up_base case ( 3 ) ! Region III (m < 0, n > 1): Particle-hole symmetry v_xc_up = - v_up_base v_xc_dw = - v_dw_base case ( 4 ) ! Region IV (m ≥ 0, n > 1): Combined v_xc_up = - v_dw_base v_xc_dw = - v_up_base end select ierr = ERROR_SUCCESS end subroutine get_vxc","tags":"","url":"proc/get_vxc.html"},{"title":"xc_lsda_destroy – LSDA-Hubbard-Fortran","text":"public  subroutine xc_lsda_destroy(xc) Destroy XC functional and free memory Arguments Type Intent Optional Attributes Name type( xc_lsda_t ), intent(inout) :: xc Calls proc~~xc_lsda_destroy~~CallsGraph proc~xc_lsda_destroy xc_lsda_destroy proc~spline2d_destroy spline2d_destroy proc~xc_lsda_destroy->proc~spline2d_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine xc_lsda_destroy ( xc ) type ( xc_lsda_t ), intent ( inout ) :: xc call spline2d_destroy ( xc % spl_exc ) call spline2d_destroy ( xc % spl_vxc_up ) call spline2d_destroy ( xc % spl_vxc_down ) xc % initialized = . false . xc % U = 0.0_dp end subroutine xc_lsda_destroy","tags":"","url":"proc/xc_lsda_destroy.html"},{"title":"convert_to_nm – LSDA-Hubbard-Fortran","text":"private  subroutine convert_to_nm(n_up, n_dw, n, m) Convert (n_up, n_dw) to (n, m) coordinates Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw real(kind=dp), intent(out) :: n real(kind=dp), intent(out) :: m Called by proc~~convert_to_nm~~CalledByGraph proc~convert_to_nm convert_to_nm proc~get_exc get_exc proc~get_exc->proc~convert_to_nm proc~get_vxc get_vxc proc~get_vxc->proc~convert_to_nm proc~compute_total_energy compute_total_energy proc~compute_total_energy->proc~get_exc proc~compute_total_energy->proc~get_vxc proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~get_vxc proc~run_kohn_sham_scf_complex->proc~compute_total_energy proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~get_vxc proc~run_kohn_sham_scf_real->proc~compute_total_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine convert_to_nm ( n_up , n_dw , n , m ) real ( dp ), intent ( in ) :: n_up , n_dw real ( dp ), intent ( out ) :: n , m n = n_up + n_dw m = n_up - n_dw end subroutine convert_to_nm","tags":"","url":"proc/convert_to_nm.html"},{"title":"apply_symmetry_transform – LSDA-Hubbard-Fortran","text":"private  subroutine apply_symmetry_transform(region, n_up, n_dw, n_up_map, n_dw_map) Apply symmetry transformation to map any region to Region I Arguments Type Intent Optional Attributes Name integer, intent(in) :: region real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw real(kind=dp), intent(out) :: n_up_map real(kind=dp), intent(out) :: n_dw_map Called by proc~~apply_symmetry_transform~~CalledByGraph proc~apply_symmetry_transform apply_symmetry_transform proc~get_exc get_exc proc~get_exc->proc~apply_symmetry_transform proc~get_vxc get_vxc proc~get_vxc->proc~apply_symmetry_transform proc~compute_total_energy compute_total_energy proc~compute_total_energy->proc~get_exc proc~compute_total_energy->proc~get_vxc proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~get_vxc proc~run_kohn_sham_scf_complex->proc~compute_total_energy proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~get_vxc proc~run_kohn_sham_scf_real->proc~compute_total_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine apply_symmetry_transform ( region , n_up , n_dw , n_up_map , n_dw_map ) integer , intent ( in ) :: region real ( dp ), intent ( in ) :: n_up , n_dw real ( dp ), intent ( out ) :: n_up_map , n_dw_map select case ( region ) case ( 1 ) ! Region I: Direct (no transformation) n_up_map = n_up n_dw_map = n_dw case ( 2 ) ! Region II: Spin exchange n_up_map = n_dw n_dw_map = n_up case ( 3 ) ! Region III: Particle-hole symmetry n_up_map = 1.0_dp - n_up n_dw_map = 1.0_dp - n_dw case ( 4 ) ! Region IV: Combined (particle-hole + spin exchange) n_up_map = 1.0_dp - n_dw n_dw_map = 1.0_dp - n_up case default ! Should never happen (region is always 1-4 from determine_region) ! Return identity transformation as fallback n_up_map = n_up n_dw_map = n_dw end select end subroutine apply_symmetry_transform","tags":"","url":"proc/apply_symmetry_transform.html"},{"title":"get_error_message – LSDA-Hubbard-Fortran","text":"public  function get_error_message(ierr) result(msg) Get human-readable error message for a given error code Arguments Type Intent Optional Attributes Name integer, intent(in) :: ierr Return Value character(len=256) Called by proc~~get_error_message~~CalledByGraph proc~get_error_message get_error_message proc~error_handler error_handler proc~error_handler->proc~get_error_message Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_error_message ( ierr ) result ( msg ) integer , intent ( in ) :: ierr character ( len = 256 ) :: msg select case ( ierr ) ! Success case ( ERROR_SUCCESS ) msg = \"Success\" ! Input validation errors (1-99) case ( ERROR_INVALID_INPUT ) msg = \"Invalid input parameter\" case ( ERROR_OUT_OF_BOUNDS ) msg = \"Value out of valid bounds\" case ( ERROR_SIZE_MISMATCH ) msg = \"Array size mismatch\" case ( ERROR_INVALID_CONCENTRATION ) msg = \"Invalid concentration (must be 0 < c <= 100)\" case ( ERROR_NEGATIVE_VALUE ) msg = \"Value must be non-negative\" case ( ERROR_INVALID_RANGE ) msg = \"Value outside valid range\" case ( ERROR_NOT_A_NUMBER ) msg = \"Array contains NaN or Inf values\" case ( ERROR_UNPHYSICAL_DENSITY ) msg = \"Unphysical density values detected\" case ( ERROR_SPLINE_INITIALIZATION_FAILED ) msg = \"Spline initialization failed\" ! Numerical errors (100-199) case ( ERROR_CONVERGENCE_FAILED ) msg = \"Numerical convergence failed\" case ( ERROR_SINGULAR_MATRIX ) msg = \"Matrix is singular or ill-conditioned\" case ( ERROR_LAPACK_FAILED ) msg = \"LAPACK routine failed\" case ( ERROR_LAPACK_INVALID_ARG ) msg = \"Invalid argument passed to LAPACK routine\" case ( ERROR_LINEAR_DEPENDENCE ) msg = \"Linear dependence detected in vector set\" ! I/O errors (200-299) case ( ERROR_FILE_NOT_FOUND ) msg = \"File not found\" case ( ERROR_FILE_READ ) msg = \"Error reading file\" case ( ERROR_FILE_WRITE ) msg = \"Error writing file\" ! Memory errors (300-399) case ( ERROR_ALLOCATION_FAILED ) msg = \"Memory allocation failed\" case ( ERROR_DEALLOCATION_FAILED ) msg = \"Memory deallocation failed\" case default write ( msg , '(A,I0)' ) \"Unknown error code: \" , ierr end select end function get_error_message","tags":"","url":"proc/get_error_message.html"},{"title":"error_handler – LSDA-Hubbard-Fortran","text":"public  subroutine error_handler(ierr, routine_name, extra_info, fatal) Generic error handler that prints error messages Arguments Type Intent Optional Attributes Name integer, intent(in) :: ierr character(len=*), intent(in) :: routine_name character(len=*), intent(in), optional :: extra_info logical, intent(in), optional :: fatal Calls proc~~error_handler~~CallsGraph proc~error_handler error_handler proc~get_error_message get_error_message proc~error_handler->proc~get_error_message Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine error_handler ( ierr , routine_name , extra_info , fatal ) integer , intent ( in ) :: ierr character ( len =* ), intent ( in ) :: routine_name character ( len =* ), intent ( in ), optional :: extra_info logical , intent ( in ), optional :: fatal character ( len = 256 ) :: msg logical :: is_fatal ! Check if fatal (default is .false.) is_fatal = . false . if ( present ( fatal )) is_fatal = fatal ! If success, do nothing if ( ierr == ERROR_SUCCESS ) return ! Get error message msg = get_error_message ( ierr ) ! Print error write ( * , '(A)' ) \"============================================\" write ( * , '(A,I0)' ) \"ERROR CODE: \" , ierr write ( * , '(A,A)' ) \"ROUTINE:    \" , trim ( routine_name ) write ( * , '(A,A)' ) \"MESSAGE:    \" , trim ( msg ) if ( present ( extra_info )) then if ( len_trim ( extra_info ) > 0 ) then write ( * , '(A,A)' ) \"DETAILS:    \" , trim ( extra_info ) end if end if write ( * , '(A)' ) \"============================================\" ! Stop if fatal if ( is_fatal ) then write ( * , '(A)' ) \"FATAL ERROR - Stopping execution\" stop 1 end if end subroutine error_handler","tags":"","url":"proc/error_handler.html"},{"title":"check_bounds – LSDA-Hubbard-Fortran","text":"public  subroutine check_bounds(val, min_val, max_val, ierr) Check if a value is within bounds [min_val, max_val] Arguments Type Intent Optional Attributes Name integer, intent(in) :: val integer, intent(in) :: min_val integer, intent(in) :: max_val integer, intent(out) :: ierr Source Code subroutine check_bounds ( val , min_val , max_val , ierr ) integer , intent ( in ) :: val , min_val , max_val integer , intent ( out ) :: ierr if ( val < min_val . or . val > max_val ) then ierr = ERROR_OUT_OF_BOUNDS else ierr = ERROR_SUCCESS end if end subroutine check_bounds","tags":"","url":"proc/check_bounds.html"},{"title":"check_positive – LSDA-Hubbard-Fortran","text":"public  subroutine check_positive(val, allow_zero, ierr) Check if a value is positive (> 0) or non-negative (>= 0) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val logical, intent(in) :: allow_zero integer, intent(out) :: ierr Source Code subroutine check_positive ( val , allow_zero , ierr ) real ( dp ), intent ( in ) :: val logical , intent ( in ) :: allow_zero integer , intent ( out ) :: ierr if ( allow_zero ) then ! Check val >= 0 if ( val < 0.0_dp ) then ierr = ERROR_NEGATIVE_VALUE else ierr = ERROR_SUCCESS end if else ! Check val > 0 if ( val <= 0.0_dp ) then ierr = ERROR_NEGATIVE_VALUE else ierr = ERROR_SUCCESS end if end if end subroutine check_positive","tags":"","url":"proc/check_positive.html"},{"title":"check_range – LSDA-Hubbard-Fortran","text":"public  subroutine check_range(val, min_val, max_val, ierr) Check if a value is within a real range [min_val, max_val] Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val real(kind=dp), intent(in) :: min_val real(kind=dp), intent(in) :: max_val integer, intent(out) :: ierr Source Code subroutine check_range ( val , min_val , max_val , ierr ) real ( dp ), intent ( in ) :: val , min_val , max_val integer , intent ( out ) :: ierr if ( val < min_val . or . val > max_val ) then ierr = ERROR_INVALID_RANGE else ierr = ERROR_SUCCESS end if end subroutine check_range","tags":"","url":"proc/check_range.html"},{"title":"validate_hamiltonian_inputs – LSDA-Hubbard-Fortran","text":"public  subroutine validate_hamiltonian_inputs(L, V_ext, V_xc, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: L real(kind=dp), intent(in) :: V_ext (:) real(kind=dp), intent(in) :: V_xc (:) integer, intent(out) :: ierr Called by proc~~validate_hamiltonian_inputs~~CalledByGraph proc~validate_hamiltonian_inputs validate_hamiltonian_inputs proc~build_hamiltonian build_hamiltonian proc~build_hamiltonian->proc~validate_hamiltonian_inputs proc~build_hamiltonian_complex build_hamiltonian_complex proc~build_hamiltonian_complex->proc~validate_hamiltonian_inputs proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~build_hamiltonian_complex proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~build_hamiltonian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine validate_hamiltonian_inputs ( L , V_ext , V_xc , ierr ) ! No hopping parameter as input - assuming t = 1 integer , intent ( in ) :: L real ( dp ), intent ( in ) :: V_ext (:) real ( dp ), intent ( in ) :: V_xc (:) integer , intent ( out ) :: ierr ierr = 0 if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( V_ext ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( V_xc ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if (. not . ALL ( ieee_is_finite ( V_ext ))) then ierr = ERROR_NOT_A_NUMBER return end if if (. not . ALL ( ieee_is_finite ( V_xc ))) then ierr = ERROR_NOT_A_NUMBER return end if end subroutine validate_hamiltonian_inputs","tags":"","url":"proc/validate_hamiltonian_inputs.html"},{"title":"build_hamiltonian – LSDA-Hubbard-Fortran","text":"public  subroutine build_hamiltonian(L, V_ext, V_xc, bc_type, theta, H, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: L real(kind=dp), intent(in) :: V_ext (:) real(kind=dp), intent(in) :: V_xc (:) integer, intent(in) :: bc_type real(kind=dp), intent(in), optional :: theta real(kind=dp), intent(out) :: H (:,:) integer, intent(out) :: ierr Calls proc~~build_hamiltonian~~CallsGraph proc~build_hamiltonian build_hamiltonian proc~apply_boundary_conditions apply_boundary_conditions proc~build_hamiltonian->proc~apply_boundary_conditions proc~validate_hamiltonian_inputs validate_hamiltonian_inputs proc~build_hamiltonian->proc~validate_hamiltonian_inputs proc~validate_bc_parameters validate_bc_parameters proc~apply_boundary_conditions->proc~validate_bc_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~build_hamiltonian~~CalledByGraph proc~build_hamiltonian build_hamiltonian proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~build_hamiltonian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine build_hamiltonian ( L , V_ext , V_xc , bc_type , theta , H , ierr ) integer , intent ( in ) :: L real ( dp ), intent ( in ) :: V_ext (:), V_xc (:) integer , intent ( in ) :: bc_type real ( dp ), intent ( in ), optional :: theta real ( dp ), intent ( out ) :: H (:,:) integer , intent ( out ) :: ierr integer :: i call validate_hamiltonian_inputs ( L , V_ext , V_xc , ierr ) if ( ierr /= 0 ) return if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if H = 0.0_dp do i = 1 , L H ( i , i ) = V_ext ( i ) + V_xc ( i ) end do do i = 1 , L - 1 H ( i , i + 1 ) = - 1.0_dp ! Assuming hopping parameter t = 1 H ( i + 1 , i ) = - 1.0_dp ! Assuming hopping parameter t = 1 end do call apply_boundary_conditions ( H , L , bc_type , theta , ierr ) end subroutine build_hamiltonian","tags":"","url":"proc/build_hamiltonian.html"},{"title":"build_hamiltonian_complex – LSDA-Hubbard-Fortran","text":"public  subroutine build_hamiltonian_complex(L, V_ext, V_xc, bc_type, theta, H, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: L real(kind=dp), intent(in) :: V_ext (:) real(kind=dp), intent(in) :: V_xc (:) integer, intent(in) :: bc_type real(kind=dp), intent(in) :: theta complex(kind=dp), intent(out) :: H (:,:) integer, intent(out) :: ierr Calls proc~~build_hamiltonian_complex~~CallsGraph proc~build_hamiltonian_complex build_hamiltonian_complex proc~apply_boundary_conditions_complex apply_boundary_conditions_complex proc~build_hamiltonian_complex->proc~apply_boundary_conditions_complex proc~validate_hamiltonian_inputs validate_hamiltonian_inputs proc~build_hamiltonian_complex->proc~validate_hamiltonian_inputs proc~validate_bc_parameters validate_bc_parameters proc~apply_boundary_conditions_complex->proc~validate_bc_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~build_hamiltonian_complex~~CalledByGraph proc~build_hamiltonian_complex build_hamiltonian_complex proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~build_hamiltonian_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine build_hamiltonian_complex ( L , V_ext , V_xc , bc_type , theta , H , ierr ) integer , intent ( in ) :: L real ( dp ), intent ( in ) :: V_ext (:), V_xc (:) integer , intent ( in ) :: bc_type real ( dp ), intent ( in ) :: theta complex ( dp ), intent ( out ) :: H (:,:) integer , intent ( out ) :: ierr integer :: i call validate_hamiltonian_inputs ( L , V_ext , V_xc , ierr ) if ( ierr /= 0 ) return if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if H = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) do i = 1 , L H ( i , i ) = cmplx ( V_ext ( i ) + V_xc ( i ), 0.0_dp , kind = dp ) end do do i = 1 , L - 1 H ( i , i + 1 ) = cmplx ( - 1.0_dp , 0.0_dp , kind = dp ) ! Assuming hopping parameter t = 1 H ( i + 1 , i ) = cmplx ( - 1.0_dp , 0.0_dp , kind = dp ) ! Assuming hopping parameter t = 1 end do call apply_boundary_conditions_complex ( H , L , bc_type , theta , ierr ) end subroutine build_hamiltonian_complex","tags":"","url":"proc/build_hamiltonian_complex.html"},{"title":"build_hamiltonian_free – LSDA-Hubbard-Fortran","text":"public  subroutine build_hamiltonian_free(L, bc_type, theta, H, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: L integer, intent(in) :: bc_type real(kind=dp), intent(in), optional :: theta real(kind=dp), intent(out) :: H (:,:) integer, intent(out) :: ierr Calls proc~~build_hamiltonian_free~~CallsGraph proc~build_hamiltonian_free build_hamiltonian_free proc~apply_boundary_conditions apply_boundary_conditions proc~build_hamiltonian_free->proc~apply_boundary_conditions proc~validate_bc_parameters validate_bc_parameters proc~apply_boundary_conditions->proc~validate_bc_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine build_hamiltonian_free ( L , bc_type , theta , H , ierr ) integer , intent ( in ) :: L integer , intent ( in ) :: bc_type real ( dp ), intent ( in ), optional :: theta real ( dp ), intent ( out ) :: H (:,:) integer , intent ( out ) :: ierr integer :: i ierr = 0 if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if H = 0.0_dp do i = 1 , L - 1 H ( i , i + 1 ) = - 1.0_dp ! Assuming hopping parameter t = 1 H ( i + 1 , i ) = - 1.0_dp ! Assuming hopping parameter t = 1 end do call apply_boundary_conditions ( H , L , bc_type , theta , ierr ) end subroutine build_hamiltonian_free","tags":"","url":"proc/build_hamiltonian_free.html"},{"title":"compute_effective_potential – LSDA-Hubbard-Fortran","text":"public  subroutine compute_effective_potential(V_ext, V_xc, V_eff, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_ext (:) real(kind=dp), intent(in) :: V_xc (:) real(kind=dp), intent(out) :: V_eff (:) integer, intent(out) :: ierr Source Code subroutine compute_effective_potential ( V_ext , V_xc , V_eff , ierr ) real ( dp ), intent ( in ) :: V_ext (:) real ( dp ), intent ( in ) :: V_xc (:) real ( dp ), intent ( out ) :: V_eff (:) integer , intent ( out ) :: ierr integer :: L ierr = 0 L = size ( V_ext ) if ( size ( V_xc ) /= L . or . size ( V_eff ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if V_eff = V_ext + V_xc end subroutine compute_effective_potential","tags":"","url":"proc/compute_effective_potential.html"},{"title":"linear_mixing – LSDA-Hubbard-Fortran","text":"public  subroutine linear_mixing(n_new, n_old, alpha, n_mixed, L, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_new (:) real(kind=dp), intent(in) :: n_old (:) real(kind=dp), intent(in) :: alpha real(kind=dp), intent(out) :: n_mixed (:) integer, intent(in) :: L integer, intent(out) :: ierr Source Code subroutine linear_mixing ( n_new , n_old , alpha , n_mixed , L , ierr ) integer , intent ( in ) :: L real ( dp ), intent ( in ) :: n_new (:), n_old (:) real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( out ) :: n_mixed (:) integer , intent ( out ) :: ierr integer :: i if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( n_new ) /= L . or . size ( n_old ) /= L . or . size ( n_mixed ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( alpha <= 0.0_dp . or . alpha > 1.0_dp ) then ierr = ERROR_INVALID_INPUT return end if ierr = ERROR_SUCCESS n_mixed = ( 1.0_dp - alpha ) * n_old + alpha * n_new end subroutine linear_mixing","tags":"","url":"proc/linear_mixing.html"},{"title":"compute_degeneracy_count – LSDA-Hubbard-Fortran","text":"public  function compute_degeneracy_count(eigvals, L, index) result(deg_count) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigvals (:) integer, intent(in) :: L integer, intent(in) :: index Return Value integer Source Code function compute_degeneracy_count ( eigvals , L , index ) result ( deg_count ) real ( dp ), intent ( in ) :: eigvals (:) integer , intent ( in ) :: L , index real ( dp ) :: eval integer :: deg_count , i if ( index < 1 . or . index > L . or . L <= 0 ) then deg_count = 0 return end if eval = eigvals ( index ) deg_count = 1 do i = index - 1 , 1 , - 1 if ( abs ( eigvals ( i ) - eval ) < DEG_TOL ) then deg_count = deg_count + 1 else exit end if end do do i = index + 1 , L if ( abs ( eigvals ( i ) - eval ) < DEG_TOL ) then deg_count = deg_count + 1 else exit end if end do end function compute_degeneracy_count","tags":"","url":"proc/compute_degeneracy_count.html"},{"title":"find_degenerate_subspaces – LSDA-Hubbard-Fortran","text":"public  subroutine find_degenerate_subspaces(eigvals, L, subspaces, subspaces_sizes, n_subspaces, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigvals (:) integer, intent(in) :: L integer, intent(out), allocatable :: subspaces (:,:) integer, intent(out), allocatable :: subspaces_sizes (:) integer, intent(out) :: n_subspaces integer, intent(out) :: ierr Source Code subroutine find_degenerate_subspaces ( eigvals , L , subspaces , subspaces_sizes , & n_subspaces , ierr ) real ( dp ), intent ( in ) :: eigvals (:) integer , intent ( in ) :: L integer , allocatable , intent ( out ) :: subspaces (:,:) integer , allocatable , intent ( out ) :: subspaces_sizes (:) integer , intent ( out ) :: ierr integer , intent ( out ) :: n_subspaces integer :: i , j , deg_count , idx , max_deg ierr = ERROR_SUCCESS if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( eigvals ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if i = 1 n_subspaces = 0 max_deg = 1 do while ( i <= L ) deg_count = 1 do j = i + 1 , L if ( abs ( eigvals ( j ) - eigvals ( i )) < DEG_TOL ) then deg_count = deg_count + 1 else exit end if end do if ( deg_count > 1 ) then n_subspaces = n_subspaces + 1 max_deg = max ( max_deg , deg_count ) end if i = i + deg_count end do ! If no degeneracies found, return empty arrays if ( n_subspaces == 0 ) then allocate ( subspaces ( 0 , 0 )) allocate ( subspaces_sizes ( 0 )) return end if allocate ( subspaces ( n_subspaces , max_deg )) allocate ( subspaces_sizes ( n_subspaces )) subspaces = 0 idx = 0 i = 1 do while ( i <= L ) deg_count = 1 do j = i + 1 , L if ( abs ( eigvals ( j ) - eigvals ( i )) < DEG_TOL ) then deg_count = deg_count + 1 else exit end if end do if ( deg_count > 1 ) then idx = idx + 1 subspaces_sizes ( idx ) = deg_count do j = 1 , deg_count subspaces ( idx , j ) = i + j - 1 end do end if i = i + deg_count end do end subroutine find_degenerate_subspaces","tags":"","url":"proc/find_degenerate_subspaces.html"},{"title":"orthonormalize_degenerate_subspace – LSDA-Hubbard-Fortran","text":"public  subroutine orthonormalize_degenerate_subspace(eigvecs, L, indexes, n_deg, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: eigvecs (:,:) integer, intent(in) :: L integer, intent(in) :: indexes (:) integer, intent(in) :: n_deg integer, intent(out) :: ierr Calls proc~~orthonormalize_degenerate_subspace~~CallsGraph proc~orthonormalize_degenerate_subspace orthonormalize_degenerate_subspace interface~dgeqrf DGEQRF proc~orthonormalize_degenerate_subspace->interface~dgeqrf interface~dorgqr DORGQR proc~orthonormalize_degenerate_subspace->interface~dorgqr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine orthonormalize_degenerate_subspace ( eigvecs , L , indexes , n_deg , ierr ) real ( dp ), intent ( inout ) :: eigvecs (:,:) integer , intent ( in ) :: L , indexes (:), n_deg integer , intent ( out ) :: ierr real ( dp ), allocatable :: A (:,:), tau (:), work (:) integer :: lwork , info , i if ( n_deg <= 1 ) then ierr = ERROR_SUCCESS ! Nothing to do for a single vector return end if if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( indexes ) < n_deg ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( eigvecs , 1 ) /= L . or . size ( eigvecs , 2 ) < L ) then ierr = ERROR_SIZE_MISMATCH return end if do i = 1 , n_deg if ( indexes ( i ) < 1 . or . indexes ( i ) > L ) then ierr = ERROR_INVALID_INPUT return end if end do allocate ( A ( L , n_deg )) do i = 1 , n_deg A (:, i ) = eigvecs (:, indexes ( i )) end do allocate ( tau ( n_deg )) lwork = - 1 allocate ( work ( 1 )) call DGEQRF ( L , n_deg , A , L , tau , work , lwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_FAILED deallocate ( A , tau , work ) return end if lwork = int ( work ( 1 )) deallocate ( work ) allocate ( work ( lwork )) call DGEQRF ( L , n_deg , A , L , tau , work , lwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_FAILED deallocate ( A , tau , work ) return end if ! Workspace query for DORGQR deallocate ( work ) allocate ( work ( 1 )) lwork = - 1 call DORGQR ( L , n_deg , n_deg , A , L , tau , work , lwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_FAILED deallocate ( A , tau , work ) return end if lwork = int ( work ( 1 )) deallocate ( work ) allocate ( work ( lwork )) call DORGQR ( L , n_deg , n_deg , A , L , tau , work , lwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_FAILED deallocate ( A , tau , work ) return end if do i = 1 , n_deg eigvecs (:, indexes ( i )) = A (:, i ) end do deallocate ( A , tau , work ) end subroutine orthonormalize_degenerate_subspace","tags":"","url":"proc/orthonormalize_degenerate_subspace.html"},{"title":"orthonormalize_degenerate_subspace_complex – LSDA-Hubbard-Fortran","text":"public  subroutine orthonormalize_degenerate_subspace_complex(eigvecs, L, indexes, n_deg, ierr) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: eigvecs (:,:) integer, intent(in) :: L integer, intent(in) :: indexes (:) integer, intent(in) :: n_deg integer, intent(out) :: ierr Source Code subroutine orthonormalize_degenerate_subspace_complex ( eigvecs , L , indexes , n_deg , ierr ) complex ( dp ), intent ( inout ) :: eigvecs (:,:) integer , intent ( in ) :: L , indexes (:), n_deg integer , intent ( out ) :: ierr integer :: j , k , idx_j , idx_k complex ( dp ) :: proj real ( dp ) :: norm ierr = ERROR_SUCCESS if ( n_deg <= 1 ) then ierr = ERROR_SUCCESS ! Nothing to do for a single vector return end if if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( indexes ) < n_deg ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( eigvecs , 1 ) /= L . or . size ( eigvecs , 2 ) < L ) then ierr = ERROR_SIZE_MISMATCH return end if do k = 1 , n_deg if ( indexes ( k ) < 1 . or . indexes ( k ) > L ) then ierr = ERROR_INVALID_INPUT return end if end do ! Modified Gram-Schmidt orthonormalization do k = 1 , n_deg idx_k = indexes ( k ) do j = 1 , k - 1 idx_j = indexes ( j ) proj = DOT_PRODUCT ( eigvecs (:, idx_j ), eigvecs (:, idx_k )) eigvecs (:, idx_k ) = eigvecs (:, idx_k ) - proj * eigvecs (:, idx_j ) end do norm = SQRT ( real ( DOT_PRODUCT ( eigvecs (:, idx_k ), eigvecs (:, idx_k )), kind = dp )) if ( norm < 1.0e-14_dp ) then ierr = ERROR_LINEAR_DEPENDENCE return end if eigvecs (:, idx_k ) = eigvecs (:, idx_k ) / norm end do end subroutine orthonormalize_degenerate_subspace_complex","tags":"","url":"proc/orthonormalize_degenerate_subspace_complex.html"},{"title":"verify_orthonormality – LSDA-Hubbard-Fortran","text":"public  subroutine verify_orthonormality(eigvecs, L, is_orthonormal, max_deviation, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigvecs (:,:) integer, intent(in) :: L logical, intent(out) :: is_orthonormal real(kind=dp), intent(out) :: max_deviation integer, intent(out) :: ierr Calls proc~~verify_orthonormality~~CallsGraph proc~verify_orthonormality verify_orthonormality interface~dgemm DGEMM proc~verify_orthonormality->interface~dgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine verify_orthonormality ( eigvecs , L , is_orthonormal , & max_deviation , ierr ) real ( dp ), intent ( in ) :: eigvecs (:,:) integer , intent ( in ) :: L logical , intent ( out ) :: is_orthonormal real ( dp ), intent ( out ) :: max_deviation integer , intent ( out ) :: ierr real ( dp ), allocatable :: S (:,:) real ( dp ) :: dev integer :: i , j ierr = ERROR_SUCCESS if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( eigvecs , 1 ) /= L . or . size ( eigvecs , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if allocate ( S ( L , L )) call DGEMM ( 'T' , & ! Transpose first matrix 'N' , & ! Don't transpose second L , L , L , & ! Dimensions: m, n, k 1.0_dp , & ! alpha eigvecs , L , & ! A matrix eigvecs , L , & ! B matrix 0.0_dp , & ! beta S , L ) ! C = result max_deviation = 0.0_dp do i = 1 , L do j = 1 , L if ( i == j ) then dev = abs ( S ( i , j ) - 1.0_dp ) else dev = abs ( S ( i , j )) end if max_deviation = max ( max_deviation , dev ) end do end do is_orthonormal = ( max_deviation < 1.0e-8_dp ) deallocate ( S ) end subroutine verify_orthonormality","tags":"","url":"proc/verify_orthonormality.html"},{"title":"DGEQRF – LSDA-Hubbard-Fortran","text":"interface Called by interface~~dgeqrf~~CalledByGraph interface~dgeqrf DGEQRF proc~orthonormalize_degenerate_subspace orthonormalize_degenerate_subspace proc~orthonormalize_degenerate_subspace->interface~dgeqrf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private  subroutine DGEQRF(M, N, A, LDA, TAU, WORK, LWORK, INFO) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N real(kind=dp), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA real(kind=dp), intent(out) :: TAU (*) real(kind=dp), intent(inout) :: WORK (*) integer, intent(in) :: LWORK integer, intent(out) :: INFO","tags":"","url":"interface/dgeqrf.html"},{"title":"DORGQR – LSDA-Hubbard-Fortran","text":"interface Called by interface~~dorgqr~~CalledByGraph interface~dorgqr DORGQR proc~orthonormalize_degenerate_subspace orthonormalize_degenerate_subspace proc~orthonormalize_degenerate_subspace->interface~dorgqr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private  subroutine DORGQR(M, N, K, A, LDA, TAU, WORK, LWORK, INFO) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K real(kind=dp), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA real(kind=dp), intent(in) :: TAU (*) real(kind=dp), intent(inout) :: WORK (*) integer, intent(in) :: LWORK integer, intent(out) :: INFO","tags":"","url":"interface/dorgqr.html"},{"title":"DGEMM – LSDA-Hubbard-Fortran","text":"interface Called by interface~~dgemm~~CalledByGraph interface~dgemm DGEMM proc~verify_orthonormality verify_orthonormality proc~verify_orthonormality->interface~dgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private  subroutine DGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K real(kind=dp), intent(in) :: ALPHA real(kind=dp), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=dp), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=dp), intent(in) :: BETA real(kind=dp), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC","tags":"","url":"interface/dgemm.html"},{"title":"compute_density_difference – LSDA-Hubbard-Fortran","text":"public  subroutine compute_density_difference(n_new, n_old, L, diff, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_new (:) real(kind=dp), intent(in) :: n_old (:) integer, intent(in) :: L real(kind=dp), intent(out) :: diff (:) integer, intent(out) :: ierr Called by proc~~compute_density_difference~~CalledByGraph proc~compute_density_difference compute_density_difference proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~compute_density_difference proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~compute_density_difference Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_density_difference ( n_new , n_old , L , diff , ierr ) real ( dp ), intent ( in ) :: n_new (:), n_old (:) integer , intent ( in ) :: L real ( dp ), intent ( out ) :: diff (:) integer , intent ( out ) :: ierr if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( n_new ) /= L . or . size ( n_old ) /= L . or . size ( diff ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if ierr = ERROR_SUCCESS diff = n_new - n_old end subroutine compute_density_difference","tags":"","url":"proc/compute_density_difference.html"},{"title":"compute_density_norm – LSDA-Hubbard-Fortran","text":"public  subroutine compute_density_norm(delta_n, L, norm_type, norm_value, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: delta_n (:) integer, intent(in) :: L integer, intent(in) :: norm_type real(kind=dp), intent(out) :: norm_value integer, intent(out) :: ierr Called by proc~~compute_density_norm~~CalledByGraph proc~compute_density_norm compute_density_norm proc~check_scf_convergence check_scf_convergence proc~check_scf_convergence->proc~compute_density_norm proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~compute_density_norm proc~run_kohn_sham_scf_complex->proc~check_scf_convergence proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~compute_density_norm proc~run_kohn_sham_scf_real->proc~check_scf_convergence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_density_norm ( delta_n , L , norm_type , norm_value , ierr ) real ( dp ), intent ( in ) :: delta_n (:) integer , intent ( in ) :: L integer , intent ( in ) :: norm_type real ( dp ), intent ( out ) :: norm_value integer , intent ( out ) :: ierr if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( delta_n ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if ierr = ERROR_SUCCESS select case ( norm_type ) case ( L1 ) norm_value = sum ( abs ( delta_n )) case ( L2 ) norm_value = sqrt ( sum ( delta_n ** 2 )) case ( Linf ) norm_value = maxval ( abs ( delta_n )) case default ierr = ERROR_INVALID_INPUT norm_value = - 1.0_dp end select end subroutine compute_density_norm","tags":"","url":"proc/compute_density_norm.html"},{"title":"check_scf_convergence – LSDA-Hubbard-Fortran","text":"public  subroutine check_scf_convergence(delta_n, L, tol, is_converged, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: delta_n (:) integer, intent(in) :: L real(kind=dp), intent(in), optional :: tol logical, intent(out) :: is_converged integer, intent(out) :: ierr Calls proc~~check_scf_convergence~~CallsGraph proc~check_scf_convergence check_scf_convergence proc~compute_density_norm compute_density_norm proc~check_scf_convergence->proc~compute_density_norm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check_scf_convergence~~CalledByGraph proc~check_scf_convergence check_scf_convergence proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~check_scf_convergence proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~check_scf_convergence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine check_scf_convergence ( delta_n , L , tol , is_converged , ierr ) real ( dp ), intent ( in ) :: delta_n (:) integer , intent ( in ) :: L real ( dp ), intent ( in ), optional :: tol logical , intent ( out ) :: is_converged integer , intent ( out ) :: ierr real ( dp ) :: norm_value real ( dp ) :: tolerance integer :: norm_type norm_type = L2 if ( present ( tol )) then tolerance = tol else tolerance = 1.0e-6_dp end if call compute_density_norm ( delta_n , L , norm_type , norm_value , ierr ) if ( ierr /= ERROR_SUCCESS ) then is_converged = . false . return end if ierr = ERROR_SUCCESS is_converged = ( norm_value < tolerance ) end subroutine check_scf_convergence","tags":"","url":"proc/check_scf_convergence.html"},{"title":"update_convergence_history – LSDA-Hubbard-Fortran","text":"public  subroutine update_convergence_history(iteration, norm, energy, history, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iteration real(kind=dp), intent(in) :: norm real(kind=dp), intent(in) :: energy type( convergence_history_t ), intent(inout) :: history integer, intent(out) :: ierr Called by proc~~update_convergence_history~~CalledByGraph proc~update_convergence_history update_convergence_history proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~update_convergence_history proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~update_convergence_history Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine update_convergence_history ( iteration , norm , energy , history , ierr ) integer , intent ( in ) :: iteration real ( dp ), intent ( in ) :: norm real ( dp ), intent ( in ) :: energy type ( convergence_history_t ), intent ( inout ) :: history integer , intent ( out ) :: ierr if ( iteration < 1 . or . iteration > history % max_iter ) then ierr = ERROR_INVALID_INPUT return end if if (. not . allocated ( history % density_norms ) . or . & . not . allocated ( history % energies )) then ierr = ERROR_INVALID_INPUT return end if history % density_norms ( iteration ) = norm history % energies ( iteration ) = energy history % current_iter = iteration ierr = ERROR_SUCCESS end subroutine update_convergence_history","tags":"","url":"proc/update_convergence_history.html"},{"title":"init_convergence_history – LSDA-Hubbard-Fortran","text":"public  subroutine init_convergence_history(history, max_iter, ierr) Arguments Type Intent Optional Attributes Name type( convergence_history_t ), intent(out) :: history integer, intent(in) :: max_iter integer, intent(out) :: ierr Called by proc~~init_convergence_history~~CalledByGraph proc~init_convergence_history init_convergence_history proc~init_scf_results init_scf_results proc~init_scf_results->proc~init_convergence_history proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~init_convergence_history proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~init_convergence_history Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine init_convergence_history ( history , max_iter , ierr ) type ( convergence_history_t ), intent ( out ) :: history integer , intent ( in ) :: max_iter integer , intent ( out ) :: ierr if ( max_iter <= 0 ) then ierr = ERROR_INVALID_INPUT return end if history % max_iter = max_iter history % current_iter = 0 allocate ( history % density_norms ( max_iter )) allocate ( history % energies ( max_iter )) history % density_norms = 0.0_dp history % energies = 0.0_dp ierr = ERROR_SUCCESS end subroutine init_convergence_history","tags":"","url":"proc/init_convergence_history.html"},{"title":"cleanup_convergence_history – LSDA-Hubbard-Fortran","text":"public  subroutine cleanup_convergence_history(history, ierr) Arguments Type Intent Optional Attributes Name type( convergence_history_t ), intent(inout) :: history integer, intent(out) :: ierr Called by proc~~cleanup_convergence_history~~CalledByGraph proc~cleanup_convergence_history cleanup_convergence_history proc~cleanup_scf_results cleanup_scf_results proc~cleanup_scf_results->proc~cleanup_convergence_history Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine cleanup_convergence_history ( history , ierr ) type ( convergence_history_t ), intent ( inout ) :: history integer , intent ( out ) :: ierr if ( allocated ( history % density_norms )) deallocate ( history % density_norms ) if ( allocated ( history % energies )) deallocate ( history % energies ) history % max_iter = 0 history % current_iter = 0 ierr = ERROR_SUCCESS end subroutine cleanup_convergence_history","tags":"","url":"proc/cleanup_convergence_history.html"},{"title":"get_potential_info – LSDA-Hubbard-Fortran","text":"public  function get_potential_info(potential_type) result(info) Get information about a potential type Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: potential_type Return Value character(len=512) Source Code function get_potential_info ( potential_type ) result ( info ) character ( len =* ), intent ( in ) :: potential_type character ( len = 512 ) :: info select case ( trim ( adjustl ( potential_type ))) case ( \"uniform\" ) info = \"Uniform potential: V(i) = V0. Parameters: [V0]\" case ( \"harmonic\" ) info = \"Harmonic trap: V(i) = k*(i-center)&#94;2. Parameters: [k]\" case ( \"impurity_single\" ) info = \"Single impurity: V(i) = V_imp at i_imp. Parameters: [V_imp, i_imp]\" case ( \"impurity_multiple\" ) info = \"Multiple impurities: Use potential_impurity_multiple directly\" case ( \"impurity_random\" ) info = \"Random impurities: Use potential_impurity_random directly\" case ( \"random_uniform\" ) info = \"Random uniform disorder: V(i) ~ Uniform[-W, +W]. Parameters: [W]\" case ( \"random_gaussian\" ) info = \"Random Gaussian: V(i) ~ N(0, sigma&#94;2). Parameters: [sigma]\" case ( \"barrier_single\" ) info = \"Single barrier: V(i) = V_bar in [i_start, i_end]. Parameters: [V_bar, i_start, i_end]\" case ( \"barrier_double\" ) info = \"Double barrier: Two barriers with well. Parameters: [V_bar, L_bar, V_well, L_well]\" case ( \"quasiperiodic\" ) info = \"Quasiperiodic AAH: V(i) = lambda*cos(2*pi*beta*i + phi). Parameters: [lambda, beta, phi]\" case default info = \"Unknown potential type\" end select end function get_potential_info","tags":"","url":"proc/get_potential_info.html"},{"title":"create_potential – LSDA-Hubbard-Fortran","text":"public  subroutine create_potential(potential_type, params, L, seed, V, ierr) Factory function to create any potential type Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: potential_type real(kind=dp), intent(in) :: params (:) integer, intent(in) :: L integer, intent(in) :: seed real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr Calls proc~~create_potential~~CallsGraph proc~create_potential create_potential proc~apply_potential_harmonic apply_potential_harmonic proc~create_potential->proc~apply_potential_harmonic proc~apply_potential_quasiperiodic apply_potential_quasiperiodic proc~create_potential->proc~apply_potential_quasiperiodic proc~apply_potential_uniform apply_potential_uniform proc~create_potential->proc~apply_potential_uniform proc~potential_barrier_double potential_barrier_double proc~create_potential->proc~potential_barrier_double proc~potential_barrier_single potential_barrier_single proc~create_potential->proc~potential_barrier_single proc~potential_impurity_single potential_impurity_single proc~create_potential->proc~potential_impurity_single proc~potential_random_gaussian potential_random_gaussian proc~create_potential->proc~potential_random_gaussian proc~potential_random_uniform potential_random_uniform proc~create_potential->proc~potential_random_uniform Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine create_potential ( potential_type , params , L , seed , V , ierr ) character ( len =* ), intent ( in ) :: potential_type real ( dp ), intent ( in ) :: params (:) integer , intent ( in ) :: L , seed real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr ! Initialize V = 0.0_dp ierr = ERROR_SUCCESS ! Select potential type select case ( trim ( adjustl ( potential_type ))) case ( \"uniform\" ) ! Uniform potential: params(1) = V0 if ( size ( params ) < 1 ) then ierr = ERROR_INVALID_INPUT return end if call apply_potential_uniform ( params ( 1 ), L , V , ierr ) case ( \"harmonic\" ) ! Harmonic trap: params(1) = k if ( size ( params ) < 1 ) then ierr = ERROR_INVALID_INPUT return end if call apply_potential_harmonic ( params ( 1 ), L , V , ierr ) case ( \"impurity_single\" ) ! Single impurity: params(1) = V_imp, params(2) = i_imp if ( size ( params ) < 2 ) then ierr = ERROR_INVALID_INPUT return end if call potential_impurity_single ( params ( 1 ), int ( params ( 2 )), L , V , ierr ) case ( \"random_uniform\" ) ! Random uniform: params(1) = W if ( size ( params ) < 1 ) then ierr = ERROR_INVALID_INPUT return end if call potential_random_uniform ( params ( 1 ), L , seed , V , ierr ) case ( \"random_gaussian\" ) ! Random Gaussian: params(1) = sigma if ( size ( params ) < 1 ) then ierr = ERROR_INVALID_INPUT return end if call potential_random_gaussian ( params ( 1 ), L , seed , V , ierr ) case ( \"barrier_single\" ) ! Single barrier: params(1) = V_bar, params(2) = i_start, params(3) = i_end if ( size ( params ) < 3 ) then ierr = ERROR_INVALID_INPUT return end if call potential_barrier_single ( params ( 1 ), int ( params ( 2 )), int ( params ( 3 )), L , V , ierr ) case ( \"barrier_double\" ) ! Double barrier: params(1) = V_bar, params(2) = L_bar, params(3) = V_well, params(4) = L_well ! Matches C++ double_barrier(Na, Vb, Lb, Vwell, Lwell, v_ext) if ( size ( params ) < 4 ) then ierr = ERROR_INVALID_INPUT return end if call potential_barrier_double ( params ( 1 ), params ( 2 ), params ( 3 ), params ( 4 ), L , V , ierr ) case ( \"quasiperiodic\" ) ! Quasiperiodic: params(1) = lambda, params(2) = beta, params(3) = phi if ( size ( params ) < 3 ) then ierr = ERROR_INVALID_INPUT return end if call apply_potential_quasiperiodic ( params ( 1 ), params ( 2 ), params ( 3 ), L , V , ierr ) case default ierr = ERROR_INVALID_INPUT end select end subroutine create_potential","tags":"","url":"proc/create_potential.html"},{"title":"potential_impurity_single – LSDA-Hubbard-Fortran","text":"public  subroutine potential_impurity_single(V_imp, i_imp, L, V, ierr) Single point impurity: V(i) = V_imp if i = i_imp, else 0 Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_imp integer, intent(in) :: i_imp integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr Called by proc~~potential_impurity_single~~CalledByGraph proc~potential_impurity_single potential_impurity_single proc~create_potential create_potential proc~create_potential->proc~potential_impurity_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine potential_impurity_single ( V_imp , i_imp , L , V , ierr ) real ( dp ), intent ( in ) :: V_imp integer , intent ( in ) :: i_imp , L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr ! Initialize V = 0.0_dp ierr = ERROR_SUCCESS ! Bounds check if ( i_imp < 1 . or . i_imp > L ) then ierr = ERROR_OUT_OF_BOUNDS return end if ! Set impurity V ( i_imp ) = V_imp end subroutine potential_impurity_single","tags":"","url":"proc/potential_impurity_single.html"},{"title":"potential_impurity_multiple – LSDA-Hubbard-Fortran","text":"public  subroutine potential_impurity_multiple(V_imp_array, imp_positions, L, V, ierr) Multiple point impurities with individual amplitudes Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_imp_array (:) integer, intent(in) :: imp_positions (:) integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr Source Code subroutine potential_impurity_multiple ( V_imp_array , imp_positions , L , V , ierr ) real ( dp ), intent ( in ) :: V_imp_array (:) integer , intent ( in ) :: imp_positions (:), L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr integer :: k , N_imp , pos ! Initialize V = 0.0_dp ierr = ERROR_SUCCESS ! Check array sizes match N_imp = size ( imp_positions ) if ( size ( V_imp_array ) /= N_imp ) then ierr = ERROR_SIZE_MISMATCH return end if ! Add each impurity do k = 1 , N_imp pos = imp_positions ( k ) ! Bounds check if ( pos < 1 . or . pos > L ) then ierr = ERROR_OUT_OF_BOUNDS return end if ! Add impurity (use += to handle overlapping impurities) V ( pos ) = V ( pos ) + V_imp_array ( k ) end do end subroutine potential_impurity_multiple","tags":"","url":"proc/potential_impurity_multiple.html"},{"title":"potential_impurity_random – LSDA-Hubbard-Fortran","text":"public  subroutine potential_impurity_random(V_imp, concentration, L, seed, V, imp_positions, ierr) Random impurities with fixed concentration Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_imp real(kind=dp), intent(in) :: concentration integer, intent(in) :: L integer, intent(in) :: seed real(kind=dp), intent(out), dimension(L) :: V integer, intent(out), allocatable :: imp_positions (:) integer, intent(out) :: ierr Calls proc~~potential_impurity_random~~CallsGraph proc~potential_impurity_random potential_impurity_random proc~sort_array sort_array proc~potential_impurity_random->proc~sort_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine potential_impurity_random ( V_imp , concentration , L , seed , V , imp_positions , ierr ) real ( dp ), intent ( in ) :: V_imp , concentration integer , intent ( in ) :: L , seed real ( dp ), dimension ( L ), intent ( out ) :: V integer , allocatable , intent ( out ) :: imp_positions (:) integer , intent ( out ) :: ierr integer :: N_imp , k , pos , attempt integer , allocatable :: seed_array (:) integer :: seed_size logical :: position_taken ( L ) real ( dp ) :: rand_val V = 0.0_dp ierr = ERROR_SUCCESS position_taken = . false . if ( concentration <= 0.0_dp . or . concentration > 10 0.0_dp ) then ierr = ERROR_INVALID_CONCENTRATION return end if N_imp = nint ( concentration * real ( L , dp ) / 10 0.0_dp ) if ( N_imp == 0 ) N_imp = 1 if ( N_imp > L ) N_imp = L allocate ( imp_positions ( N_imp )) if ( seed >= 0 ) then call random_seed ( size = seed_size ) allocate ( seed_array ( seed_size )) seed_array = seed call random_seed ( put = seed_array ) deallocate ( seed_array ) else call random_seed () end if ! Place impurities randomly (without replacement) do k = 1 , N_imp attempt = 0 do call random_number ( rand_val ) pos = 1 + int ( rand_val * L ) ! Make sure position is valid and not already taken if ( pos >= 1 . and . pos <= L . and . . not . position_taken ( pos )) then position_taken ( pos ) = . true . imp_positions ( k ) = pos V ( pos ) = V_imp exit end if ! Safety check: avoid infinite loop attempt = attempt + 1 if ( attempt > 1000 * L ) then ierr = ERROR_OUT_OF_BOUNDS return end if end do end do call sort_array ( imp_positions ) end subroutine potential_impurity_random","tags":"","url":"proc/potential_impurity_random.html"},{"title":"sort_array – LSDA-Hubbard-Fortran","text":"private  subroutine sort_array(arr) Simple insertion sort for small arrays Arguments Type Intent Optional Attributes Name integer, intent(inout) :: arr (:) Called by proc~~sort_array~~CalledByGraph proc~sort_array sort_array proc~potential_impurity_random potential_impurity_random proc~potential_impurity_random->proc~sort_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_array ( arr ) integer , intent ( inout ) :: arr (:) integer :: i , j , temp , n n = size ( arr ) do i = 2 , n temp = arr ( i ) j = i - 1 do while ( j >= 1 ) if ( arr ( j ) <= temp ) exit arr ( j + 1 ) = arr ( j ) j = j - 1 end do arr ( j + 1 ) = temp end do end subroutine sort_array","tags":"","url":"proc/sort_array.html"},{"title":"compute_E0 – LSDA-Hubbard-Fortran","text":"public  function compute_E0(n_up, n_dw, L) result(E0) Compute non-interacting energy (U=0, free Fermi gas) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw integer, intent(in) :: L Return Value real(kind=dp) Called by proc~~compute_e0~~CalledByGraph proc~compute_e0 compute_E0 proc~compute_e_xc compute_E_xc proc~compute_e_xc->proc~compute_e0 proc~compute_v_xc_numerical compute_V_xc_numerical proc~compute_v_xc_numerical->proc~compute_e_xc proc~generate_xc_table generate_xc_table proc~generate_xc_table->proc~compute_e_xc proc~generate_xc_table->proc~compute_v_xc_numerical proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function compute_E0 ( n_up , n_dw , L ) result ( E0 ) real ( dp ), intent ( in ) :: n_up , n_dw integer , intent ( in ) :: L real ( dp ) :: E0 , I_j , k_j integer :: Nup , Ndw , j Nup = NINT ( n_up * real ( L , dp )) Ndw = NINT ( n_dw * real ( L , dp )) E0 = 0.0_dp do j = 1 , Nup I_j = real ( j , dp ) - 0.5_dp * real ( Nup + 1 , dp ) k_j = TWOPI * I_j / real ( L , dp ) E0 = E0 - 2.0_dp * cos ( k_j ) end do do j = 1 , Ndw I_j = real ( j , dp ) - 0.5_dp * real ( Ndw + 1 , dp ) k_j = TWOPI * I_j / real ( L , dp ) E0 = E0 - 2.0_dp * cos ( k_j ) end do end function compute_E0","tags":"","url":"proc/compute_e0.html"},{"title":"compute_E_xc – LSDA-Hubbard-Fortran","text":"public  function compute_E_xc(n_up, n_dn, U, L) result(E_xc) Compute exchange-correlation energy: E_xc = E_BA - E_0 Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dn real(kind=dp), intent(in) :: U integer, intent(in) :: L Return Value real(kind=dp) Calls proc~~compute_e_xc~~CallsGraph proc~compute_e_xc compute_E_xc proc~compute_e0 compute_E0 proc~compute_e_xc->proc~compute_e0 proc~compute_energy compute_energy proc~compute_e_xc->proc~compute_energy proc~compute_residual compute_residual proc~compute_e_xc->proc~compute_residual proc~initialize_quantum_numbers initialize_quantum_numbers proc~compute_e_xc->proc~initialize_quantum_numbers proc~solve_newton solve_newton proc~compute_e_xc->proc~solve_newton proc~theta theta proc~compute_residual->proc~theta proc~theta_capital Theta_capital proc~compute_residual->proc~theta_capital proc~solve_newton->proc~compute_residual proc~compute_jacobian compute_jacobian proc~solve_newton->proc~compute_jacobian proc~line_search line_search proc~solve_newton->proc~line_search proc~solve_linear_system solve_linear_system proc~solve_newton->proc~solve_linear_system proc~line_search->proc~compute_residual interface~dgesv DGESV proc~solve_linear_system->interface~dgesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_e_xc~~CalledByGraph proc~compute_e_xc compute_E_xc proc~compute_v_xc_numerical compute_V_xc_numerical proc~compute_v_xc_numerical->proc~compute_e_xc proc~generate_xc_table generate_xc_table proc~generate_xc_table->proc~compute_e_xc proc~generate_xc_table->proc~compute_v_xc_numerical proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function compute_E_xc ( n_up , n_dn , U , L ) result ( E_xc ) real ( dp ), intent ( in ) :: n_up , n_dn , U integer , intent ( in ) :: L real ( dp ) :: E_xc integer :: Nup , Ndn , M real ( dp ) :: E0 , E_BA real ( dp ), allocatable :: x (:), k (:), F (:) real ( dp ), allocatable :: quantum_I (:), quantum_J (:) logical :: converged if ( abs ( U ) < U_SMALL ) then E_xc = 0.0_dp return end if Nup = nint ( n_up * real ( L , dp )) Ndn = nint ( n_dn * real ( L , dp )) M = Ndn allocate ( x ( Nup + M )) ! Combined array for solver (k + Lambda) allocate ( k ( Nup )) allocate ( F ( Nup + M )) allocate ( quantum_I ( Nup ), quantum_J ( M )) call initialize_quantum_numbers ( Nup , M , quantum_I , quantum_J ) x ( 1 : Nup ) = TWOPI * quantum_I / real ( L , dp ) if ( M > 0 ) then x ( Nup + 1 : Nup + M ) = 0.0_dp end if call solve_newton ( x , quantum_I , quantum_J , L , U , converged ) if (. not . converged ) then F = compute_residual ( x ( 1 : Nup ), x ( Nup + 1 : Nup + M ), quantum_I , quantum_J , L , U ) if ( norm2 ( F ) > 1.0e-8_dp ) then E_xc = ieee_value ( E_xc , ieee_quiet_nan ) deallocate ( x , k , quantum_I , quantum_J , F ) return end if deallocate ( F ) end if k = x ( 1 : Nup ) E_BA = compute_energy ( k ) E0 = compute_E0 ( n_up , n_dn , L ) E_xc = ( E_BA - E0 ) / real ( L , dp ) deallocate ( x , k , quantum_I , quantum_J ) end function compute_E_xc","tags":"","url":"proc/compute_e_xc.html"},{"title":"compute_V_xc_numerical – LSDA-Hubbard-Fortran","text":"public  function compute_V_xc_numerical(n_up, n_dw, U, L) result(v_xc) Compute XC potentials via numerical derivatives (central finite differences) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw real(kind=dp), intent(in) :: U integer, intent(in) :: L Return Value type( xc_potentials_t ) Calls proc~~compute_v_xc_numerical~~CallsGraph proc~compute_v_xc_numerical compute_V_xc_numerical proc~compute_e_xc compute_E_xc proc~compute_v_xc_numerical->proc~compute_e_xc proc~compute_e0 compute_E0 proc~compute_e_xc->proc~compute_e0 proc~compute_energy compute_energy proc~compute_e_xc->proc~compute_energy proc~compute_residual compute_residual proc~compute_e_xc->proc~compute_residual proc~initialize_quantum_numbers initialize_quantum_numbers proc~compute_e_xc->proc~initialize_quantum_numbers proc~solve_newton solve_newton proc~compute_e_xc->proc~solve_newton proc~theta theta proc~compute_residual->proc~theta proc~theta_capital Theta_capital proc~compute_residual->proc~theta_capital proc~solve_newton->proc~compute_residual proc~compute_jacobian compute_jacobian proc~solve_newton->proc~compute_jacobian proc~line_search line_search proc~solve_newton->proc~line_search proc~solve_linear_system solve_linear_system proc~solve_newton->proc~solve_linear_system proc~line_search->proc~compute_residual interface~dgesv DGESV proc~solve_linear_system->interface~dgesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_v_xc_numerical~~CalledByGraph proc~compute_v_xc_numerical compute_V_xc_numerical proc~generate_xc_table generate_xc_table proc~generate_xc_table->proc~compute_v_xc_numerical proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function compute_V_xc_numerical ( n_up , n_dw , U , L ) result ( v_xc ) real ( dp ), intent ( in ) :: n_up , n_dw integer , intent ( in ) :: L real ( dp ), intent ( in ) :: U type ( xc_potentials_t ) :: v_xc real ( dp ) :: delta_n real ( dp ) :: E_xc_up_plus , E_xc_up_minus real ( dp ) :: E_xc_dw_plus , E_xc_dw_minus delta_n = 1.0e-4_dp ! Derivative with respect to n_up E_xc_up_plus = compute_E_xc ( n_up + delta_n , n_dw , U , L ) E_xc_up_minus = compute_E_xc ( n_up - delta_n , n_dw , U , L ) if ( ieee_is_nan ( E_xc_up_plus ) . or . ieee_is_nan ( E_xc_up_minus )) then v_xc % v_xc_up = ieee_value ( 0.0_dp , ieee_quiet_nan ) else v_xc % v_xc_up = ( E_xc_up_plus - E_xc_up_minus ) / ( 2.0_dp * delta_n ) end if ! Derivative with respect to n_dw E_xc_dw_plus = compute_E_xc ( n_up , n_dw + delta_n , U , L ) E_xc_dw_minus = compute_E_xc ( n_up , n_dw - delta_n , U , L ) if ( ieee_is_nan ( E_xc_dw_plus ) . or . ieee_is_nan ( E_xc_dw_minus )) then v_xc % v_xc_down = ieee_value ( 0.0_dp , ieee_quiet_nan ) else v_xc % v_xc_down = ( E_xc_dw_plus - E_xc_dw_minus ) / ( 2.0_dp * delta_n ) end if end function compute_V_xc_numerical","tags":"","url":"proc/compute_v_xc_numerical.html"},{"title":"generate_xc_table – LSDA-Hubbard-Fortran","text":"public  subroutine generate_xc_table(U, params, table, status) Generate complete XC table for a single U value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: U type( grid_params_t ), intent(in) :: params type( xc_table_t ), intent(out) :: table integer, intent(out) :: status Calls proc~~generate_xc_table~~CallsGraph proc~generate_xc_table generate_xc_table proc~compute_e_xc compute_E_xc proc~generate_xc_table->proc~compute_e_xc proc~compute_v_xc_numerical compute_V_xc_numerical proc~generate_xc_table->proc~compute_v_xc_numerical proc~compute_e0 compute_E0 proc~compute_e_xc->proc~compute_e0 proc~compute_energy compute_energy proc~compute_e_xc->proc~compute_energy proc~compute_residual compute_residual proc~compute_e_xc->proc~compute_residual proc~initialize_quantum_numbers initialize_quantum_numbers proc~compute_e_xc->proc~initialize_quantum_numbers proc~solve_newton solve_newton proc~compute_e_xc->proc~solve_newton proc~compute_v_xc_numerical->proc~compute_e_xc proc~theta theta proc~compute_residual->proc~theta proc~theta_capital Theta_capital proc~compute_residual->proc~theta_capital proc~solve_newton->proc~compute_residual proc~compute_jacobian compute_jacobian proc~solve_newton->proc~compute_jacobian proc~line_search line_search proc~solve_newton->proc~line_search proc~solve_linear_system solve_linear_system proc~solve_newton->proc~solve_linear_system proc~line_search->proc~compute_residual interface~dgesv DGESV proc~solve_linear_system->interface~dgesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~generate_xc_table~~CalledByGraph proc~generate_xc_table generate_xc_table proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~generate_xc_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine generate_xc_table ( U , params , table , status ) real ( dp ), intent ( in ) :: U type ( grid_params_t ), intent ( in ) :: params type ( xc_table_t ), intent ( out ) :: table integer , intent ( out ) :: status integer :: i , j real ( dp ) :: n , m , n_up , n_dw , delta_n , delta_m type ( xc_potentials_t ) :: v_xc integer :: actual_m_points status = 0 table % U = U table % n_points_n = params % n_points table % n_points_m = params % m_points allocate ( table % n_grid ( params % n_points )) allocate ( table % m_grid ( params % m_points , params % n_points )) allocate ( table % exc ( params % m_points , params % n_points )) allocate ( table % vxc_up ( params % m_points , params % n_points )) allocate ( table % vxc_down ( params % m_points , params % n_points )) ! Initialize with NaN (for debugging) table % exc = ieee_value ( 0.0_dp , ieee_quiet_nan ) table % vxc_up = ieee_value ( 0.0_dp , ieee_quiet_nan ) table % vxc_down = ieee_value ( 0.0_dp , ieee_quiet_nan ) delta_n = ( params % n_max - params % n_min ) / real ( params % n_points - 1 , dp ) !$OMP PARALLEL DO PRIVATE(i, j, n, m, n_up, n_dw, delta_m, v_xc, actual_m_points) & !$OMP SHARED(table, params, U, delta_n) SCHEDULE(dynamic) do i = 1 , params % n_points n = params % n_min + real ( i - 1 , dp ) * delta_n table % n_grid ( i ) = n actual_m_points = params % m_points if ( actual_m_points > 1 ) then delta_m = ( 2.0_dp * n ) / real ( actual_m_points - 1 , dp ) else delta_m = 0.0_dp end if do j = 1 , actual_m_points m = - n + real ( j - 1 , dp ) * delta_m table % m_grid ( j , i ) = m n_up = 0.5_dp * ( n + m ) n_dw = 0.5_dp * ( n - m ) if ( n_up < 0.0_dp . or . n_up > 1.0_dp . or . & n_dw < 0.0_dp . or . n_dw > 1.0_dp ) then cycle end if table % exc ( j , i ) = compute_E_xc ( n_up , n_dw , U , params % L ) v_xc = compute_V_xc_numerical ( n_up , n_dw , U , params % L ) table % vxc_up ( j , i ) = v_xc % v_xc_up table % vxc_down ( j , i ) = v_xc % v_xc_down end do end do !$OMP END PARALLEL DO end subroutine generate_xc_table","tags":"","url":"proc/generate_xc_table.html"},{"title":"generate_table_grid – LSDA-Hubbard-Fortran","text":"public  subroutine generate_table_grid(U_values, params, output_dir, status) Generate multiple XC tables using continuation method in U Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: U_values (:) type( grid_params_t ), intent(in) :: params character(len=*), intent(in) :: output_dir integer, intent(out) :: status Calls proc~~generate_table_grid~~CallsGraph proc~generate_table_grid generate_table_grid proc~generate_xc_table generate_xc_table proc~generate_table_grid->proc~generate_xc_table proc~write_fortran_table write_fortran_table proc~generate_table_grid->proc~write_fortran_table proc~compute_e_xc compute_E_xc proc~generate_xc_table->proc~compute_e_xc proc~compute_v_xc_numerical compute_V_xc_numerical proc~generate_xc_table->proc~compute_v_xc_numerical proc~compute_e0 compute_E0 proc~compute_e_xc->proc~compute_e0 proc~compute_energy compute_energy proc~compute_e_xc->proc~compute_energy proc~compute_residual compute_residual proc~compute_e_xc->proc~compute_residual proc~initialize_quantum_numbers initialize_quantum_numbers proc~compute_e_xc->proc~initialize_quantum_numbers proc~solve_newton solve_newton proc~compute_e_xc->proc~solve_newton proc~compute_v_xc_numerical->proc~compute_e_xc proc~theta theta proc~compute_residual->proc~theta proc~theta_capital Theta_capital proc~compute_residual->proc~theta_capital proc~solve_newton->proc~compute_residual proc~compute_jacobian compute_jacobian proc~solve_newton->proc~compute_jacobian proc~line_search line_search proc~solve_newton->proc~line_search proc~solve_linear_system solve_linear_system proc~solve_newton->proc~solve_linear_system proc~line_search->proc~compute_residual interface~dgesv DGESV proc~solve_linear_system->interface~dgesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine generate_table_grid ( U_values , params , output_dir , status ) real ( dp ), intent ( in ) :: U_values (:) type ( grid_params_t ), intent ( in ) :: params character ( len =* ), intent ( in ) :: output_dir integer , intent ( out ) :: status integer :: k , n_U , io_stat real ( dp ) :: U_current type ( xc_table_t ) :: table character ( len = 256 ) :: filename character ( len = 32 ) :: U_str status = 0 n_U = size ( U_values ) print '(A)' , \"=========================================\" print '(A)' , \"  XC Table Grid Generation\" print '(A)' , \"=========================================\" print '(A,I0,A)' , \"Generating \" , n_U , \" tables with continuation method\" print '(A,F6.2,A,F6.2)' , \"U range: \" , U_values ( 1 ), \" to \" , U_values ( n_U ) print '(A,I0,A,I0)' , \"Grid size: \" , params % n_points , \" x \" , params % m_points print '(A)' , \"\" do k = 1 , n_U U_current = U_values ( k ) print '(A,I0,A,I0,A,F6.2)' , \"Processing U(\" , k , \"/\" , n_U , \") = \" , U_current call generate_xc_table ( U_current , params , table , status ) if ( status /= 0 ) then print '(A,F6.2)' , \"  ERROR: Failed to generate table for U = \" , U_current return end if write ( U_str , '(F6.2)' ) U_current U_str = adjustl ( U_str ) filename = trim ( output_dir ) // \"/lsda_hub_u\" // trim ( U_str ) // \".dat\" call write_fortran_table ( filename , table , io_stat ) if ( io_stat /= 0 ) then print '(A)' , \"  ERROR: Failed to write table file\" status = - 1 return end if print '(A,A)' , \"  Saved: \" , trim ( filename ) ! Deallocate table arrays for next iteration if ( allocated ( table % n_grid )) deallocate ( table % n_grid ) if ( allocated ( table % m_grid )) deallocate ( table % m_grid ) if ( allocated ( table % exc )) deallocate ( table % exc ) if ( allocated ( table % vxc_up )) deallocate ( table % vxc_up ) if ( allocated ( table % vxc_down )) deallocate ( table % vxc_down ) end do print '(A)' , \"\" print '(A)' , \"=========================================\" print '(A,I0,A)' , \"Successfully generated \" , n_U , \" XC tables!\" print '(A)' , \"=========================================\" end subroutine generate_table_grid","tags":"","url":"proc/generate_table_grid.html"},{"title":"potential_barrier_single – LSDA-Hubbard-Fortran","text":"public  subroutine potential_barrier_single(V_bar, i_start, i_end, L, V, ierr) Single rectangular barrier: V(i) = V_bar for i_start ≤ i ≤ i_end, else 0 Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_bar integer, intent(in) :: i_start integer, intent(in) :: i_end integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr Called by proc~~potential_barrier_single~~CalledByGraph proc~potential_barrier_single potential_barrier_single proc~create_potential create_potential proc~create_potential->proc~potential_barrier_single Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine potential_barrier_single ( V_bar , i_start , i_end , L , V , ierr ) real ( dp ), intent ( in ) :: V_bar integer , intent ( in ) :: i_start , i_end , L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr V = 0.0_dp ierr = ERROR_SUCCESS if ( i_start < 1 . or . i_start > L ) then ierr = ERROR_OUT_OF_BOUNDS return end if if ( i_end < 1 . or . i_end > L ) then ierr = ERROR_OUT_OF_BOUNDS return end if if ( i_end < i_start ) then ierr = ERROR_OUT_OF_BOUNDS return end if V ( i_start : i_end ) = V_bar end subroutine potential_barrier_single","tags":"","url":"proc/potential_barrier_single.html"},{"title":"potential_barrier_double – LSDA-Hubbard-Fortran","text":"public  subroutine potential_barrier_double(V_bar, L_bar, V_well, L_well, L, V, ierr) Double rectangular barrier: Two barriers creating a quantum well Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_bar real(kind=dp), intent(in) :: L_bar real(kind=dp), intent(in) :: V_well real(kind=dp), intent(in) :: L_well integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr Called by proc~~potential_barrier_double~~CalledByGraph proc~potential_barrier_double potential_barrier_double proc~create_potential create_potential proc~create_potential->proc~potential_barrier_double Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine potential_barrier_double ( V_bar , L_bar , V_well , L_well , L , V , ierr ) real ( dp ), intent ( in ) :: V_bar , L_bar , V_well , L_well integer , intent ( in ) :: L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr real ( dp ) :: x0 , x1 , x2 , x_1 , x_2 integer :: i real ( dp ), parameter :: SMALL = 1.0e-10_dp ierr = ERROR_SUCCESS V = 0.0_dp ! Calculate center position (matches C++ logic) ! C++: x0 = (Na%2 ? (double(Na/2)) + 1.0 : (double(Na/2)) + 0.5) if ( mod ( L , 2 ) == 1 ) then ! Odd L: center at (L/2) + 1 = (L+1)/2 x0 = real ( L / 2 , dp ) + 1.0_dp else ! Even L: center at (L/2) + 0.5 x0 = real ( L / 2 , dp ) + 0.5_dp end if ! Calculate region boundaries (matches C++ lines 171-175) x1 = x0 + L_well / 2.0_dp ! Right edge of well x2 = x1 + L_bar ! Right edge of right barrier x_1 = x0 - L_well / 2.0_dp ! Left edge of well x_2 = x_1 - L_bar ! Left edge of left barrier ! Apply potential to each site (matches C++ lines 179-191) do i = 1 , L if ( x_2 - SMALL < real ( i , dp ) . and . real ( i , dp ) < x_1 + SMALL ) then ! Left barrier region V ( i ) = V_bar else if ( x1 - SMALL < real ( i , dp ) . and . real ( i , dp ) < x2 + SMALL ) then ! Right barrier region V ( i ) = V_bar else if ( x_1 + SMALL <= real ( i , dp ) . and . real ( i , dp ) <= x1 - SMALL ) then ! Well region (between barriers) V ( i ) = V_well else ! Outside regions V ( i ) = 0.0_dp end if end do end subroutine potential_barrier_double","tags":"","url":"proc/potential_barrier_double.html"},{"title":"validate_diagonalization_inputs – LSDA-Hubbard-Fortran","text":"public  subroutine validate_diagonalization_inputs(L, H, eigvals, eigvecs, compute_vectors, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: L real(kind=dp), intent(in) :: H (:,:) real(kind=dp), intent(in) :: eigvals (:) real(kind=dp), intent(in), optional :: eigvecs (:,:) logical, intent(in) :: compute_vectors integer, intent(out) :: ierr Called by proc~~validate_diagonalization_inputs~~CalledByGraph proc~validate_diagonalization_inputs validate_diagonalization_inputs proc~diagonalize_symmetric_real diagonalize_symmetric_real proc~diagonalize_symmetric_real->proc~validate_diagonalization_inputs proc~diagonalize_symmetric_real_values_only diagonalize_symmetric_real_values_only proc~diagonalize_symmetric_real_values_only->proc~validate_diagonalization_inputs proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~diagonalize_symmetric_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine validate_diagonalization_inputs ( L , H , eigvals , eigvecs , compute_vectors , ierr ) integer , intent ( in ) :: L real ( dp ), intent ( in ) :: H (:,:), eigvals (:) real ( dp ), intent ( in ), optional :: eigvecs (:,:) logical , intent ( in ) :: compute_vectors integer , intent ( out ) :: ierr ierr = 0 if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( eigvals ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( compute_vectors ) then if (. not . present ( eigvecs )) then ierr = ERROR_INVALID_INPUT return end if if ( size ( eigvecs , 1 ) /= L . or . size ( eigvecs , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if end if end subroutine validate_diagonalization_inputs","tags":"","url":"proc/validate_diagonalization_inputs.html"},{"title":"diagonalize_symmetric_real – LSDA-Hubbard-Fortran","text":"public  subroutine diagonalize_symmetric_real(H, L, eigvals, eigvecs, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: H (:,:) integer, intent(in) :: L real(kind=dp), intent(out) :: eigvals (:) real(kind=dp), intent(out) :: eigvecs (:,:) integer, intent(out) :: ierr Calls proc~~diagonalize_symmetric_real~~CallsGraph proc~diagonalize_symmetric_real diagonalize_symmetric_real interface~dsyevd DSYEVD proc~diagonalize_symmetric_real->interface~dsyevd proc~validate_diagonalization_inputs validate_diagonalization_inputs proc~diagonalize_symmetric_real->proc~validate_diagonalization_inputs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~diagonalize_symmetric_real~~CalledByGraph proc~diagonalize_symmetric_real diagonalize_symmetric_real proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~diagonalize_symmetric_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine diagonalize_symmetric_real ( H , L , eigvals , eigvecs , ierr ) real ( dp ), intent ( in ) :: H (:,:) integer , intent ( in ) :: L real ( dp ), intent ( out ) :: eigvals (:) real ( dp ), intent ( out ) :: eigvecs (:,:) integer , intent ( out ) :: ierr real ( dp ), allocatable :: H_work (:,:) real ( dp ), allocatable :: work (:) integer , allocatable :: iwork (:) integer :: lwork , liwork , info call validate_diagonalization_inputs ( L , H , eigvals , eigvecs , . true ., ierr ) if ( ierr /= ERROR_SUCCESS ) return allocate ( H_work ( L , L )) H_work = H lwork = - 1 liwork = - 1 allocate ( work ( 1 ), iwork ( 1 )) call DSYEVD ( 'V' , 'U' , L , H_work , L , eigvals , work , & lwork , iwork , liwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_INVALID_ARG deallocate ( H_work , work , iwork ) return end if lwork = int ( work ( 1 )) liwork = iwork ( 1 ) deallocate ( work , iwork ) allocate ( work ( lwork ), iwork ( liwork )) ! Actual diagonalization call DSYEVD ( 'V' , 'U' , L , H_work , L , eigvals , work , & lwork , iwork , liwork , info ) if ( info < 0 ) then ierr = ERROR_LAPACK_INVALID_ARG else if ( info > 0 ) then ierr = ERROR_CONVERGENCE_FAILED else ierr = ERROR_SUCCESS eigvecs = H_work end if deallocate ( H_work , work , iwork ) end subroutine diagonalize_symmetric_real","tags":"","url":"proc/diagonalize_symmetric_real.html"},{"title":"diagonalize_symmetric_real_values_only – LSDA-Hubbard-Fortran","text":"public  subroutine diagonalize_symmetric_real_values_only(H, L, eigvals, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: H (:,:) integer, intent(in) :: L real(kind=dp), intent(out) :: eigvals (:) integer, intent(out) :: ierr Calls proc~~diagonalize_symmetric_real_values_only~~CallsGraph proc~diagonalize_symmetric_real_values_only diagonalize_symmetric_real_values_only interface~dsyevd DSYEVD proc~diagonalize_symmetric_real_values_only->interface~dsyevd proc~validate_diagonalization_inputs validate_diagonalization_inputs proc~diagonalize_symmetric_real_values_only->proc~validate_diagonalization_inputs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine diagonalize_symmetric_real_values_only ( H , L , eigvals , ierr ) real ( dp ), intent ( in ) :: H (:,:) integer , intent ( in ) :: L real ( dp ), intent ( out ) :: eigvals (:) integer , intent ( out ) :: ierr real ( dp ), allocatable :: H_work (:,:) real ( dp ), allocatable :: work (:) integer , allocatable :: iwork (:) integer :: lwork , liwork , info call validate_diagonalization_inputs ( L , H , eigvals , compute_vectors = . false ., ierr = ierr ) if ( ierr /= ERROR_SUCCESS ) return allocate ( H_work ( L , L )) H_work = H lwork = - 1 liwork = - 1 allocate ( work ( 1 ), iwork ( 1 )) call DSYEVD ( 'N' , 'U' , L , H_work , L , eigvals , work , & lwork , iwork , liwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_INVALID_ARG deallocate ( H_work , work , iwork ) return end if lwork = int ( work ( 1 )) liwork = iwork ( 1 ) deallocate ( work , iwork ) allocate ( work ( lwork ), iwork ( liwork )) ! Actual diagonalization call DSYEVD ( 'N' , 'U' , L , H_work , L , eigvals , work , & lwork , iwork , liwork , info ) if ( info < 0 ) then ierr = ERROR_LAPACK_INVALID_ARG else if ( info > 0 ) then ierr = ERROR_CONVERGENCE_FAILED else ierr = ERROR_SUCCESS end if deallocate ( H_work , work , iwork ) end subroutine diagonalize_symmetric_real_values_only","tags":"","url":"proc/diagonalize_symmetric_real_values_only.html"},{"title":"diagonalize_hermitian_complex – LSDA-Hubbard-Fortran","text":"public  subroutine diagonalize_hermitian_complex(H, L, eigvals, eigvecs, ierr) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: H (:,:) integer, intent(in) :: L real(kind=dp), intent(out) :: eigvals (:) complex(kind=dp), intent(out) :: eigvecs (:,:) integer, intent(out) :: ierr Calls proc~~diagonalize_hermitian_complex~~CallsGraph proc~diagonalize_hermitian_complex diagonalize_hermitian_complex interface~zheevd ZHEEVD proc~diagonalize_hermitian_complex->interface~zheevd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~diagonalize_hermitian_complex~~CalledByGraph proc~diagonalize_hermitian_complex diagonalize_hermitian_complex proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~diagonalize_hermitian_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine diagonalize_hermitian_complex ( H , L , eigvals , eigvecs , ierr ) complex ( dp ), intent ( in ) :: H (:,:) integer , intent ( in ) :: L real ( dp ), intent ( out ) :: eigvals (:) complex ( dp ), intent ( out ) :: eigvecs (:,:) integer , intent ( out ) :: ierr complex ( dp ), allocatable :: H_work (:,:) complex ( dp ), allocatable :: work (:) real ( dp ), allocatable :: rwork (:) integer , allocatable :: iwork (:) integer :: lwork , lrwork , liwork , info ! Validate inputs ierr = ERROR_SUCCESS if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( eigvals ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( eigvecs , 1 ) /= L . or . size ( eigvecs , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if allocate ( H_work ( L , L )) H_work = H lwork = - 1 lrwork = - 1 liwork = - 1 allocate ( work ( 1 ), rwork ( 1 ), iwork ( 1 )) call ZHEEVD ( 'V' , 'U' , L , H_work , L , eigvals , work , & lwork , rwork , lrwork , iwork , liwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_INVALID_ARG deallocate ( H_work , work , rwork , iwork ) return end if lwork = int ( real ( work ( 1 ), kind = dp )) lrwork = int ( rwork ( 1 )) liwork = iwork ( 1 ) deallocate ( work , rwork , iwork ) allocate ( work ( lwork ), iwork ( liwork ), rwork ( lrwork )) ! Actual diagonalization call ZHEEVD ( 'V' , 'U' , L , H_work , L , eigvals , work , & lwork , rwork , lrwork , iwork , liwork , info ) if ( info < 0 ) then ierr = ERROR_LAPACK_INVALID_ARG else if ( info > 0 ) then ierr = ERROR_CONVERGENCE_FAILED else ierr = ERROR_SUCCESS eigvecs = H_work end if deallocate ( H_work , work , rwork , iwork ) end subroutine diagonalize_hermitian_complex","tags":"","url":"proc/diagonalize_hermitian_complex.html"},{"title":"diagonalize_hermitian_complex_values_only – LSDA-Hubbard-Fortran","text":"public  subroutine diagonalize_hermitian_complex_values_only(H, L, eigvals, ierr) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: H (:,:) integer, intent(in) :: L real(kind=dp), intent(out) :: eigvals (:) integer, intent(out) :: ierr Calls proc~~diagonalize_hermitian_complex_values_only~~CallsGraph proc~diagonalize_hermitian_complex_values_only diagonalize_hermitian_complex_values_only interface~zheevd ZHEEVD proc~diagonalize_hermitian_complex_values_only->interface~zheevd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine diagonalize_hermitian_complex_values_only ( H , L , eigvals , ierr ) complex ( dp ), intent ( in ) :: H (:,:) integer , intent ( in ) :: L real ( dp ), intent ( out ) :: eigvals (:) integer , intent ( out ) :: ierr complex ( dp ), allocatable :: H_work (:,:) complex ( dp ), allocatable :: work (:) real ( dp ), allocatable :: rwork (:) integer , allocatable :: iwork (:) integer :: lwork , lrwork , liwork , info ! Validate inputs ierr = ERROR_SUCCESS if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( eigvals ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if allocate ( H_work ( L , L )) H_work = H lwork = - 1 lrwork = - 1 liwork = - 1 allocate ( work ( 1 ), rwork ( 1 ), iwork ( 1 )) call ZHEEVD ( 'N' , 'U' , L , H_work , L , eigvals , work , & lwork , rwork , lrwork , iwork , liwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_INVALID_ARG deallocate ( H_work , work , rwork , iwork ) return end if lwork = int ( real ( work ( 1 ), kind = dp )) lrwork = int ( rwork ( 1 )) liwork = iwork ( 1 ) deallocate ( work , rwork , iwork ) allocate ( work ( lwork ), iwork ( liwork ), rwork ( lrwork )) ! Actual diagonalization call ZHEEVD ( 'N' , 'U' , L , H_work , L , eigvals , work , & lwork , rwork , lrwork , iwork , liwork , info ) if ( info < 0 ) then ierr = ERROR_LAPACK_INVALID_ARG else if ( info > 0 ) then ierr = ERROR_CONVERGENCE_FAILED else ierr = ERROR_SUCCESS end if deallocate ( H_work , work , rwork , iwork ) end subroutine diagonalize_hermitian_complex_values_only","tags":"","url":"proc/diagonalize_hermitian_complex_values_only.html"},{"title":"DSYEVD – LSDA-Hubbard-Fortran","text":"interface Called by interface~~dsyevd~~CalledByGraph interface~dsyevd DSYEVD proc~diagonalize_symmetric_real diagonalize_symmetric_real proc~diagonalize_symmetric_real->interface~dsyevd proc~diagonalize_symmetric_real_values_only diagonalize_symmetric_real_values_only proc~diagonalize_symmetric_real_values_only->interface~dsyevd proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~diagonalize_symmetric_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private  subroutine DSYEVD(jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=dp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=dp), intent(out) :: w (*) real(kind=dp), intent(out) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: iwork (*) integer, intent(in) :: liwork integer, intent(out) :: info","tags":"","url":"interface/dsyevd.html"},{"title":"ZHEEVD – LSDA-Hubbard-Fortran","text":"interface Called by interface~~zheevd~~CalledByGraph interface~zheevd ZHEEVD proc~diagonalize_hermitian_complex diagonalize_hermitian_complex proc~diagonalize_hermitian_complex->interface~zheevd proc~diagonalize_hermitian_complex_values_only diagonalize_hermitian_complex_values_only proc~diagonalize_hermitian_complex_values_only->interface~zheevd proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~diagonalize_hermitian_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private  subroutine ZHEEVD(jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=dp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=dp), intent(out) :: w (*) complex(kind=dp), intent(out) :: work (*) integer, intent(in) :: lwork real(kind=dp), intent(out) :: rwork (*) integer, intent(in) :: lrwork integer, intent(out) :: iwork (*) integer, intent(in) :: liwork integer, intent(out) :: info","tags":"","url":"interface/zheevd.html"},{"title":"read_cpp_table – LSDA-Hubbard-Fortran","text":"public  subroutine read_cpp_table(filename, table, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( xc_table_t ), intent(out) :: table integer, intent(out) :: ierr Calls proc~~read_cpp_table~~CallsGraph proc~read_cpp_table read_cpp_table proc~count_blocks_and_points count_blocks_and_points proc~read_cpp_table->proc~count_blocks_and_points proc~extract_u_from_filename extract_U_from_filename proc~read_cpp_table->proc~extract_u_from_filename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_cpp_table ( filename , table , ierr ) character ( len =* ), intent ( in ) :: filename type ( xc_table_t ), intent ( out ) :: table integer , intent ( out ) :: ierr integer :: unit , io_stat character ( len = MAX_LINE_LEN ) :: line integer :: n_blocks , n_mag_points integer :: i_block , i_mag real ( dp ) :: n_val , m_val , exc_val , vxc_up_val , vxc_down_val call extract_U_from_filename ( filename , table % U , ierr ) if ( ierr /= ERROR_SUCCESS ) return call count_blocks_and_points ( filename , n_blocks , n_mag_points , ierr ) if ( ierr /= ERROR_SUCCESS ) return table % n_points_n = n_blocks table % n_points_m = n_mag_points allocate ( table % n_grid ( n_blocks )) allocate ( table % m_grid ( n_mag_points , n_blocks )) allocate ( table % exc ( n_mag_points , n_blocks )) allocate ( table % vxc_up ( n_mag_points , n_blocks )) allocate ( table % vxc_down ( n_mag_points , n_blocks )) open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then ierr = ERROR_FILE_NOT_FOUND return end if i_block = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then ierr = ERROR_FILE_READ close ( unit ) exit end if if ( line ( 1 : 2 ) == 'n:' ) then i_block = i_block + 1 read ( line ( 3 :), * , iostat = io_stat ) n_val if ( io_stat /= 0 ) then ierr = ERROR_FILE_READ close ( unit ) return end if table % n_grid ( i_block ) = n_val read ( unit , '(A)' , iostat = io_stat ) line ! Skip header if ( io_stat /= 0 ) then ierr = ERROR_FILE_READ close ( unit ) return end if do i_mag = 1 , n_mag_points read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 . or . line ( 1 : 2 ) == 'n:' ) then if ( i_mag > 1 ) then table % m_grid ( i_mag : n_mag_points , i_block ) = & table % m_grid ( i_mag - 1 , i_block ) table % exc ( i_mag : n_mag_points , i_block ) = & table % exc ( i_mag - 1 , i_block ) table % vxc_up ( i_mag : n_mag_points , i_block ) = & table % vxc_up ( i_mag - 1 , i_block ) table % vxc_down ( i_mag : n_mag_points , i_block ) = & table % vxc_down ( i_mag - 1 , i_block ) end if if ( line ( 1 : 2 ) == 'n:' ) backspace ( unit ) exit end if read ( line , * , iostat = io_stat ) m_val , exc_val , vxc_up_val , vxc_down_val if ( io_stat /= 0 ) then ierr = ERROR_FILE_READ close ( unit ) return end if table % m_grid ( i_mag , i_block ) = m_val table % exc ( i_mag , i_block ) = exc_val table % vxc_up ( i_mag , i_block ) = vxc_up_val table % vxc_down ( i_mag , i_block ) = vxc_down_val end do end if end do close ( unit ) ierr = ERROR_SUCCESS end subroutine read_cpp_table","tags":"","url":"proc/read_cpp_table.html"},{"title":"count_blocks_and_points – LSDA-Hubbard-Fortran","text":"private  subroutine count_blocks_and_points(filename, n_blocks, n_mag_points, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(out) :: n_blocks integer, intent(out) :: n_mag_points integer, intent(out) :: ierr Called by proc~~count_blocks_and_points~~CalledByGraph proc~count_blocks_and_points count_blocks_and_points proc~read_cpp_table read_cpp_table proc~read_cpp_table->proc~count_blocks_and_points Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine count_blocks_and_points ( filename , n_blocks , n_mag_points , ierr ) character ( len =* ), intent ( in ) :: filename integer , intent ( out ) :: n_blocks , n_mag_points , ierr integer :: unit , io_stat character ( len = MAX_LINE_LEN ) :: line integer :: points_in_block , max_points logical :: in_data_section open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then ierr = ERROR_FILE_NOT_FOUND return end if n_blocks = 0 max_points = 0 points_in_block = 0 in_data_section = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then ierr = ERROR_FILE_READ close ( unit ) exit end if if ( line ( 1 : 2 ) == 'n:' ) then if ( n_blocks > 0 ) then max_points = max ( max_points , points_in_block ) end if n_blocks = n_blocks + 1 points_in_block = 0 in_data_section = . false . else if ( line ( 1 : 4 ) == '#mag' ) then in_data_section = . true . else if ( in_data_section . and . len_trim ( line ) > 0 ) then points_in_block = points_in_block + 1 end if end do if ( points_in_block > 0 ) then max_points = max ( max_points , points_in_block ) end if n_mag_points = max_points close ( unit ) if ( n_blocks == 0 . or . n_mag_points == 0 ) then ierr = ERROR_INVALID_INPUT return end if ierr = ERROR_SUCCESS end subroutine count_blocks_and_points","tags":"","url":"proc/count_blocks_and_points.html"},{"title":"extract_U_from_filename – LSDA-Hubbard-Fortran","text":"public  subroutine extract_U_from_filename(filename, U, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out) :: U integer, intent(out) :: ierr Called by proc~~extract_u_from_filename~~CalledByGraph proc~extract_u_from_filename extract_U_from_filename proc~read_cpp_table read_cpp_table proc~read_cpp_table->proc~extract_u_from_filename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine extract_U_from_filename ( filename , U , ierr ) character ( len =* ), intent ( in ) :: filename real ( dp ), intent ( out ) :: U integer , intent ( out ) :: ierr integer :: pos_u , pos_end , i , io_stat character ( len = 32 ) :: u_string logical :: found_dot pos_u = index ( filename , '_u' ) if ( pos_u == 0 ) then ierr = ERROR_INVALID_INPUT return end if u_string = filename ( pos_u + 2 :) pos_end = 0 found_dot = . false . do i = 1 , len_trim ( u_string ) if ( u_string ( i : i ) == '.' ) then if ( found_dot ) then pos_end = i - 1 exit else found_dot = . true . end if else if (. not . (( u_string ( i : i ) >= '0' . and . u_string ( i : i ) <= '9' ) . or . & u_string ( i : i ) == '-' . or . u_string ( i : i ) == '+' . or . & u_string ( i : i ) == 'e' . or . u_string ( i : i ) == 'E' )) then pos_end = i - 1 exit end if end do if ( pos_end == 0 ) pos_end = len_trim ( u_string ) read ( u_string ( 1 : pos_end ), * , iostat = io_stat ) U if ( io_stat /= 0 ) then ierr = ERROR_FILE_READ return end if ierr = ERROR_SUCCESS end subroutine extract_U_from_filename","tags":"","url":"proc/extract_u_from_filename.html"},{"title":"write_fortran_table – LSDA-Hubbard-Fortran","text":"public  subroutine write_fortran_table(filename, table, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( xc_table_t ), intent(in) :: table integer, intent(out) :: ierr Called by proc~~write_fortran_table~~CalledByGraph proc~write_fortran_table write_fortran_table proc~generate_table_grid generate_table_grid proc~generate_table_grid->proc~write_fortran_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine write_fortran_table ( filename , table , ierr ) character ( len =* ), intent ( in ) :: filename type ( xc_table_t ), intent ( in ) :: table integer , intent ( out ) :: ierr integer :: unit , io_stat if (. not . allocated ( table % n_grid )) then ierr = ERROR_INVALID_INPUT return end if open ( newunit = unit , file = filename , status = 'replace' , action = 'write' , & form = 'unformatted' , access = 'stream' , iostat = io_stat ) if ( io_stat /= 0 ) then ierr = ERROR_FILE_WRITE return end if write ( unit , iostat = io_stat ) table % U if ( io_stat /= 0 ) goto 100 write ( unit , iostat = io_stat ) table % n_points_n , table % n_points_m if ( io_stat /= 0 ) goto 100 write ( unit , iostat = io_stat ) table % n_grid if ( io_stat /= 0 ) goto 100 write ( unit , iostat = io_stat ) table % m_grid if ( io_stat /= 0 ) goto 100 write ( unit , iostat = io_stat ) table % exc if ( io_stat /= 0 ) goto 100 write ( unit , iostat = io_stat ) table % vxc_up if ( io_stat /= 0 ) goto 100 write ( unit , iostat = io_stat ) table % vxc_down if ( io_stat /= 0 ) goto 100 close ( unit ) ierr = ERROR_SUCCESS return 100 ierr = ERROR_FILE_WRITE close ( unit ) end subroutine write_fortran_table","tags":"","url":"proc/write_fortran_table.html"},{"title":"read_fortran_table – LSDA-Hubbard-Fortran","text":"public  subroutine read_fortran_table(filename, table, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( xc_table_t ), intent(out) :: table integer, intent(out) :: ierr Calls proc~~read_fortran_table~~CallsGraph proc~read_fortran_table read_fortran_table proc~deallocate_table deallocate_table proc~read_fortran_table->proc~deallocate_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_fortran_table~~CalledByGraph proc~read_fortran_table read_fortran_table proc~xc_lsda_init xc_lsda_init proc~xc_lsda_init->proc~read_fortran_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_fortran_table ( filename , table , ierr ) character ( len =* ), intent ( in ) :: filename type ( xc_table_t ), intent ( out ) :: table integer , intent ( out ) :: ierr integer :: unit , io_stat call deallocate_table ( table ) open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & form = 'unformatted' , access = 'stream' , iostat = io_stat ) if ( io_stat /= 0 ) then ierr = ERROR_FILE_NOT_FOUND return end if read ( unit , iostat = io_stat ) table % U if ( io_stat /= 0 ) goto 200 read ( unit , iostat = io_stat ) table % n_points_n , table % n_points_m if ( io_stat /= 0 ) goto 200 if ( table % n_points_n <= 0 . or . table % n_points_m <= 0 ) then ierr = ERROR_INVALID_INPUT close ( unit ) return end if allocate ( table % n_grid ( table % n_points_n )) allocate ( table % m_grid ( table % n_points_m , table % n_points_n )) allocate ( table % exc ( table % n_points_m , table % n_points_n )) allocate ( table % vxc_up ( table % n_points_m , table % n_points_n )) allocate ( table % vxc_down ( table % n_points_m , table % n_points_n )) read ( unit , iostat = io_stat ) table % n_grid if ( io_stat /= 0 ) goto 200 read ( unit , iostat = io_stat ) table % m_grid if ( io_stat /= 0 ) goto 200 read ( unit , iostat = io_stat ) table % exc if ( io_stat /= 0 ) goto 200 read ( unit , iostat = io_stat ) table % vxc_up if ( io_stat /= 0 ) goto 200 read ( unit , iostat = io_stat ) table % vxc_down if ( io_stat /= 0 ) goto 200 close ( unit ) ierr = ERROR_SUCCESS return 200 ierr = ERROR_FILE_READ close ( unit ) call deallocate_table ( table ) end subroutine read_fortran_table","tags":"","url":"proc/read_fortran_table.html"},{"title":"deallocate_table – LSDA-Hubbard-Fortran","text":"public  subroutine deallocate_table(table) Arguments Type Intent Optional Attributes Name type( xc_table_t ), intent(inout) :: table Called by proc~~deallocate_table~~CalledByGraph proc~deallocate_table deallocate_table proc~read_fortran_table read_fortran_table proc~read_fortran_table->proc~deallocate_table proc~xc_lsda_init xc_lsda_init proc~xc_lsda_init->proc~deallocate_table proc~xc_lsda_init->proc~read_fortran_table Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine deallocate_table ( table ) type ( xc_table_t ), intent ( inout ) :: table if ( allocated ( table % n_grid )) deallocate ( table % n_grid ) if ( allocated ( table % m_grid )) deallocate ( table % m_grid ) if ( allocated ( table % exc )) deallocate ( table % exc ) if ( allocated ( table % vxc_up )) deallocate ( table % vxc_up ) if ( allocated ( table % vxc_down )) deallocate ( table % vxc_down ) end subroutine deallocate_table","tags":"","url":"proc/deallocate_table.html"},{"title":"print_table_info – LSDA-Hubbard-Fortran","text":"public  subroutine print_table_info(table, unit) Arguments Type Intent Optional Attributes Name type( xc_table_t ), intent(in) :: table integer, intent(in), optional :: unit Source Code subroutine print_table_info ( table , unit ) type ( xc_table_t ), intent ( in ) :: table integer , intent ( in ), optional :: unit integer :: out_unit real ( dp ) :: n_min , n_max , m_min , m_max , exc_min , exc_max , vxc_min , vxc_max out_unit = 6 if ( present ( unit )) out_unit = unit if (. not . allocated ( table % n_grid )) then write ( out_unit , '(A)' ) \"XC Table: [UNALLOCATED]\" return end if n_min = minval ( table % n_grid ) n_max = maxval ( table % n_grid ) m_min = minval ( table % m_grid ) m_max = maxval ( table % m_grid ) exc_min = minval ( table % exc ) exc_max = maxval ( table % exc ) vxc_min = min ( minval ( table % vxc_up ), minval ( table % vxc_down )) vxc_max = max ( maxval ( table % vxc_up ), maxval ( table % vxc_down )) write ( out_unit , '(A)' ) \"=========================================\" write ( out_unit , '(A)' ) \"XC Table Summary\" write ( out_unit , '(A)' ) \"=========================================\" write ( out_unit , '(A,F8.4)' ) \"  Hubbard U:           \" , table % U write ( out_unit , '(A,I6)' ) \"  Density points:      \" , table % n_points_n write ( out_unit , '(A,I6)' ) \"  Magnetization points:\" , table % n_points_m write ( out_unit , '(A)' ) \"-----------------------------------------\" write ( out_unit , '(A,F10.6,A,F10.6)' ) \"  Density range:       \" , n_min , \" to \" , n_max write ( out_unit , '(A,ES12.5,A,ES12.5)' ) \"  Magnetization range: \" , m_min , \" to \" , m_max write ( out_unit , '(A)' ) \"-----------------------------------------\" write ( out_unit , '(A,ES12.5,A,ES12.5)' ) \"  E_xc range:          \" , exc_min , \" to \" , exc_max write ( out_unit , '(A,ES12.5,A,ES12.5)' ) \"  V_xc range:          \" , vxc_min , \" to \" , vxc_max write ( out_unit , '(A)' ) \"=========================================\" end subroutine print_table_info","tags":"","url":"proc/print_table_info.html"},{"title":"potential_random_uniform – LSDA-Hubbard-Fortran","text":"public  subroutine potential_random_uniform(W, L, seed, V, ierr) Random potential with uniform distribution: V(i) ~ U[-W, W] Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: W integer, intent(in) :: L integer, intent(in) :: seed real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr Called by proc~~potential_random_uniform~~CalledByGraph proc~potential_random_uniform potential_random_uniform proc~create_potential create_potential proc~create_potential->proc~potential_random_uniform Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine potential_random_uniform ( W , L , seed , V , ierr ) real ( dp ), intent ( in ) :: W integer , intent ( in ) :: L , seed real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr integer :: i , seed_size integer , allocatable :: seed_array (:) real ( dp ) :: rand_val ierr = ERROR_SUCCESS if ( W < 0.0_dp ) then ierr = ERROR_NEGATIVE_VALUE V = 0.0_dp return end if ! Special case: W = 0 means no disorder if ( W == 0.0_dp ) then V = 0.0_dp return end if if ( seed >= 0 ) then call random_seed ( size = seed_size ) allocate ( seed_array ( seed_size )) seed_array = seed call random_seed ( put = seed_array ) deallocate ( seed_array ) else call random_seed () end if do i = 1 , L call random_number ( rand_val ) ! C++ formula: V*(2.0*rand - 1.0) gives [-V, +V] ! Matches C++ random1 implementation exactly V ( i ) = W * ( 2.0_dp * rand_val - 1.0_dp ) ! Maps [0,1] → [-W, +W] end do end subroutine potential_random_uniform","tags":"","url":"proc/potential_random_uniform.html"},{"title":"potential_random_gaussian – LSDA-Hubbard-Fortran","text":"public  subroutine potential_random_gaussian(sigma, L, seed, V, ierr) Random potential with Gaussian distribution: V(i) ~ N(0, σ²) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sigma integer, intent(in) :: L integer, intent(in) :: seed real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr Called by proc~~potential_random_gaussian~~CalledByGraph proc~potential_random_gaussian potential_random_gaussian proc~create_potential create_potential proc~create_potential->proc~potential_random_gaussian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine potential_random_gaussian ( sigma , L , seed , V , ierr ) real ( dp ), intent ( in ) :: sigma integer , intent ( in ) :: L , seed real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr integer :: i , seed_size integer , allocatable :: seed_array (:) real ( dp ) :: u1 , u2 , z1 , z2 ierr = ERROR_SUCCESS if ( sigma < 0.0_dp ) then ierr = ERROR_NEGATIVE_VALUE V = 0.0_dp return end if ! Special case: sigma = 0 means no disorder if ( sigma == 0.0_dp ) then V = 0.0_dp return end if if ( seed >= 0 ) then call random_seed ( size = seed_size ) allocate ( seed_array ( seed_size )) seed_array = seed call random_seed ( put = seed_array ) deallocate ( seed_array ) else call random_seed () end if ! Generate Gaussian random values using Box-Muller transform do i = 1 , L , 2 call random_number ( u1 ) call random_number ( u2 ) ! Box-Muller transform z1 = sqrt ( - 2.0_dp * log ( u1 )) * cos ( 2.0_dp * PI * u2 ) z2 = sqrt ( - 2.0_dp * log ( u1 )) * sin ( 2.0_dp * PI * u2 ) V ( i ) = sigma * z1 if ( i + 1 <= L ) then V ( i + 1 ) = sigma * z2 end if end do end subroutine potential_random_gaussian","tags":"","url":"proc/potential_random_gaussian.html"},{"title":"validate_bc_parameters – LSDA-Hubbard-Fortran","text":"public  subroutine validate_bc_parameters(bc_type, theta, L, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: bc_type real(kind=dp), intent(in), optional :: theta integer, intent(in) :: L integer, intent(out) :: ierr Called by proc~~validate_bc_parameters~~CalledByGraph proc~validate_bc_parameters validate_bc_parameters proc~apply_boundary_conditions apply_boundary_conditions proc~apply_boundary_conditions->proc~validate_bc_parameters proc~apply_boundary_conditions_complex apply_boundary_conditions_complex proc~apply_boundary_conditions_complex->proc~validate_bc_parameters proc~get_free_particle_eigenvalues get_free_particle_eigenvalues proc~get_free_particle_eigenvalues->proc~validate_bc_parameters proc~build_hamiltonian build_hamiltonian proc~build_hamiltonian->proc~apply_boundary_conditions proc~build_hamiltonian_complex build_hamiltonian_complex proc~build_hamiltonian_complex->proc~apply_boundary_conditions_complex proc~build_hamiltonian_free build_hamiltonian_free proc~build_hamiltonian_free->proc~apply_boundary_conditions proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~build_hamiltonian_complex proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~build_hamiltonian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine validate_bc_parameters ( bc_type , theta , L , ierr ) integer , intent ( in ) :: bc_type real ( dp ), intent ( in ), optional :: theta integer , intent ( in ) :: L integer , intent ( out ) :: ierr integer , parameter :: allowed ( 3 ) = [ BC_OPEN , BC_PERIODIC , BC_TWISTED ] ierr = 0 if ( L <= 1 ) then ierr = ERROR_INVALID_INPUT return end if if (. not . any ( bc_type == allowed )) then ierr = ERROR_INVALID_INPUT return end if if ( bc_type == BC_OPEN ) then return end if if ( bc_type == BC_TWISTED ) then if (. not . present ( theta )) then ierr = ERROR_INVALID_INPUT return end if if ( theta < 0.0_dp . or . theta >= TWOPI ) then ierr = ERROR_OUT_OF_BOUNDS return end if end if end subroutine validate_bc_parameters","tags":"","url":"proc/validate_bc_parameters.html"},{"title":"apply_boundary_conditions – LSDA-Hubbard-Fortran","text":"public  subroutine apply_boundary_conditions(H, L, bc_type, theta, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: H (:,:) integer, intent(in) :: L integer, intent(in) :: bc_type real(kind=dp), intent(in), optional :: theta integer, intent(out) :: ierr Calls proc~~apply_boundary_conditions~~CallsGraph proc~apply_boundary_conditions apply_boundary_conditions proc~validate_bc_parameters validate_bc_parameters proc~apply_boundary_conditions->proc~validate_bc_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~apply_boundary_conditions~~CalledByGraph proc~apply_boundary_conditions apply_boundary_conditions proc~build_hamiltonian build_hamiltonian proc~build_hamiltonian->proc~apply_boundary_conditions proc~build_hamiltonian_free build_hamiltonian_free proc~build_hamiltonian_free->proc~apply_boundary_conditions proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~build_hamiltonian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine apply_boundary_conditions ( H , L , bc_type , theta , ierr ) real ( dp ), intent ( inout ) :: H (:,:) integer , intent ( in ) :: L integer , intent ( in ) :: bc_type real ( dp ), intent ( in ), optional :: theta integer , intent ( out ) :: ierr ierr = 0 call validate_bc_parameters ( bc_type , theta , L , ierr ) if ( ierr /= 0 ) return if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if select case ( bc_type ) case ( BC_OPEN ) return case ( BC_PERIODIC ) H ( 1 , L ) = - 1.0_dp ! Assuming hopping parameter t = 1 H ( L , 1 ) = - 1.0_dp ! Assuming hopping parameter t = 1 case ( BC_TWISTED ) ierr = ERROR_INVALID_INPUT return case default ierr = ERROR_INVALID_INPUT end select end subroutine apply_boundary_conditions","tags":"","url":"proc/apply_boundary_conditions.html"},{"title":"apply_boundary_conditions_complex – LSDA-Hubbard-Fortran","text":"public  subroutine apply_boundary_conditions_complex(H, L, bc_type, theta, ierr) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: H (:,:) integer, intent(in) :: L integer, intent(in) :: bc_type real(kind=dp), intent(in), optional :: theta integer, intent(out) :: ierr Calls proc~~apply_boundary_conditions_complex~~CallsGraph proc~apply_boundary_conditions_complex apply_boundary_conditions_complex proc~validate_bc_parameters validate_bc_parameters proc~apply_boundary_conditions_complex->proc~validate_bc_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~apply_boundary_conditions_complex~~CalledByGraph proc~apply_boundary_conditions_complex apply_boundary_conditions_complex proc~build_hamiltonian_complex build_hamiltonian_complex proc~build_hamiltonian_complex->proc~apply_boundary_conditions_complex proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~build_hamiltonian_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine apply_boundary_conditions_complex ( H , L , bc_type , theta , ierr ) complex ( dp ), intent ( inout ) :: H (:,:) integer , intent ( in ) :: L integer , intent ( in ) :: bc_type real ( dp ), intent ( in ), optional :: theta complex ( dp ), allocatable :: H_complex (:,:) integer , intent ( out ) :: ierr real ( dp ) :: theta_val complex ( dp ), parameter :: IMAG_UNIT = ( 0.0_dp , 1.0_dp ) ierr = 0 call validate_bc_parameters ( bc_type , theta , L , ierr ) if ( ierr /= 0 ) return if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if select case ( bc_type ) case ( BC_OPEN ) return case ( BC_PERIODIC ) H ( 1 , L ) = cmplx ( - 1.0_dp , 0.0_dp , kind = dp ) ! Assuming hopping parameter t = 1 H ( L , 1 ) = cmplx ( - 1.0_dp , 0.0_dp , kind = dp ) ! Assuming hopping parameter t = 1 case ( BC_TWISTED ) theta_val = theta H ( 1 , L ) = - 1.0_dp * exp ( IMAG_UNIT * theta_val ) H ( L , 1 ) = - 1.0_dp * exp ( - IMAG_UNIT * theta_val ) case default ierr = ERROR_INVALID_INPUT end select end subroutine apply_boundary_conditions_complex","tags":"","url":"proc/apply_boundary_conditions_complex.html"},{"title":"get_free_particle_eigenvalues – LSDA-Hubbard-Fortran","text":"public  subroutine get_free_particle_eigenvalues(L, bc_type, theta, eigenvalues, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: L integer, intent(in) :: bc_type real(kind=dp), intent(in), optional :: theta real(kind=dp), intent(out) :: eigenvalues (:) integer, intent(out) :: ierr Calls proc~~get_free_particle_eigenvalues~~CallsGraph proc~get_free_particle_eigenvalues get_free_particle_eigenvalues proc~validate_bc_parameters validate_bc_parameters proc~get_free_particle_eigenvalues->proc~validate_bc_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_free_particle_eigenvalues ( L , bc_type , theta , eigenvalues , ierr ) integer , intent ( in ) :: L integer , intent ( in ) :: bc_type real ( dp ), intent ( in ), optional :: theta real ( dp ), intent ( out ) :: eigenvalues (:) integer , intent ( out ) :: ierr integer :: n , k real ( dp ) :: theta_val ierr = 0 call validate_bc_parameters ( bc_type , theta , L , ierr ) if ( ierr /= 0 ) return if ( size ( eigenvalues ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if select case ( bc_type ) case ( BC_OPEN ) do n = 1 , L eigenvalues ( n ) = - 2.0_dp * cos ( n * PI / real ( L + 1 , dp )) ! Assuming hopping parameter t = 1 end do case ( BC_PERIODIC ) do k = 0 , L - 1 eigenvalues ( k + 1 ) = - 2.0_dp * cos ( TWOPI * k / real ( L , dp )) ! Assuming hopping parameter t = 1 end do case ( BC_TWISTED ) theta_val = theta do k = 0 , L - 1 eigenvalues ( k + 1 ) = - 2.0_dp * cos (( TWOPI * k + theta_val ) / real ( L , dp )) ! Assuming hopping parameter t = 1 end do case default ierr = ERROR_INVALID_INPUT return end select end subroutine get_free_particle_eigenvalues","tags":"","url":"proc/get_free_particle_eigenvalues.html"},{"title":"adaptive_mix_get_alpha – LSDA-Hubbard-Fortran","text":"public  function adaptive_mix_get_alpha(mix_ctrl) result(alpha) Get alpha (Fortran convention) from mix (C++ convention) Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(in) :: mix_ctrl Return Value real(kind=dp) Called by proc~~adaptive_mix_get_alpha~~CalledByGraph proc~adaptive_mix_get_alpha adaptive_mix_get_alpha proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~adaptive_mix_get_alpha proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~adaptive_mix_get_alpha Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function adaptive_mix_get_alpha ( mix_ctrl ) result ( alpha ) type ( adaptive_mix_t ), intent ( in ) :: mix_ctrl real ( dp ) :: alpha alpha = 1.0_dp - mix_ctrl % mix ! Clamp to valid range (0, 1] to prevent linear_mixing from failing if ( alpha <= 0.0_dp ) then alpha = 1.0e-10_dp ! Very small but positive else if ( alpha > 1.0_dp ) then alpha = 1.0_dp end if end function adaptive_mix_get_alpha","tags":"","url":"proc/adaptive_mix_get_alpha.html"},{"title":"adaptive_mix_init – LSDA-Hubbard-Fortran","text":"public  subroutine adaptive_mix_init(mix_ctrl, tol) Initialize adaptive mixing Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(out) :: mix_ctrl real(kind=dp), intent(in), optional :: tol Called by proc~~adaptive_mix_init~~CalledByGraph proc~adaptive_mix_init adaptive_mix_init proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~adaptive_mix_init proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~adaptive_mix_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine adaptive_mix_init ( mix_ctrl , tol ) type ( adaptive_mix_t ), intent ( out ) :: mix_ctrl real ( dp ), intent ( in ), optional :: tol mix_ctrl % iter = 0 mix_ctrl % count_sc = 0 mix_ctrl % count_bot = 0 mix_ctrl % count_top = 0 mix_ctrl % count_sc_max = 10 mix_ctrl % mix = INITIAL_MIX mix_ctrl % energy_top = 0.0_dp mix_ctrl % energy_bot = 0.0_dp mix_ctrl % energy_new = 0.0_dp mix_ctrl % energy_old = 0.0_dp mix_ctrl % converged = . false . if ( present ( tol )) then mix_ctrl % tol = tol else mix_ctrl % tol = 1.0e-8_dp end if end subroutine adaptive_mix_init","tags":"","url":"proc/adaptive_mix_init.html"},{"title":"adaptive_mix_update – LSDA-Hubbard-Fortran","text":"public  subroutine adaptive_mix_update(mix_ctrl, energy) Update adaptive mixing based on new energy Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(inout) :: mix_ctrl real(kind=dp), intent(in) :: energy Calls proc~~adaptive_mix_update~~CallsGraph proc~adaptive_mix_update adaptive_mix_update proc~dw_mix dw_mix proc~adaptive_mix_update->proc~dw_mix proc~reset_counts reset_counts proc~adaptive_mix_update->proc~reset_counts proc~up_mix up_mix proc~adaptive_mix_update->proc~up_mix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~adaptive_mix_update~~CalledByGraph proc~adaptive_mix_update adaptive_mix_update proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~adaptive_mix_update proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~adaptive_mix_update Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine adaptive_mix_update ( mix_ctrl , energy ) type ( adaptive_mix_t ), intent ( inout ) :: mix_ctrl real ( dp ), intent ( in ) :: energy real ( dp ) :: error , band_error ! Increment iteration mix_ctrl % iter = mix_ctrl % iter + 1 ! Update energies mix_ctrl % energy_old = mix_ctrl % energy_new mix_ctrl % energy_new = energy ! First iteration: initialize bounds if ( mix_ctrl % iter == 1 ) then mix_ctrl % energy_top = energy mix_ctrl % energy_bot = energy mix_ctrl % energy_old = energy mix_ctrl % converged = . false . return end if ! Calculate relative error if ( abs ( mix_ctrl % energy_new ) > 1.0e-15_dp ) then error = abs (( mix_ctrl % energy_new - mix_ctrl % energy_old ) / mix_ctrl % energy_new ) else error = abs ( mix_ctrl % energy_new - mix_ctrl % energy_old ) end if ! Calculate band error if ( abs ( mix_ctrl % energy_bot ) > 1.0e-15_dp ) then band_error = abs (( mix_ctrl % energy_top - mix_ctrl % energy_bot ) / mix_ctrl % energy_bot ) else band_error = abs ( mix_ctrl % energy_top - mix_ctrl % energy_bot ) end if ! Check if energy is within current band [Bot, Top] if ( mix_ctrl % energy_bot <= mix_ctrl % energy_new . and . & mix_ctrl % energy_new <= mix_ctrl % energy_top ) then ! Energy within band mix_ctrl % count_sc = mix_ctrl % count_sc + 1 mix_ctrl % count_top = 0 mix_ctrl % count_bot = 0 ! Check convergence if ( mix_ctrl % count_sc >= mix_ctrl % count_sc_max . and . & error < mix_ctrl % tol . and . band_error < mix_ctrl % tol ) then mix_ctrl % converged = . true . return end if ! Energy in band but not converged → UpMix (more conservative) if ( mix_ctrl % count_sc >= mix_ctrl % count_sc_max . and . & ( error >= mix_ctrl % tol . or . band_error >= mix_ctrl % tol )) then call up_mix ( mix_ctrl ) call reset_counts ( mix_ctrl ) end if else if ( mix_ctrl % energy_new > mix_ctrl % energy_top ) then ! Energy increased above top mix_ctrl % energy_top = mix_ctrl % energy_new mix_ctrl % count_top = mix_ctrl % count_top + 1 mix_ctrl % count_bot = 0 mix_ctrl % count_sc = 0 else if ( mix_ctrl % energy_new < mix_ctrl % energy_bot ) then ! Energy decreased below bottom mix_ctrl % energy_bot = mix_ctrl % energy_new mix_ctrl % count_bot = mix_ctrl % count_bot + 1 mix_ctrl % count_top = 0 mix_ctrl % count_sc = 0 end if ! If energy only increases or decreases for too long → DwMix (more aggressive) ! IMPORTANT: C++ checks Mix > 0.35 to prevent Mix from becoming too small if (( mix_ctrl % count_bot > mix_ctrl % count_sc_max * 5 . or . & mix_ctrl % count_top > mix_ctrl % count_sc_max * 5 ) . and . & mix_ctrl % mix > 0.35_dp ) then call dw_mix ( mix_ctrl ) ! Clamp Mix to prevent it from going too negative ! (C++ doesn't clamp explicitly, but the check above prevents problems) if ( mix_ctrl % mix < 0.0_dp ) then mix_ctrl % mix = 0.0_dp end if call reset_counts ( mix_ctrl ) end if ! Max iterations reached if ( mix_ctrl % iter >= ITER_MAX ) then mix_ctrl % converged = . false . end if end subroutine adaptive_mix_update","tags":"","url":"proc/adaptive_mix_update.html"},{"title":"adaptive_mix_reset – LSDA-Hubbard-Fortran","text":"public  subroutine adaptive_mix_reset(mix_ctrl) Reset adaptive mixing counters (keep Mix value) Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(inout) :: mix_ctrl Calls proc~~adaptive_mix_reset~~CallsGraph proc~adaptive_mix_reset adaptive_mix_reset proc~reset_counts reset_counts proc~adaptive_mix_reset->proc~reset_counts Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine adaptive_mix_reset ( mix_ctrl ) type ( adaptive_mix_t ), intent ( inout ) :: mix_ctrl call reset_counts ( mix_ctrl ) ! Reset energy bounds to current energy mix_ctrl % energy_top = mix_ctrl % energy_new mix_ctrl % energy_bot = mix_ctrl % energy_new mix_ctrl % energy_old = mix_ctrl % energy_new end subroutine adaptive_mix_reset","tags":"","url":"proc/adaptive_mix_reset.html"},{"title":"up_mix – LSDA-Hubbard-Fortran","text":"private  subroutine up_mix(mix_ctrl) Increase mixing parameter (more conservative) Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(inout) :: mix_ctrl Called by proc~~up_mix~~CalledByGraph proc~up_mix up_mix proc~adaptive_mix_update adaptive_mix_update proc~adaptive_mix_update->proc~up_mix proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~adaptive_mix_update proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~adaptive_mix_update Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine up_mix ( mix_ctrl ) type ( adaptive_mix_t ), intent ( inout ) :: mix_ctrl real ( dp ) :: new_mix new_mix = mix_ctrl % mix + ( 1.0_dp - mix_ctrl % mix ) / 1.5_dp if ( new_mix < 0.999999999_dp ) then mix_ctrl % mix = new_mix end if end subroutine up_mix","tags":"","url":"proc/up_mix.html"},{"title":"dw_mix – LSDA-Hubbard-Fortran","text":"private  subroutine dw_mix(mix_ctrl) Decrease mixing parameter (more aggressive) Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(inout) :: mix_ctrl Called by proc~~dw_mix~~CalledByGraph proc~dw_mix dw_mix proc~adaptive_mix_update adaptive_mix_update proc~adaptive_mix_update->proc~dw_mix proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~adaptive_mix_update proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~adaptive_mix_update Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dw_mix ( mix_ctrl ) type ( adaptive_mix_t ), intent ( inout ) :: mix_ctrl mix_ctrl % mix = mix_ctrl % mix - ( 1.0_dp - mix_ctrl % mix ) * 1.9_dp end subroutine dw_mix","tags":"","url":"proc/dw_mix.html"},{"title":"reset_counts – LSDA-Hubbard-Fortran","text":"private  subroutine reset_counts(mix_ctrl) Reset counters only (internal helper) Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(inout) :: mix_ctrl Called by proc~~reset_counts~~CalledByGraph proc~reset_counts reset_counts proc~adaptive_mix_reset adaptive_mix_reset proc~adaptive_mix_reset->proc~reset_counts proc~adaptive_mix_update adaptive_mix_update proc~adaptive_mix_update->proc~reset_counts proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->proc~adaptive_mix_update proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->proc~adaptive_mix_update Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine reset_counts ( mix_ctrl ) type ( adaptive_mix_t ), intent ( inout ) :: mix_ctrl mix_ctrl % count_sc = 0 mix_ctrl % count_bot = 0 mix_ctrl % count_top = 0 end subroutine reset_counts","tags":"","url":"proc/reset_counts.html"},{"title":"compute_density_spin_real – LSDA-Hubbard-Fortran","text":"private  subroutine compute_density_spin_real(eigvecs, L, n_elec, density, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigvecs (:,:) integer, intent(in) :: L integer, intent(in) :: n_elec real(kind=dp), intent(out) :: density (:) integer, intent(out) :: ierr Called by proc~~compute_density_spin_real~~CalledByGraph proc~compute_density_spin_real compute_density_spin_real interface~compute_density_spin compute_density_spin interface~compute_density_spin->proc~compute_density_spin_real proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->interface~compute_density_spin proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->interface~compute_density_spin Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/compute_density_spin_real.html"},{"title":"compute_density_spin_complex – LSDA-Hubbard-Fortran","text":"private  subroutine compute_density_spin_complex(eigvecs, L, n_elec, density, ierr) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: eigvecs (:,:) integer, intent(in) :: L integer, intent(in) :: n_elec real(kind=dp), intent(out) :: density (:) integer, intent(out) :: ierr Called by proc~~compute_density_spin_complex~~CalledByGraph proc~compute_density_spin_complex compute_density_spin_complex interface~compute_density_spin compute_density_spin interface~compute_density_spin->proc~compute_density_spin_complex proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->interface~compute_density_spin proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->interface~compute_density_spin Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/compute_density_spin_complex.html"},{"title":"compute_total_density – LSDA-Hubbard-Fortran","text":"public  subroutine compute_total_density(density_up, density_dw, density_total, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: density_up (:) real(kind=dp), intent(in) :: density_dw (:) real(kind=dp), intent(out) :: density_total (:) integer, intent(out) :: ierr","tags":"","url":"proc/compute_total_density.html"},{"title":"verify_particle_number – LSDA-Hubbard-Fortran","text":"public  subroutine verify_particle_number(density, L, n_expected, is_conserved, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: density (:) integer, intent(in) :: L integer, intent(in) :: n_expected logical, intent(out) :: is_conserved integer, intent(out) :: ierr","tags":"","url":"proc/verify_particle_number.html"},{"title":"check_density_bounds – LSDA-Hubbard-Fortran","text":"public  subroutine check_density_bounds(density_up, density_dw, L, all_valid, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: density_up (:) real(kind=dp), intent(in) :: density_dw (:) integer, intent(in) :: L logical, intent(out) :: all_valid integer, intent(out) :: ierr","tags":"","url":"proc/check_density_bounds.html"},{"title":"compute_density_spin – LSDA-Hubbard-Fortran","text":"public interface compute_density_spin Calls interface~~compute_density_spin~~CallsGraph interface~compute_density_spin compute_density_spin proc~compute_density_spin_complex compute_density_spin_complex interface~compute_density_spin->proc~compute_density_spin_complex proc~compute_density_spin_real compute_density_spin_real interface~compute_density_spin->proc~compute_density_spin_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~compute_density_spin~~CalledByGraph interface~compute_density_spin compute_density_spin proc~run_kohn_sham_scf_complex run_kohn_sham_scf_complex proc~run_kohn_sham_scf_complex->interface~compute_density_spin proc~run_kohn_sham_scf_real run_kohn_sham_scf_real proc~run_kohn_sham_scf_real->interface~compute_density_spin Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine compute_density_spin_real (eigvecs, L, n_elec, density, ierr) Compute density from real eigenvectors (Open/Periodic BC) Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigvecs (:,:) integer, intent(in) :: L integer, intent(in) :: n_elec real(kind=dp), intent(out) :: density (:) integer, intent(out) :: ierr private  subroutine compute_density_spin_complex (eigvecs, L, n_elec, density, ierr) Compute density from complex eigenvectors (Twisted BC) Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: eigvecs (:,:) integer, intent(in) :: L integer, intent(in) :: n_elec real(kind=dp), intent(out) :: density (:) integer, intent(out) :: ierr","tags":"","url":"interface/compute_density_spin.html"},{"title":"estimate_dxdU – LSDA-Hubbard-Fortran","text":"public  function estimate_dxdU(x_old, x_current, dU) result(dxdU) Estimates dx/dU using finite differences Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x_old (:) real(kind=dp), intent(in) :: x_current (:) real(kind=dp), intent(in) :: dU Return Value real(kind=dp), (size(x_current)) Called by proc~~estimate_dxdu~~CalledByGraph proc~estimate_dxdu estimate_dxdU proc~sweep_u_backward sweep_U_backward proc~sweep_u_backward->proc~estimate_dxdu proc~sweep_u_forward sweep_U_forward proc~sweep_u_forward->proc~estimate_dxdu proc~sweep_u_bidirectional sweep_U_bidirectional proc~sweep_u_bidirectional->proc~sweep_u_backward proc~sweep_u_bidirectional->proc~sweep_u_forward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function estimate_dxdU ( x_old , x_current , dU ) result ( dxdU ) real ( dp ), intent ( in ) :: x_old (:), x_current (:), dU real ( dp ) :: dxdU ( size ( x_current )) dxdU = ( x_current - x_old ) / dU end function estimate_dxdU","tags":"","url":"proc/estimate_dxdu.html"},{"title":"sweep_U_forward – LSDA-Hubbard-Fortran","text":"public  subroutine sweep_U_forward(I, J, L, U_values, solutions, energies, converged_flags) Forward sweep in U with predictor-corrector method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U_values (:) real(kind=dp), intent(out) :: solutions (:,:) real(kind=dp), intent(out) :: energies (:) logical, intent(out) :: converged_flags (:) Calls proc~~sweep_u_forward~~CallsGraph proc~sweep_u_forward sweep_U_forward proc~compute_energy compute_energy proc~sweep_u_forward->proc~compute_energy proc~estimate_dxdu estimate_dxdU proc~sweep_u_forward->proc~estimate_dxdu proc~solve_newton solve_newton proc~sweep_u_forward->proc~solve_newton proc~compute_jacobian compute_jacobian proc~solve_newton->proc~compute_jacobian proc~compute_residual compute_residual proc~solve_newton->proc~compute_residual proc~line_search line_search proc~solve_newton->proc~line_search proc~solve_linear_system solve_linear_system proc~solve_newton->proc~solve_linear_system proc~theta theta proc~compute_residual->proc~theta proc~theta_capital Theta_capital proc~compute_residual->proc~theta_capital proc~line_search->proc~compute_residual interface~dgesv DGESV proc~solve_linear_system->interface~dgesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sweep_u_forward~~CalledByGraph proc~sweep_u_forward sweep_U_forward proc~sweep_u_bidirectional sweep_U_bidirectional proc~sweep_u_bidirectional->proc~sweep_u_forward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sweep_u_forward.html"},{"title":"sweep_U_backward – LSDA-Hubbard-Fortran","text":"public  subroutine sweep_U_backward(I, J, L, U_values, solutions, energies, converged_flags) Backward sweep in U with predictor-corrector method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U_values (:) real(kind=dp), intent(out) :: solutions (:,:) real(kind=dp), intent(out) :: energies (:) logical, intent(out) :: converged_flags (:) Calls proc~~sweep_u_backward~~CallsGraph proc~sweep_u_backward sweep_U_backward proc~compute_energy compute_energy proc~sweep_u_backward->proc~compute_energy proc~estimate_dxdu estimate_dxdU proc~sweep_u_backward->proc~estimate_dxdu proc~solve_newton solve_newton proc~sweep_u_backward->proc~solve_newton proc~compute_jacobian compute_jacobian proc~solve_newton->proc~compute_jacobian proc~compute_residual compute_residual proc~solve_newton->proc~compute_residual proc~line_search line_search proc~solve_newton->proc~line_search proc~solve_linear_system solve_linear_system proc~solve_newton->proc~solve_linear_system proc~theta theta proc~compute_residual->proc~theta proc~theta_capital Theta_capital proc~compute_residual->proc~theta_capital proc~line_search->proc~compute_residual interface~dgesv DGESV proc~solve_linear_system->interface~dgesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sweep_u_backward~~CalledByGraph proc~sweep_u_backward sweep_U_backward proc~sweep_u_bidirectional sweep_U_bidirectional proc~sweep_u_bidirectional->proc~sweep_u_backward Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sweep_u_backward.html"},{"title":"sweep_U_bidirectional – LSDA-Hubbard-Fortran","text":"public  subroutine sweep_U_bidirectional(I, J, L, U_values, solutions, energies, converged_flags) Bidirectional sweep with refinement (forward + backward average) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U_values (:) real(kind=dp), intent(out) :: solutions (:,:) real(kind=dp), intent(out) :: energies (:) logical, intent(out) :: converged_flags (:) Calls proc~~sweep_u_bidirectional~~CallsGraph proc~sweep_u_bidirectional sweep_U_bidirectional proc~sweep_u_backward sweep_U_backward proc~sweep_u_bidirectional->proc~sweep_u_backward proc~sweep_u_forward sweep_U_forward proc~sweep_u_bidirectional->proc~sweep_u_forward proc~compute_energy compute_energy proc~sweep_u_backward->proc~compute_energy proc~estimate_dxdu estimate_dxdU proc~sweep_u_backward->proc~estimate_dxdu proc~solve_newton solve_newton proc~sweep_u_backward->proc~solve_newton proc~sweep_u_forward->proc~compute_energy proc~sweep_u_forward->proc~estimate_dxdu proc~sweep_u_forward->proc~solve_newton proc~compute_jacobian compute_jacobian proc~solve_newton->proc~compute_jacobian proc~compute_residual compute_residual proc~solve_newton->proc~compute_residual proc~line_search line_search proc~solve_newton->proc~line_search proc~solve_linear_system solve_linear_system proc~solve_newton->proc~solve_linear_system proc~theta theta proc~compute_residual->proc~theta proc~theta_capital Theta_capital proc~compute_residual->proc~theta_capital proc~line_search->proc~compute_residual interface~dgesv DGESV proc~solve_linear_system->interface~dgesv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/sweep_u_bidirectional.html"},{"title":"output_writer – LSDA-Hubbard-Fortran","text":"Module for writing simulation results to files Uses lsda_constants lsda_types lsda_errors input_parser kohn_sham_cycle module~~output_writer~~UsesGraph module~output_writer output_writer module~input_parser input_parser module~output_writer->module~input_parser module~kohn_sham_cycle kohn_sham_cycle module~output_writer->module~kohn_sham_cycle module~lsda_constants lsda_constants module~output_writer->module~lsda_constants module~lsda_errors lsda_errors module~output_writer->module~lsda_errors module~lsda_types lsda_types module~output_writer->module~lsda_types module~input_parser->module~kohn_sham_cycle module~input_parser->module~lsda_constants module~input_parser->module~lsda_errors module~input_parser->module~lsda_types module~boundary_conditions boundary_conditions module~input_parser->module~boundary_conditions module~kohn_sham_cycle->module~lsda_constants module~kohn_sham_cycle->module~lsda_errors module~kohn_sham_cycle->module~lsda_types module~adaptive_mixing adaptive_mixing module~kohn_sham_cycle->module~adaptive_mixing module~kohn_sham_cycle->module~boundary_conditions module~convergence_monitor convergence_monitor module~kohn_sham_cycle->module~convergence_monitor module~density_calculator density_calculator module~kohn_sham_cycle->module~density_calculator module~hamiltonian_builder hamiltonian_builder module~kohn_sham_cycle->module~hamiltonian_builder module~lapack_wrapper lapack_wrapper module~kohn_sham_cycle->module~lapack_wrapper module~mixing_schemes mixing_schemes module~kohn_sham_cycle->module~mixing_schemes module~xc_lsda xc_lsda module~kohn_sham_cycle->module~xc_lsda iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants module~lsda_types->module~lsda_constants module~adaptive_mixing->module~lsda_constants module~adaptive_mixing->module~lsda_errors module~boundary_conditions->module~lsda_constants module~boundary_conditions->module~lsda_errors module~convergence_monitor->module~lsda_constants module~convergence_monitor->module~lsda_errors module~density_calculator->module~lsda_constants module~density_calculator->module~lsda_errors module~hamiltonian_builder->module~lsda_constants module~hamiltonian_builder->module~lsda_errors module~hamiltonian_builder->module~boundary_conditions ieee_arithmetic ieee_arithmetic module~hamiltonian_builder->ieee_arithmetic module~lapack_wrapper->module~lsda_constants module~lapack_wrapper->module~lsda_errors module~mixing_schemes->module~lsda_constants module~mixing_schemes->module~lsda_errors module~xc_lsda->module~lsda_constants module~xc_lsda->module~lsda_errors module~spline2d spline2d module~xc_lsda->module~spline2d module~table_io table_io module~xc_lsda->module~table_io module~spline2d->module~lsda_constants module~table_io->module~lsda_constants module~table_io->module~lsda_errors module~table_io->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine write_results (results, sys_params, inputs, ierr) Write all simulation results Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(in) :: results type( system_params_t ), intent(in) :: sys_params type( input_params_t ), intent(in) :: inputs integer, intent(out) :: ierr public  subroutine write_summary (results, sys_params, inputs, ierr) Write summary to stdout and file Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(in) :: results type( system_params_t ), intent(in) :: sys_params type( input_params_t ), intent(in) :: inputs integer, intent(out) :: ierr public  subroutine write_density_profile (results, sys_params, prefix, ierr) Write density profile to file Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(in) :: results type( system_params_t ), intent(in) :: sys_params character(len=*), intent(in) :: prefix integer, intent(out) :: ierr public  subroutine write_eigenvalues (results, sys_params, prefix, ierr) Write eigenvalues to file Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(in) :: results type( system_params_t ), intent(in) :: sys_params character(len=*), intent(in) :: prefix integer, intent(out) :: ierr public  subroutine write_convergence_history (results, prefix, ierr) Write convergence history to file Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(in) :: results character(len=*), intent(in) :: prefix integer, intent(out) :: ierr","tags":"","url":"module/output_writer.html"},{"title":"kohn_sham_cycle – LSDA-Hubbard-Fortran","text":"Uses lsda_constants lapack_wrapper adaptive_mixing hamiltonian_builder lsda_types boundary_conditions lsda_errors xc_lsda mixing_schemes density_calculator convergence_monitor module~~kohn_sham_cycle~~UsesGraph module~kohn_sham_cycle kohn_sham_cycle module~adaptive_mixing adaptive_mixing module~kohn_sham_cycle->module~adaptive_mixing module~boundary_conditions boundary_conditions module~kohn_sham_cycle->module~boundary_conditions module~convergence_monitor convergence_monitor module~kohn_sham_cycle->module~convergence_monitor module~density_calculator density_calculator module~kohn_sham_cycle->module~density_calculator module~hamiltonian_builder hamiltonian_builder module~kohn_sham_cycle->module~hamiltonian_builder module~lapack_wrapper lapack_wrapper module~kohn_sham_cycle->module~lapack_wrapper module~lsda_constants lsda_constants module~kohn_sham_cycle->module~lsda_constants module~lsda_errors lsda_errors module~kohn_sham_cycle->module~lsda_errors module~lsda_types lsda_types module~kohn_sham_cycle->module~lsda_types module~mixing_schemes mixing_schemes module~kohn_sham_cycle->module~mixing_schemes module~xc_lsda xc_lsda module~kohn_sham_cycle->module~xc_lsda module~adaptive_mixing->module~lsda_constants module~adaptive_mixing->module~lsda_errors module~boundary_conditions->module~lsda_constants module~boundary_conditions->module~lsda_errors module~convergence_monitor->module~lsda_constants module~convergence_monitor->module~lsda_errors module~density_calculator->module~lsda_constants module~density_calculator->module~lsda_errors module~hamiltonian_builder->module~boundary_conditions module~hamiltonian_builder->module~lsda_constants module~hamiltonian_builder->module~lsda_errors ieee_arithmetic ieee_arithmetic module~hamiltonian_builder->ieee_arithmetic module~lapack_wrapper->module~lsda_constants module~lapack_wrapper->module~lsda_errors iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants module~lsda_types->module~lsda_constants module~mixing_schemes->module~lsda_constants module~mixing_schemes->module~lsda_errors module~xc_lsda->module~lsda_constants module~xc_lsda->module~lsda_errors module~spline2d spline2d module~xc_lsda->module~spline2d module~table_io table_io module~xc_lsda->module~table_io module~spline2d->module~lsda_constants module~table_io->module~lsda_constants module~table_io->module~lsda_errors module~table_io->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~kohn_sham_cycle~~UsedByGraph module~kohn_sham_cycle kohn_sham_cycle module~input_parser input_parser module~input_parser->module~kohn_sham_cycle module~output_writer output_writer module~output_writer->module~kohn_sham_cycle module~output_writer->module~input_parser Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: scf_params_t Parameters for SCF cycle Read more… Components Type Visibility Attributes Name Initial integer, public :: max_iter = ITER_MAX real(kind=dp), public :: density_tol = SCF_DENSITY_TOL real(kind=dp), public :: energy_tol = SCF_ENERGY_TOL real(kind=dp), public :: mixing_alpha = MIX_ALPHA logical, public :: verbose = .false. logical, public :: store_history = .true. logical, public :: use_adaptive_mixing = .true. type, public :: scf_results_t Results from SCF cycle Read more… Components Type Visibility Attributes Name Initial logical, public :: converged integer, public :: n_iterations real(kind=dp), public :: final_density_error real(kind=dp), public :: final_energy real(kind=dp), public, allocatable :: density_up (:) real(kind=dp), public, allocatable :: density_down (:) real(kind=dp), public, allocatable :: eigvals (:) type( convergence_history_t ), public :: history Subroutines public  subroutine compute_total_energy (eigvals_up, eigvals_down, n_up, n_down, density_up, density_down, V_ext, xc_func, U, L, total_energy, ierr) Compute total Kohn-Sham energy Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigvals_up (:) real(kind=dp), intent(in) :: eigvals_down (:) integer, intent(in) :: n_up integer, intent(in) :: n_down real(kind=dp), intent(in) :: density_up (:) real(kind=dp), intent(in) :: density_down (:) real(kind=dp), intent(in) :: V_ext (:) type( xc_lsda_t ), intent(in) :: xc_func real(kind=dp), intent(in) :: U integer, intent(in) :: L real(kind=dp), intent(out) :: total_energy integer, intent(out) :: ierr private  subroutine validate_kohn_sham_cycle_inputs (params, scf_params, V_ext, ierr) Validate inputs for Kohn-Sham SCF cycle Read more… Arguments Type Intent Optional Attributes Name type( system_params_t ), intent(in) :: params type( scf_params_t ), intent(in) :: scf_params real(kind=dp), intent(in) :: V_ext (:) integer, intent(out) :: ierr public  subroutine run_kohn_sham_scf_real (params, scf_params, V_ext, xc_func, results, ierr) Run self-consistent Kohn-Sham cycle (real Hamiltonian) Read more… Arguments Type Intent Optional Attributes Name type( system_params_t ), intent(in) :: params type( scf_params_t ), intent(in) :: scf_params real(kind=dp), intent(in) :: V_ext (:) type( xc_lsda_t ), intent(in) :: xc_func type( scf_results_t ), intent(out) :: results integer, intent(out) :: ierr public  subroutine run_kohn_sham_scf_complex (params, scf_params, V_ext, xc_func, results, ierr) Run self-consistent Kohn-Sham cycle (complex Hamiltonian) Read more… Arguments Type Intent Optional Attributes Name type( system_params_t ), intent(in) :: params type( scf_params_t ), intent(in) :: scf_params real(kind=dp), intent(in) :: V_ext (:) type( xc_lsda_t ), intent(in) :: xc_func type( scf_results_t ), intent(out) :: results integer, intent(out) :: ierr public  subroutine init_scf_results (results, L, store_history, max_iter, ierr) Initialize SCF results structure Read more… Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(out) :: results integer, intent(in) :: L logical, intent(in) :: store_history integer, intent(in) :: max_iter integer, intent(out) :: ierr public  subroutine cleanup_scf_results (results, ierr) Deallocate SCF results Read more… Arguments Type Intent Optional Attributes Name type( scf_results_t ), intent(inout) :: results integer, intent(out) :: ierr","tags":"","url":"module/kohn_sham_cycle.html"},{"title":"nonlinear_solvers – LSDA-Hubbard-Fortran","text":"Nonlinear solvers for the Bethe Ansatz equations Uses bethe_equations ieee_arithmetic lsda_constants module~~nonlinear_solvers~~UsesGraph module~nonlinear_solvers nonlinear_solvers ieee_arithmetic ieee_arithmetic module~nonlinear_solvers->ieee_arithmetic module~bethe_equations bethe_equations module~nonlinear_solvers->module~bethe_equations module~lsda_constants lsda_constants module~nonlinear_solvers->module~lsda_constants module~bethe_equations->module~lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~nonlinear_solvers~~UsedByGraph module~nonlinear_solvers nonlinear_solvers module~bethe_tables bethe_tables module~bethe_tables->module~nonlinear_solvers module~continuation continuation module~continuation->module~nonlinear_solvers Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: ARMIJO_C = 1.0e-4_dp Armijo condition parameter (c ∈ (0,1)) integer, private, parameter :: MAX_LS_ITER = 20 Maximum iterations for line search backtracking Interfaces interface LAPACK interface for solving linear systems A·x = b private  subroutine DGESV(N, NRHS, A, LDA, IPIV, B, LDB, INFO) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: NRHS real(kind=dp), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA integer, intent(out) :: IPIV (*) real(kind=dp), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB integer, intent(out) :: INFO Functions public  function line_search (x, dx, F_old, I, J, L, U) result(alpha) Armijo backtracking line search for Newton-Raphson Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: dx (:) real(kind=dp), intent(in) :: F_old (:) real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U Return Value real(kind=dp) Subroutines public  subroutine solve_linear_system (A, x, b) Solves linear system A·x = b using LAPACK DGESV Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(out) :: x (:) real(kind=dp), intent(in) :: b (:) public  subroutine solve_newton (x, I, J, L, U, converged) Newton-Raphson solver for Bethe Ansatz equations Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: x (:) real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U logical, intent(out) :: converged","tags":"","url":"module/nonlinear_solvers.html"},{"title":"bethe_equations – LSDA-Hubbard-Fortran","text":"Uses lsda_constants module~~bethe_equations~~UsesGraph module~bethe_equations bethe_equations module~lsda_constants lsda_constants module~bethe_equations->module~lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~bethe_equations~~UsedByGraph module~bethe_equations bethe_equations module~bethe_tables bethe_tables module~bethe_tables->module~bethe_equations module~nonlinear_solvers nonlinear_solvers module~bethe_tables->module~nonlinear_solvers module~continuation continuation module~continuation->module~bethe_equations module~continuation->module~nonlinear_solvers module~nonlinear_solvers->module~bethe_equations Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function theta (x, U) result(res) charge-spin scattering function θ(x, U) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: U Return Value real(kind=dp) public  function Theta_capital (x, U) result(res) spin-spin scattering function Θ(x, U) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: U Return Value real(kind=dp) public  function dtheta_dx (x, U) result(res) Derivative of the charge-spin scattering function θ with respect to x Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: U Return Value real(kind=dp) public  function dTheta_capital_dx (x, U) result(res) Derivative of the function Θ with respect to x Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: U Return Value real(kind=dp) public  function dtheta_dU (x, U) result(res) Derivative of the charge-spin scattering function θ with respect to U Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: U Return Value real(kind=dp) public  function dTheta_capital_dU (x, U) result(res) Derivative of the spin-spin scattering function Θ with respect to U Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: U Return Value real(kind=dp) public  function compute_residual (k, Lambda, I, J_capital, L, U) result(F) Computes the residual vector F(x) for the Lieb-Wu equations of the 1D Hubbard model. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k (:) real(kind=dp), intent(in) :: Lambda (:) real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J_capital (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U Return Value real(kind=dp), (size(k)+size(Lambda)) public  function compute_jacobian (k, Lambda, L, U) result(Jacobian) Computes the Jacobian matrix J = ∂F/∂x for the Lieb-Wu equations. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k (:) real(kind=dp), intent(in) :: Lambda (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U Return Value real(kind=dp), (size(k)+size(Lambda),size(k)+size(Lambda)) public  function compute_dFdU (k, Lambda, I, J_capital, L, U) result(dFdU) Computes the derivative of the residual vector with respect to U: ∂F/∂U Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k (:) real(kind=dp), intent(in) :: Lambda (:) real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J_capital (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U Return Value real(kind=dp), (size(k)+size(Lambda)) public  function compute_energy (k) result(E) Computes the ground state energy from Bethe Ansatz rapidities Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k (:) Return Value real(kind=dp) Subroutines public  subroutine initialize_quantum_numbers (Nup, M, I, J_capital) Initialize quantum numbers for the ground state Arguments Type Intent Optional Attributes Name integer, intent(in) :: Nup integer, intent(in) :: M real(kind=dp), intent(out) :: I (:) real(kind=dp), intent(out) :: J_capital (:)","tags":"","url":"module/bethe_equations.html"},{"title":"potential_quasiperiodic – LSDA-Hubbard-Fortran","text":"Module for quasiperiodic potential (Aubry-André-Harper model) Uses lsda_constants module~~potential_quasiperiodic~~UsesGraph module~potential_quasiperiodic potential_quasiperiodic module~lsda_constants lsda_constants module~potential_quasiperiodic->module~lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~potential_quasiperiodic~~UsedByGraph module~potential_quasiperiodic potential_quasiperiodic module~potential_factory potential_factory module~potential_factory->module~potential_quasiperiodic Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: GOLDEN_RATIO = 0.5_dp*(sqrt(5.0_dp)-1.0_dp) Golden ratio (default for maximum incommensurability) Subroutines public  subroutine apply_potential_quasiperiodic (lambda, beta, phi, L, V, ierr) Quasiperiodic potential: V(i) = λ cos(2πβi + φ) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda real(kind=dp), intent(in) :: beta real(kind=dp), intent(in) :: phi integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr","tags":"","url":"module/potential_quasiperiodic.html"},{"title":"spline2d – LSDA-Hubbard-Fortran","text":"Uses lsda_constants module~~spline2d~~UsesGraph module~spline2d spline2d module~lsda_constants lsda_constants module~spline2d->module~lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~spline2d~~UsedByGraph module~spline2d spline2d module~xc_lsda xc_lsda module~xc_lsda->module~spline2d module~kohn_sham_cycle kohn_sham_cycle module~kohn_sham_cycle->module~xc_lsda module~input_parser input_parser module~input_parser->module~kohn_sham_cycle module~output_writer output_writer module~output_writer->module~kohn_sham_cycle module~output_writer->module~input_parser Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: spline2d_t Components Type Visibility Attributes Name Initial integer, public :: n_x Number of points in x (n) direction integer, public :: n_y_max Maximum number of points in y (m) direction real(kind=dp), public, allocatable :: x (:) Grid points in x direction: x(n_x) real(kind=dp), public, allocatable :: y (:,:) Grid points in y direction: y(n_y, n_x) - varies with x! real(kind=dp), public, allocatable :: f (:,:) Function values: f(n_y, n_x) integer, public, allocatable :: n_y (:) Number of y points for each x: n_y(n_x) real(kind=dp), public, allocatable :: d2f_dy2 (:,:) Second derivatives in y: d2f_dy2(n_y, n_x) logical, public :: initialized = .false. Initialization flag Functions private  function find_interval (x_grid, n, x) result(i) Find interval containing x in monotonic array Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x_grid (0:) integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value integer private  function spline1d_eval (x_grid, y_grid, d2y, n, x) result(y_interp) Evaluate cubic spline at point x given coefficients Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x_grid (0:) real(kind=dp), intent(in) :: y_grid (0:) real(kind=dp), intent(in) :: d2y (0:) integer, intent(in) :: n real(kind=dp), intent(in) :: x Return Value real(kind=dp) public  function spline2d_eval (spl, x, y) result(f_interp) Evaluate 2D spline at point (x, y) Arguments Type Intent Optional Attributes Name type( spline2d_t ), intent(in) :: spl real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: y Return Value real(kind=dp) Subroutines private  subroutine spline1d_coeff (x, y, n, d2y, bc_type, dy0, dyn) Compute cubic spline coefficients (second derivatives) for 1D data Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (0:) real(kind=dp), intent(in) :: y (0:) integer, intent(in) :: n real(kind=dp), intent(out) :: d2y (0:) character(len=*), intent(in) :: bc_type real(kind=dp), intent(in) :: dy0 real(kind=dp), intent(in) :: dyn public  subroutine spline2d_init (spl, x_grid, y_grid, f_values, n_y_pts) Initialize 2D spline from grid data Arguments Type Intent Optional Attributes Name type( spline2d_t ), intent(out) :: spl real(kind=dp), intent(in) :: x_grid (:) real(kind=dp), intent(in) :: y_grid (:,:) real(kind=dp), intent(in) :: f_values (:,:) integer, intent(in) :: n_y_pts (:) public  subroutine spline2d_destroy (spl) Clean up spline object Arguments Type Intent Optional Attributes Name type( spline2d_t ), intent(inout) :: spl","tags":"","url":"module/spline2d.html"},{"title":"potential_uniform – LSDA-Hubbard-Fortran","text":"Module for uniform (constant) external potential Uses lsda_constants module~~potential_uniform~~UsesGraph module~potential_uniform potential_uniform module~lsda_constants lsda_constants module~potential_uniform->module~lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~potential_uniform~~UsedByGraph module~potential_uniform potential_uniform module~potential_factory potential_factory module~potential_factory->module~potential_uniform Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine apply_potential_uniform (V0, L, V, ierr) Uniform potential: V(i) = V₀ for all i Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V0 integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr","tags":"","url":"module/potential_uniform.html"},{"title":"input_parser – LSDA-Hubbard-Fortran","text":"Module for parsing input parameters from command line and namelist files Uses lsda_constants lsda_types boundary_conditions lsda_errors kohn_sham_cycle module~~input_parser~~UsesGraph module~input_parser input_parser module~boundary_conditions boundary_conditions module~input_parser->module~boundary_conditions module~kohn_sham_cycle kohn_sham_cycle module~input_parser->module~kohn_sham_cycle module~lsda_constants lsda_constants module~input_parser->module~lsda_constants module~lsda_errors lsda_errors module~input_parser->module~lsda_errors module~lsda_types lsda_types module~input_parser->module~lsda_types module~boundary_conditions->module~lsda_constants module~boundary_conditions->module~lsda_errors module~kohn_sham_cycle->module~boundary_conditions module~kohn_sham_cycle->module~lsda_constants module~kohn_sham_cycle->module~lsda_errors module~kohn_sham_cycle->module~lsda_types module~adaptive_mixing adaptive_mixing module~kohn_sham_cycle->module~adaptive_mixing module~convergence_monitor convergence_monitor module~kohn_sham_cycle->module~convergence_monitor module~density_calculator density_calculator module~kohn_sham_cycle->module~density_calculator module~hamiltonian_builder hamiltonian_builder module~kohn_sham_cycle->module~hamiltonian_builder module~lapack_wrapper lapack_wrapper module~kohn_sham_cycle->module~lapack_wrapper module~mixing_schemes mixing_schemes module~kohn_sham_cycle->module~mixing_schemes module~xc_lsda xc_lsda module~kohn_sham_cycle->module~xc_lsda iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants module~lsda_types->module~lsda_constants module~adaptive_mixing->module~lsda_constants module~adaptive_mixing->module~lsda_errors module~convergence_monitor->module~lsda_constants module~convergence_monitor->module~lsda_errors module~density_calculator->module~lsda_constants module~density_calculator->module~lsda_errors module~hamiltonian_builder->module~boundary_conditions module~hamiltonian_builder->module~lsda_constants module~hamiltonian_builder->module~lsda_errors ieee_arithmetic ieee_arithmetic module~hamiltonian_builder->ieee_arithmetic module~lapack_wrapper->module~lsda_constants module~lapack_wrapper->module~lsda_errors module~mixing_schemes->module~lsda_constants module~mixing_schemes->module~lsda_errors module~xc_lsda->module~lsda_constants module~xc_lsda->module~lsda_errors module~spline2d spline2d module~xc_lsda->module~spline2d module~table_io table_io module~xc_lsda->module~table_io module~spline2d->module~lsda_constants module~table_io->module~lsda_constants module~table_io->module~lsda_errors module~table_io->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~input_parser~~UsedByGraph module~input_parser input_parser module~output_writer output_writer module~output_writer->module~input_parser Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: input_params_t Input parameters type Components Type Visibility Attributes Name Initial integer, public :: L = 10 integer, public :: Nup = 5 integer, public :: Ndown = 5 real(kind=dp), public :: U = 4.0_dp character(len=20), public :: bc_type = 'periodic' real(kind=dp), public :: phase = 0.0_dp character(len=20), public :: potential_type = 'uniform' real(kind=dp), public :: V0 = 0.0_dp real(kind=dp), public :: pot_center = 0.0_dp real(kind=dp), public :: pot_width = 1.0_dp real(kind=dp), public :: spring_constant = 0.001_dp real(kind=dp), public :: concentration = 50.0_dp integer, public :: pot_seed = -1 character(len=500), public :: imp_positions_str = '' real(kind=dp), public :: disorder_strength = 2.0_dp character(len=20), public :: distribution = 'gaussian' integer, public :: position = 50 integer, public :: width = 5 real(kind=dp), public :: barrier_width = 3.0_dp real(kind=dp), public :: well_depth = -3.0_dp real(kind=dp), public :: well_width = 20.0_dp integer, public :: position1 = 35 integer, public :: width1 = 3 integer, public :: position2 = 65 integer, public :: width2 = 3 integer, public :: max_iter = ITER_MAX real(kind=dp), public :: density_tol = SCF_DENSITY_TOL real(kind=dp), public :: energy_tol = SCF_ENERGY_TOL real(kind=dp), public :: mixing_alpha = MIX_ALPHA logical, public :: verbose = .true. logical, public :: store_history = .true. logical, public :: use_adaptive_mixing = .true. character(len=100), public :: output_prefix = 'lsda_output' logical, public :: save_density = .true. logical, public :: save_eigenvalues = .true. logical, public :: save_wavefunction = .false. Subroutines public  subroutine parse_inputs (inputs, ierr) Parse inputs from command line or namelist file Arguments Type Intent Optional Attributes Name type( input_params_t ), intent(out) :: inputs integer, intent(out) :: ierr private  subroutine read_namelist_file (filename, inputs, ierr) Read parameters from namelist file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( input_params_t ), intent(inout) :: inputs integer, intent(out) :: ierr public  subroutine validate_inputs (inputs, ierr) Validate input parameters Arguments Type Intent Optional Attributes Name type( input_params_t ), intent(in) :: inputs integer, intent(out) :: ierr public  subroutine convert_to_system_params (inputs, sys_params, ierr) Convert input_params_t to system_params_t Arguments Type Intent Optional Attributes Name type( input_params_t ), intent(in) :: inputs type( system_params_t ), intent(out) :: sys_params integer, intent(out) :: ierr public  subroutine convert_to_scf_params (inputs, scf_params) Convert input_params_t to scf_params_t Arguments Type Intent Optional Attributes Name type( input_params_t ), intent(in) :: inputs type( scf_params_t ), intent(out) :: scf_params private  subroutine parse_integer_arg (current_idx, nargs, value, ierr) Parse integer argument from command line Arguments Type Intent Optional Attributes Name integer, intent(in) :: current_idx integer, intent(in) :: nargs integer, intent(out) :: value integer, intent(out) :: ierr private  subroutine parse_real_arg (current_idx, nargs, value, ierr) Parse real argument from command line Arguments Type Intent Optional Attributes Name integer, intent(in) :: current_idx integer, intent(in) :: nargs real(kind=dp), intent(out) :: value integer, intent(out) :: ierr private  subroutine print_help () Print help message Arguments None","tags":"","url":"module/input_parser.html"},{"title":"potential_harmonic – LSDA-Hubbard-Fortran","text":"Module for harmonic trap potential Uses lsda_constants module~~potential_harmonic~~UsesGraph module~potential_harmonic potential_harmonic module~lsda_constants lsda_constants module~potential_harmonic->module~lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~potential_harmonic~~UsedByGraph module~potential_harmonic potential_harmonic module~potential_factory potential_factory module~potential_factory->module~potential_harmonic Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine apply_potential_harmonic (k, L, V, ierr) Harmonic trap potential: V(i) = k * (i - i_center)² Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr","tags":"","url":"module/potential_harmonic.html"},{"title":"xc_lsda – LSDA-Hubbard-Fortran","text":"Module for LSDA exchange-correlation functional evaluation Uses lsda_errors table_io spline2d lsda_constants module~~xc_lsda~~UsesGraph module~xc_lsda xc_lsda module~lsda_constants lsda_constants module~xc_lsda->module~lsda_constants module~lsda_errors lsda_errors module~xc_lsda->module~lsda_errors module~spline2d spline2d module~xc_lsda->module~spline2d module~table_io table_io module~xc_lsda->module~table_io iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants module~spline2d->module~lsda_constants module~table_io->module~lsda_constants module~table_io->module~lsda_errors module~table_io->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~xc_lsda~~UsedByGraph module~xc_lsda xc_lsda module~kohn_sham_cycle kohn_sham_cycle module~kohn_sham_cycle->module~xc_lsda module~input_parser input_parser module~input_parser->module~kohn_sham_cycle module~output_writer output_writer module~output_writer->module~kohn_sham_cycle module~output_writer->module~input_parser Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: xc_lsda_t LSDA XC functional type containing splines for exc, vxc_up, vxc_down Components Type Visibility Attributes Name Initial real(kind=dp), public :: U = 0.0_dp Hubbard U parameter type( spline2d_t ), public :: spl_exc Spline for e_xc(n, m) type( spline2d_t ), public :: spl_vxc_up Spline for V_xc&#94;up(n, m) type( spline2d_t ), public :: spl_vxc_down Spline for V_xc&#94;dn(n, m) logical, public :: initialized = .false. Initialization flag Functions private  function determine_region (n_up, n_dw) result(region) Determine symmetry region for (n_up, n_dw) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw Return Value integer Subroutines public  subroutine xc_lsda_init (xc, table_file, ierr) Initialize XC functional from table file Arguments Type Intent Optional Attributes Name type( xc_lsda_t ), intent(out) :: xc character(len=*), intent(in) :: table_file integer, intent(out) :: ierr public  subroutine get_exc (xc, n_up, n_dw, exc, ierr) Get exchange-correlation energy per particle at (n_up, n_dw) Arguments Type Intent Optional Attributes Name type( xc_lsda_t ), intent(in) :: xc real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw real(kind=dp), intent(out) :: exc integer, intent(out) :: ierr public  subroutine get_vxc (xc, n_up, n_dw, v_xc_up, v_xc_dw, ierr) Get exchange-correlation potentials at (n_up, n_dw) Arguments Type Intent Optional Attributes Name type( xc_lsda_t ), intent(in) :: xc real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw real(kind=dp), intent(out) :: v_xc_up real(kind=dp), intent(out) :: v_xc_dw integer, intent(out) :: ierr public  subroutine xc_lsda_destroy (xc) Destroy XC functional and free memory Arguments Type Intent Optional Attributes Name type( xc_lsda_t ), intent(inout) :: xc private  subroutine convert_to_nm (n_up, n_dw, n, m) Convert (n_up, n_dw) to (n, m) coordinates Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw real(kind=dp), intent(out) :: n real(kind=dp), intent(out) :: m private  subroutine apply_symmetry_transform (region, n_up, n_dw, n_up_map, n_dw_map) Apply symmetry transformation to map any region to Region I Arguments Type Intent Optional Attributes Name integer, intent(in) :: region real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw real(kind=dp), intent(out) :: n_up_map real(kind=dp), intent(out) :: n_dw_map","tags":"","url":"module/xc_lsda.html"},{"title":"lsda_errors – LSDA-Hubbard-Fortran","text":"Module for centralized error handling Uses lsda_constants module~~lsda_errors~~UsesGraph module~lsda_errors lsda_errors module~lsda_constants lsda_constants module~lsda_errors->module~lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lsda_errors~~UsedByGraph module~lsda_errors lsda_errors module~adaptive_mixing adaptive_mixing module~adaptive_mixing->module~lsda_errors module~boundary_conditions boundary_conditions module~boundary_conditions->module~lsda_errors module~convergence_monitor convergence_monitor module~convergence_monitor->module~lsda_errors module~degeneracy_handler degeneracy_handler module~degeneracy_handler->module~lsda_errors module~density_calculator density_calculator module~density_calculator->module~lsda_errors module~hamiltonian_builder hamiltonian_builder module~hamiltonian_builder->module~lsda_errors module~hamiltonian_builder->module~boundary_conditions module~input_parser input_parser module~input_parser->module~lsda_errors module~input_parser->module~boundary_conditions module~kohn_sham_cycle kohn_sham_cycle module~input_parser->module~kohn_sham_cycle module~kohn_sham_cycle->module~lsda_errors module~kohn_sham_cycle->module~adaptive_mixing module~kohn_sham_cycle->module~boundary_conditions module~kohn_sham_cycle->module~convergence_monitor module~kohn_sham_cycle->module~density_calculator module~kohn_sham_cycle->module~hamiltonian_builder module~lapack_wrapper lapack_wrapper module~kohn_sham_cycle->module~lapack_wrapper module~mixing_schemes mixing_schemes module~kohn_sham_cycle->module~mixing_schemes module~xc_lsda xc_lsda module~kohn_sham_cycle->module~xc_lsda module~lapack_wrapper->module~lsda_errors module~mixing_schemes->module~lsda_errors module~output_writer output_writer module~output_writer->module~lsda_errors module~output_writer->module~input_parser module~output_writer->module~kohn_sham_cycle module~potential_barrier potential_barrier module~potential_barrier->module~lsda_errors module~potential_factory potential_factory module~potential_factory->module~lsda_errors module~potential_factory->module~potential_barrier module~potential_impurity potential_impurity module~potential_factory->module~potential_impurity module~potential_random potential_random module~potential_factory->module~potential_random module~potential_impurity->module~lsda_errors module~potential_random->module~lsda_errors module~table_io table_io module~table_io->module~lsda_errors module~xc_lsda->module~lsda_errors module~xc_lsda->module~table_io proc~apply_potential_harmonic apply_potential_harmonic proc~apply_potential_harmonic->module~lsda_errors proc~apply_potential_quasiperiodic apply_potential_quasiperiodic proc~apply_potential_quasiperiodic->module~lsda_errors proc~apply_potential_uniform apply_potential_uniform proc~apply_potential_uniform->module~lsda_errors module~bethe_tables bethe_tables module~bethe_tables->module~table_io Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: ERROR_SUCCESS = 0 integer, public, parameter :: ERROR_INVALID_INPUT = 1 integer, public, parameter :: ERROR_OUT_OF_BOUNDS = 2 integer, public, parameter :: ERROR_SIZE_MISMATCH = 3 integer, public, parameter :: ERROR_INVALID_CONCENTRATION = 4 integer, public, parameter :: ERROR_NEGATIVE_VALUE = 5 integer, public, parameter :: ERROR_INVALID_RANGE = 6 integer, public, parameter :: ERROR_NOT_A_NUMBER = 7 integer, public, parameter :: ERROR_UNPHYSICAL_DENSITY = 8 integer, public, parameter :: ERROR_SPLINE_INITIALIZATION_FAILED = 9 integer, public, parameter :: ERROR_CONVERGENCE_FAILED = 100 integer, public, parameter :: ERROR_SINGULAR_MATRIX = 101 integer, public, parameter :: ERROR_LAPACK_FAILED = 102 integer, public, parameter :: ERROR_LAPACK_INVALID_ARG = 103 integer, public, parameter :: ERROR_LINEAR_DEPENDENCE = 104 integer, public, parameter :: ERROR_FILE_NOT_FOUND = 200 integer, public, parameter :: ERROR_FILE_READ = 201 integer, public, parameter :: ERROR_FILE_WRITE = 202 integer, public, parameter :: ERROR_ALLOCATION_FAILED = 300 integer, public, parameter :: ERROR_DEALLOCATION_FAILED = 301 Functions public  function get_error_message (ierr) result(msg) Get human-readable error message for a given error code Arguments Type Intent Optional Attributes Name integer, intent(in) :: ierr Return Value character(len=256) Subroutines public  subroutine error_handler (ierr, routine_name, extra_info, fatal) Generic error handler that prints error messages Arguments Type Intent Optional Attributes Name integer, intent(in) :: ierr character(len=*), intent(in) :: routine_name character(len=*), intent(in), optional :: extra_info logical, intent(in), optional :: fatal public  subroutine check_bounds (val, min_val, max_val, ierr) Check if a value is within bounds [min_val, max_val] Arguments Type Intent Optional Attributes Name integer, intent(in) :: val integer, intent(in) :: min_val integer, intent(in) :: max_val integer, intent(out) :: ierr public  subroutine check_positive (val, allow_zero, ierr) Check if a value is positive (> 0) or non-negative (>= 0) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val logical, intent(in) :: allow_zero integer, intent(out) :: ierr public  subroutine check_range (val, min_val, max_val, ierr) Check if a value is within a real range [min_val, max_val] Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val real(kind=dp), intent(in) :: min_val real(kind=dp), intent(in) :: max_val integer, intent(out) :: ierr","tags":"","url":"module/lsda_errors.html"},{"title":"hamiltonian_builder – LSDA-Hubbard-Fortran","text":"Uses boundary_conditions lsda_errors ieee_arithmetic lsda_constants module~~hamiltonian_builder~~UsesGraph module~hamiltonian_builder hamiltonian_builder ieee_arithmetic ieee_arithmetic module~hamiltonian_builder->ieee_arithmetic module~boundary_conditions boundary_conditions module~hamiltonian_builder->module~boundary_conditions module~lsda_constants lsda_constants module~hamiltonian_builder->module~lsda_constants module~lsda_errors lsda_errors module~hamiltonian_builder->module~lsda_errors module~boundary_conditions->module~lsda_constants module~boundary_conditions->module~lsda_errors iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hamiltonian_builder~~UsedByGraph module~hamiltonian_builder hamiltonian_builder module~kohn_sham_cycle kohn_sham_cycle module~kohn_sham_cycle->module~hamiltonian_builder module~input_parser input_parser module~input_parser->module~kohn_sham_cycle module~output_writer output_writer module~output_writer->module~kohn_sham_cycle module~output_writer->module~input_parser Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine validate_hamiltonian_inputs (L, V_ext, V_xc, ierr) Validate Hamiltonian construction inputs Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: L real(kind=dp), intent(in) :: V_ext (:) real(kind=dp), intent(in) :: V_xc (:) integer, intent(out) :: ierr public  subroutine build_hamiltonian (L, V_ext, V_xc, bc_type, theta, H, ierr) Build tight-binding Hamiltonian with external and XC potentials (real) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: L real(kind=dp), intent(in) :: V_ext (:) real(kind=dp), intent(in) :: V_xc (:) integer, intent(in) :: bc_type real(kind=dp), intent(in), optional :: theta real(kind=dp), intent(out) :: H (:,:) integer, intent(out) :: ierr public  subroutine build_hamiltonian_complex (L, V_ext, V_xc, bc_type, theta, H, ierr) Build tight-binding Hamiltonian with external and XC potentials (complex) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: L real(kind=dp), intent(in) :: V_ext (:) real(kind=dp), intent(in) :: V_xc (:) integer, intent(in) :: bc_type real(kind=dp), intent(in) :: theta complex(kind=dp), intent(out) :: H (:,:) integer, intent(out) :: ierr public  subroutine build_hamiltonian_free (L, bc_type, theta, H, ierr) Build free-particle Hamiltonian (U=0, V=0) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: L integer, intent(in) :: bc_type real(kind=dp), intent(in), optional :: theta real(kind=dp), intent(out) :: H (:,:) integer, intent(out) :: ierr public  subroutine compute_effective_potential (V_ext, V_xc, V_eff, ierr) Compute effective potential V_eff = V_ext + V_xc Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_ext (:) real(kind=dp), intent(in) :: V_xc (:) real(kind=dp), intent(out) :: V_eff (:) integer, intent(out) :: ierr","tags":"","url":"module/hamiltonian_builder.html"},{"title":"mixing_schemes – LSDA-Hubbard-Fortran","text":"Uses lsda_errors lsda_constants module~~mixing_schemes~~UsesGraph module~mixing_schemes mixing_schemes module~lsda_constants lsda_constants module~mixing_schemes->module~lsda_constants module~lsda_errors lsda_errors module~mixing_schemes->module~lsda_errors iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~mixing_schemes~~UsedByGraph module~mixing_schemes mixing_schemes module~kohn_sham_cycle kohn_sham_cycle module~kohn_sham_cycle->module~mixing_schemes module~input_parser input_parser module~input_parser->module~kohn_sham_cycle module~output_writer output_writer module~output_writer->module~kohn_sham_cycle module~output_writer->module~input_parser Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine linear_mixing (n_new, n_old, alpha, n_mixed, L, ierr) Linear density mixing for SCF convergence Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_new (:) real(kind=dp), intent(in) :: n_old (:) real(kind=dp), intent(in) :: alpha real(kind=dp), intent(out) :: n_mixed (:) integer, intent(in) :: L integer, intent(out) :: ierr","tags":"","url":"module/mixing_schemes.html"},{"title":"degeneracy_handler – LSDA-Hubbard-Fortran","text":"Uses lsda_errors lsda_constants module~~degeneracy_handler~~UsesGraph module~degeneracy_handler degeneracy_handler module~lsda_constants lsda_constants module~degeneracy_handler->module~lsda_constants module~lsda_errors lsda_errors module~degeneracy_handler->module~lsda_errors iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: DEG_TOL = 1.0e-8_dp Interfaces interface private  subroutine DGEQRF(M, N, A, LDA, TAU, WORK, LWORK, INFO) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N real(kind=dp), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA real(kind=dp), intent(out) :: TAU (*) real(kind=dp), intent(inout) :: WORK (*) integer, intent(in) :: LWORK integer, intent(out) :: INFO interface private  subroutine DORGQR(M, N, K, A, LDA, TAU, WORK, LWORK, INFO) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K real(kind=dp), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA real(kind=dp), intent(in) :: TAU (*) real(kind=dp), intent(inout) :: WORK (*) integer, intent(in) :: LWORK integer, intent(out) :: INFO interface private  subroutine DGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K real(kind=dp), intent(in) :: ALPHA real(kind=dp), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=dp), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=dp), intent(in) :: BETA real(kind=dp), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC Functions public  function compute_degeneracy_count (eigvals, L, index) result(deg_count) Count number of eigenvalues degenerate with given index Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigvals (:) integer, intent(in) :: L integer, intent(in) :: index Return Value integer Subroutines public  subroutine find_degenerate_subspaces (eigvals, L, subspaces, subspaces_sizes, n_subspaces, ierr) Find all degenerate subspaces in eigenvalue spectrum Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigvals (:) integer, intent(in) :: L integer, intent(out), allocatable :: subspaces (:,:) integer, intent(out), allocatable :: subspaces_sizes (:) integer, intent(out) :: n_subspaces integer, intent(out) :: ierr public  subroutine orthonormalize_degenerate_subspace (eigvecs, L, indexes, n_deg, ierr) Re-orthonormalize degenerate subspace using LAPACK QR Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: eigvecs (:,:) integer, intent(in) :: L integer, intent(in) :: indexes (:) integer, intent(in) :: n_deg integer, intent(out) :: ierr public  subroutine orthonormalize_degenerate_subspace_complex (eigvecs, L, indexes, n_deg, ierr) Re-orthonormalize complex degenerate subspace using Gram-Schmidt Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: eigvecs (:,:) integer, intent(in) :: L integer, intent(in) :: indexes (:) integer, intent(in) :: n_deg integer, intent(out) :: ierr public  subroutine verify_orthonormality (eigvecs, L, is_orthonormal, max_deviation, ierr) Verify eigenvectors are orthonormal Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigvecs (:,:) integer, intent(in) :: L logical, intent(out) :: is_orthonormal real(kind=dp), intent(out) :: max_deviation integer, intent(out) :: ierr","tags":"","url":"module/degeneracy_handler.html"},{"title":"convergence_monitor – LSDA-Hubbard-Fortran","text":"Uses lsda_errors lsda_constants module~~convergence_monitor~~UsesGraph module~convergence_monitor convergence_monitor module~lsda_constants lsda_constants module~convergence_monitor->module~lsda_constants module~lsda_errors lsda_errors module~convergence_monitor->module~lsda_errors iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~convergence_monitor~~UsedByGraph module~convergence_monitor convergence_monitor module~kohn_sham_cycle kohn_sham_cycle module~kohn_sham_cycle->module~convergence_monitor module~input_parser input_parser module~input_parser->module~kohn_sham_cycle module~output_writer output_writer module~output_writer->module~kohn_sham_cycle module~output_writer->module~input_parser Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Enumerations enum, bind(c) Enumerators enumerator :: L1 = 1 enumerator :: L2 = 2 enumerator :: Linf = 3 Derived Types type, public :: convergence_history_t Components Type Visibility Attributes Name Initial integer, public :: max_iter integer, public :: current_iter real(kind=dp), public, allocatable :: density_norms (:) real(kind=dp), public, allocatable :: energies (:) Subroutines public  subroutine compute_density_difference (n_new, n_old, L, diff, ierr) Compute difference between new and old densities Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_new (:) real(kind=dp), intent(in) :: n_old (:) integer, intent(in) :: L real(kind=dp), intent(out) :: diff (:) integer, intent(out) :: ierr public  subroutine compute_density_norm (delta_n, L, norm_type, norm_value, ierr) Compute norm of density difference Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: delta_n (:) integer, intent(in) :: L integer, intent(in) :: norm_type real(kind=dp), intent(out) :: norm_value integer, intent(out) :: ierr public  subroutine check_scf_convergence (delta_n, L, tol, is_converged, ierr) Check if SCF iteration has converged Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: delta_n (:) integer, intent(in) :: L real(kind=dp), intent(in), optional :: tol logical, intent(out) :: is_converged integer, intent(out) :: ierr public  subroutine update_convergence_history (iteration, norm, energy, history, ierr) Update convergence history with current iteration data Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: iteration real(kind=dp), intent(in) :: norm real(kind=dp), intent(in) :: energy type( convergence_history_t ), intent(inout) :: history integer, intent(out) :: ierr public  subroutine init_convergence_history (history, max_iter, ierr) Initialize convergence history storage Read more… Arguments Type Intent Optional Attributes Name type( convergence_history_t ), intent(out) :: history integer, intent(in) :: max_iter integer, intent(out) :: ierr public  subroutine cleanup_convergence_history (history, ierr) Deallocate convergence history Read more… Arguments Type Intent Optional Attributes Name type( convergence_history_t ), intent(inout) :: history integer, intent(out) :: ierr","tags":"","url":"module/convergence_monitor.html"},{"title":"potential_factory – LSDA-Hubbard-Fortran","text":"Module for potential factory pattern Uses potential_random potential_impurity potential_quasiperiodic potential_uniform potential_barrier potential_harmonic lsda_constants lsda_errors module~~potential_factory~~UsesGraph module~potential_factory potential_factory module~lsda_constants lsda_constants module~potential_factory->module~lsda_constants module~lsda_errors lsda_errors module~potential_factory->module~lsda_errors module~potential_barrier potential_barrier module~potential_factory->module~potential_barrier module~potential_harmonic potential_harmonic module~potential_factory->module~potential_harmonic module~potential_impurity potential_impurity module~potential_factory->module~potential_impurity module~potential_quasiperiodic potential_quasiperiodic module~potential_factory->module~potential_quasiperiodic module~potential_random potential_random module~potential_factory->module~potential_random module~potential_uniform potential_uniform module~potential_factory->module~potential_uniform iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants module~potential_barrier->module~lsda_constants module~potential_barrier->module~lsda_errors module~potential_harmonic->module~lsda_constants module~potential_impurity->module~lsda_constants module~potential_impurity->module~lsda_errors module~potential_quasiperiodic->module~lsda_constants module~potential_random->module~lsda_constants module~potential_random->module~lsda_errors module~potential_uniform->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function get_potential_info (potential_type) result(info) Get information about a potential type Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: potential_type Return Value character(len=512) Subroutines public  subroutine create_potential (potential_type, params, L, seed, V, ierr) Factory function to create any potential type Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: potential_type real(kind=dp), intent(in) :: params (:) integer, intent(in) :: L integer, intent(in) :: seed real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr","tags":"","url":"module/potential_factory.html"},{"title":"potential_impurity – LSDA-Hubbard-Fortran","text":"Module for point impurity potentials Uses lsda_errors lsda_constants module~~potential_impurity~~UsesGraph module~potential_impurity potential_impurity module~lsda_constants lsda_constants module~potential_impurity->module~lsda_constants module~lsda_errors lsda_errors module~potential_impurity->module~lsda_errors iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~potential_impurity~~UsedByGraph module~potential_impurity potential_impurity module~potential_factory potential_factory module~potential_factory->module~potential_impurity Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine potential_impurity_single (V_imp, i_imp, L, V, ierr) Single point impurity: V(i) = V_imp if i = i_imp, else 0 Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_imp integer, intent(in) :: i_imp integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr public  subroutine potential_impurity_multiple (V_imp_array, imp_positions, L, V, ierr) Multiple point impurities with individual amplitudes Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_imp_array (:) integer, intent(in) :: imp_positions (:) integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr public  subroutine potential_impurity_random (V_imp, concentration, L, seed, V, imp_positions, ierr) Random impurities with fixed concentration Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_imp real(kind=dp), intent(in) :: concentration integer, intent(in) :: L integer, intent(in) :: seed real(kind=dp), intent(out), dimension(L) :: V integer, intent(out), allocatable :: imp_positions (:) integer, intent(out) :: ierr private  subroutine sort_array (arr) Simple insertion sort for small arrays Arguments Type Intent Optional Attributes Name integer, intent(inout) :: arr (:)","tags":"","url":"module/potential_impurity.html"},{"title":"lsda_types – LSDA-Hubbard-Fortran","text":"Derived types for LSDA-Hubbard calculations Uses lsda_constants module~~lsda_types~~UsesGraph module~lsda_types lsda_types module~lsda_constants lsda_constants module~lsda_types->module~lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lsda_types~~UsedByGraph module~lsda_types lsda_types module~input_parser input_parser module~input_parser->module~lsda_types module~kohn_sham_cycle kohn_sham_cycle module~input_parser->module~kohn_sham_cycle module~kohn_sham_cycle->module~lsda_types module~output_writer output_writer module~output_writer->module~lsda_types module~output_writer->module~input_parser module~output_writer->module~kohn_sham_cycle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: system_params_t System parameters for LSDA-Hubbard calculations Components Type Visibility Attributes Name Initial integer, public :: L Number of lattice sites integer, public :: Nup Number of spin-up electrons (N↑) integer, public :: Ndown Number of spin-down electrons (N↓) integer, public :: bc Boundary conditions: 0=open, 1=periodic, 2=twisted real(kind=dp), public :: U Hubbard interaction strength (in units of hopping t=1) real(kind=dp), public :: phase Twist angle for twisted BC (in units of π), only used if bc=2","tags":"","url":"module/lsda_types.html"},{"title":"bethe_tables – LSDA-Hubbard-Fortran","text":"Module for generating exchange-correlation functional tables Uses lsda_constants nonlinear_solvers ieee_arithmetic table_io bethe_equations module~~bethe_tables~~UsesGraph module~bethe_tables bethe_tables ieee_arithmetic ieee_arithmetic module~bethe_tables->ieee_arithmetic module~bethe_equations bethe_equations module~bethe_tables->module~bethe_equations module~lsda_constants lsda_constants module~bethe_tables->module~lsda_constants module~nonlinear_solvers nonlinear_solvers module~bethe_tables->module~nonlinear_solvers module~table_io table_io module~bethe_tables->module~table_io module~bethe_equations->module~lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~nonlinear_solvers->ieee_arithmetic module~nonlinear_solvers->module~bethe_equations module~nonlinear_solvers->module~lsda_constants module~table_io->module~lsda_constants module~table_io->iso_fortran_env module~lsda_errors lsda_errors module~table_io->module~lsda_errors module~lsda_errors->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: grid_params_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: n_min = 0.1_dp Minimum density real(kind=dp), public :: n_max = 2.0_dp Maximum density integer, public :: n_points = 50 Number of density points integer, public :: m_points = 51 Number of magnetization points (per n) integer, public :: L = 100 System size real(kind=dp), public :: delta_n = 1.0e-4_dp Finite difference increment type, public :: xc_potentials_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: v_xc_up real(kind=dp), public :: v_xc_down Functions public  function compute_E0 (n_up, n_dw, L) result(E0) Compute non-interacting energy (U=0, free Fermi gas) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw integer, intent(in) :: L Return Value real(kind=dp) public  function compute_E_xc (n_up, n_dn, U, L) result(E_xc) Compute exchange-correlation energy: E_xc = E_BA - E_0 Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dn real(kind=dp), intent(in) :: U integer, intent(in) :: L Return Value real(kind=dp) public  function compute_V_xc_numerical (n_up, n_dw, U, L) result(v_xc) Compute XC potentials via numerical derivatives (central finite differences) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: n_up real(kind=dp), intent(in) :: n_dw real(kind=dp), intent(in) :: U integer, intent(in) :: L Return Value type( xc_potentials_t ) Subroutines public  subroutine generate_xc_table (U, params, table, status) Generate complete XC table for a single U value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: U type( grid_params_t ), intent(in) :: params type( xc_table_t ), intent(out) :: table integer, intent(out) :: status public  subroutine generate_table_grid (U_values, params, output_dir, status) Generate multiple XC tables using continuation method in U Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: U_values (:) type( grid_params_t ), intent(in) :: params character(len=*), intent(in) :: output_dir integer, intent(out) :: status","tags":"","url":"module/bethe_tables.html"},{"title":"potential_barrier – LSDA-Hubbard-Fortran","text":"Module for barrier potentials Uses lsda_errors lsda_constants module~~potential_barrier~~UsesGraph module~potential_barrier potential_barrier module~lsda_constants lsda_constants module~potential_barrier->module~lsda_constants module~lsda_errors lsda_errors module~potential_barrier->module~lsda_errors iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~potential_barrier~~UsedByGraph module~potential_barrier potential_barrier module~potential_factory potential_factory module~potential_factory->module~potential_barrier Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine potential_barrier_single (V_bar, i_start, i_end, L, V, ierr) Single rectangular barrier: V(i) = V_bar for i_start ≤ i ≤ i_end, else 0 Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_bar integer, intent(in) :: i_start integer, intent(in) :: i_end integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr public  subroutine potential_barrier_double (V_bar, L_bar, V_well, L_well, L, V, ierr) Double rectangular barrier: Two barriers creating a quantum well Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: V_bar real(kind=dp), intent(in) :: L_bar real(kind=dp), intent(in) :: V_well real(kind=dp), intent(in) :: L_well integer, intent(in) :: L real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr","tags":"","url":"module/potential_barrier.html"},{"title":"lsda_constants – LSDA-Hubbard-Fortran","text":"Physical and numerical constants for LSDA-Hubbard calculations Uses iso_fortran_env module~~lsda_constants~~UsesGraph module~lsda_constants lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lsda_constants~~UsedByGraph module~lsda_constants lsda_constants module~adaptive_mixing adaptive_mixing module~adaptive_mixing->module~lsda_constants module~lsda_errors lsda_errors module~adaptive_mixing->module~lsda_errors module~bethe_equations bethe_equations module~bethe_equations->module~lsda_constants module~bethe_tables bethe_tables module~bethe_tables->module~lsda_constants module~bethe_tables->module~bethe_equations module~nonlinear_solvers nonlinear_solvers module~bethe_tables->module~nonlinear_solvers module~table_io table_io module~bethe_tables->module~table_io module~boundary_conditions boundary_conditions module~boundary_conditions->module~lsda_constants module~boundary_conditions->module~lsda_errors module~continuation continuation module~continuation->module~lsda_constants module~continuation->module~bethe_equations module~continuation->module~nonlinear_solvers module~convergence_monitor convergence_monitor module~convergence_monitor->module~lsda_constants module~convergence_monitor->module~lsda_errors module~degeneracy_handler degeneracy_handler module~degeneracy_handler->module~lsda_constants module~degeneracy_handler->module~lsda_errors module~density_calculator density_calculator module~density_calculator->module~lsda_constants module~density_calculator->module~lsda_errors module~hamiltonian_builder hamiltonian_builder module~hamiltonian_builder->module~lsda_constants module~hamiltonian_builder->module~boundary_conditions module~hamiltonian_builder->module~lsda_errors module~input_parser input_parser module~input_parser->module~lsda_constants module~input_parser->module~boundary_conditions module~kohn_sham_cycle kohn_sham_cycle module~input_parser->module~kohn_sham_cycle module~input_parser->module~lsda_errors module~lsda_types lsda_types module~input_parser->module~lsda_types module~kohn_sham_cycle->module~lsda_constants module~kohn_sham_cycle->module~adaptive_mixing module~kohn_sham_cycle->module~boundary_conditions module~kohn_sham_cycle->module~convergence_monitor module~kohn_sham_cycle->module~density_calculator module~kohn_sham_cycle->module~hamiltonian_builder module~lapack_wrapper lapack_wrapper module~kohn_sham_cycle->module~lapack_wrapper module~kohn_sham_cycle->module~lsda_errors module~kohn_sham_cycle->module~lsda_types module~mixing_schemes mixing_schemes module~kohn_sham_cycle->module~mixing_schemes module~xc_lsda xc_lsda module~kohn_sham_cycle->module~xc_lsda module~lapack_wrapper->module~lsda_constants module~lapack_wrapper->module~lsda_errors module~lsda_errors->module~lsda_constants module~lsda_types->module~lsda_constants module~mixing_schemes->module~lsda_constants module~mixing_schemes->module~lsda_errors module~nonlinear_solvers->module~lsda_constants module~nonlinear_solvers->module~bethe_equations module~output_writer output_writer module~output_writer->module~lsda_constants module~output_writer->module~input_parser module~output_writer->module~kohn_sham_cycle module~output_writer->module~lsda_errors module~output_writer->module~lsda_types module~potential_barrier potential_barrier module~potential_barrier->module~lsda_constants module~potential_barrier->module~lsda_errors module~potential_factory potential_factory module~potential_factory->module~lsda_constants module~potential_factory->module~lsda_errors module~potential_factory->module~potential_barrier module~potential_harmonic potential_harmonic module~potential_factory->module~potential_harmonic module~potential_impurity potential_impurity module~potential_factory->module~potential_impurity module~potential_quasiperiodic potential_quasiperiodic module~potential_factory->module~potential_quasiperiodic module~potential_random potential_random module~potential_factory->module~potential_random module~potential_uniform potential_uniform module~potential_factory->module~potential_uniform module~potential_harmonic->module~lsda_constants module~potential_impurity->module~lsda_constants module~potential_impurity->module~lsda_errors module~potential_quasiperiodic->module~lsda_constants module~potential_random->module~lsda_constants module~potential_random->module~lsda_errors module~potential_uniform->module~lsda_constants module~spline2d spline2d module~spline2d->module~lsda_constants module~table_io->module~lsda_constants module~table_io->module~lsda_errors module~xc_lsda->module~lsda_constants module~xc_lsda->module~lsda_errors module~xc_lsda->module~spline2d module~xc_lsda->module~table_io proc~apply_potential_harmonic apply_potential_harmonic proc~apply_potential_harmonic->module~lsda_errors proc~apply_potential_quasiperiodic apply_potential_quasiperiodic proc~apply_potential_quasiperiodic->module~lsda_errors proc~apply_potential_uniform apply_potential_uniform proc~apply_potential_uniform->module~lsda_errors Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = real64 integer, public, parameter :: sp = int32 real(kind=dp), public, parameter :: PI = 4.0_dp*atan(1.0_dp) real(kind=dp), public, parameter :: TWOPI = 2.0_dp*PI real(kind=dp), public, parameter :: U_SMALL = 1.0e-9_dp real(kind=dp), public, parameter :: TOL_DEFAULT = 1.0e-16_dp integer, public, parameter :: ITER_MAX = 10000 real(kind=dp), public, parameter :: INITIAL_MIX = 0.95_dp real(kind=dp), public, parameter :: MIX_ALPHA = 1.0_dp-INITIAL_MIX real(kind=dp), public, parameter :: NEWTON_TOL = 1.0e-10_dp integer, public, parameter :: NEWTON_MAX_ITER = 50 real(kind=dp), public, parameter :: SCF_ENERGY_TOL = 1.0e-8_dp real(kind=dp), public, parameter :: SCF_DENSITY_TOL = 1.0e-6_dp","tags":"","url":"module/lsda_constants.html"},{"title":"lapack_wrapper – LSDA-Hubbard-Fortran","text":"Uses lsda_errors lsda_constants module~~lapack_wrapper~~UsesGraph module~lapack_wrapper lapack_wrapper module~lsda_constants lsda_constants module~lapack_wrapper->module~lsda_constants module~lsda_errors lsda_errors module~lapack_wrapper->module~lsda_errors iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lapack_wrapper~~UsedByGraph module~lapack_wrapper lapack_wrapper module~kohn_sham_cycle kohn_sham_cycle module~kohn_sham_cycle->module~lapack_wrapper module~input_parser input_parser module~input_parser->module~kohn_sham_cycle module~output_writer output_writer module~output_writer->module~kohn_sham_cycle module~output_writer->module~input_parser Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface private  subroutine DSYEVD(jobz, uplo, n, a, lda, w, work, lwork, iwork, liwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n real(kind=dp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=dp), intent(out) :: w (*) real(kind=dp), intent(out) :: work (*) integer, intent(in) :: lwork integer, intent(out) :: iwork (*) integer, intent(in) :: liwork integer, intent(out) :: info interface private  subroutine ZHEEVD(jobz, uplo, n, a, lda, w, work, lwork, rwork, lrwork, iwork, liwork, info) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: jobz character(len=1), intent(in) :: uplo integer, intent(in) :: n complex(kind=dp), intent(inout) :: a (lda,*) integer, intent(in) :: lda real(kind=dp), intent(out) :: w (*) complex(kind=dp), intent(out) :: work (*) integer, intent(in) :: lwork real(kind=dp), intent(out) :: rwork (*) integer, intent(in) :: lrwork integer, intent(out) :: iwork (*) integer, intent(in) :: liwork integer, intent(out) :: info Subroutines public  subroutine validate_diagonalization_inputs (L, H, eigvals, eigvecs, compute_vectors, ierr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: L real(kind=dp), intent(in) :: H (:,:) real(kind=dp), intent(in) :: eigvals (:) real(kind=dp), intent(in), optional :: eigvecs (:,:) logical, intent(in) :: compute_vectors integer, intent(out) :: ierr public  subroutine diagonalize_symmetric_real (H, L, eigvals, eigvecs, ierr) Diagonalize real symmetric matrix (eigenvalues + eigenvectors) Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: H (:,:) integer, intent(in) :: L real(kind=dp), intent(out) :: eigvals (:) real(kind=dp), intent(out) :: eigvecs (:,:) integer, intent(out) :: ierr public  subroutine diagonalize_symmetric_real_values_only (H, L, eigvals, ierr) Diagonalize real symmetric matrix (eigenvalues only) Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: H (:,:) integer, intent(in) :: L real(kind=dp), intent(out) :: eigvals (:) integer, intent(out) :: ierr public  subroutine diagonalize_hermitian_complex (H, L, eigvals, eigvecs, ierr) Diagonalize complex Hermitian matrix (eigenvalues + eigenvectors) Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: H (:,:) integer, intent(in) :: L real(kind=dp), intent(out) :: eigvals (:) complex(kind=dp), intent(out) :: eigvecs (:,:) integer, intent(out) :: ierr public  subroutine diagonalize_hermitian_complex_values_only (H, L, eigvals, ierr) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: H (:,:) integer, intent(in) :: L real(kind=dp), intent(out) :: eigvals (:) integer, intent(out) :: ierr","tags":"","url":"module/lapack_wrapper.html"},{"title":"table_io – LSDA-Hubbard-Fortran","text":"Input/output routines for XC functional tables Uses lsda_errors iso_fortran_env lsda_constants module~~table_io~~UsesGraph module~table_io table_io iso_fortran_env iso_fortran_env module~table_io->iso_fortran_env module~lsda_constants lsda_constants module~table_io->module~lsda_constants module~lsda_errors lsda_errors module~table_io->module~lsda_errors module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~table_io~~UsedByGraph module~table_io table_io module~bethe_tables bethe_tables module~bethe_tables->module~table_io module~xc_lsda xc_lsda module~xc_lsda->module~table_io module~kohn_sham_cycle kohn_sham_cycle module~kohn_sham_cycle->module~xc_lsda module~input_parser input_parser module~input_parser->module~kohn_sham_cycle module~output_writer output_writer module~output_writer->module~kohn_sham_cycle module~output_writer->module~input_parser Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_LINE_LEN = 256 Derived Types type, public :: xc_table_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: U integer, public :: n_points_n integer, public :: n_points_m real(kind=dp), public, allocatable :: n_grid (:) real(kind=dp), public, allocatable :: m_grid (:,:) real(kind=dp), public, allocatable :: exc (:,:) real(kind=dp), public, allocatable :: vxc_up (:,:) real(kind=dp), public, allocatable :: vxc_down (:,:) Subroutines public  subroutine read_cpp_table (filename, table, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( xc_table_t ), intent(out) :: table integer, intent(out) :: ierr private  subroutine count_blocks_and_points (filename, n_blocks, n_mag_points, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(out) :: n_blocks integer, intent(out) :: n_mag_points integer, intent(out) :: ierr public  subroutine extract_U_from_filename (filename, U, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(out) :: U integer, intent(out) :: ierr public  subroutine write_fortran_table (filename, table, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( xc_table_t ), intent(in) :: table integer, intent(out) :: ierr public  subroutine read_fortran_table (filename, table, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( xc_table_t ), intent(out) :: table integer, intent(out) :: ierr public  subroutine deallocate_table (table) Arguments Type Intent Optional Attributes Name type( xc_table_t ), intent(inout) :: table public  subroutine print_table_info (table, unit) Arguments Type Intent Optional Attributes Name type( xc_table_t ), intent(in) :: table integer, intent(in), optional :: unit","tags":"","url":"module/table_io.html"},{"title":"potential_random – LSDA-Hubbard-Fortran","text":"Module for random (disorder) potentials Uses lsda_errors lsda_constants module~~potential_random~~UsesGraph module~potential_random potential_random module~lsda_constants lsda_constants module~potential_random->module~lsda_constants module~lsda_errors lsda_errors module~potential_random->module~lsda_errors iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~potential_random~~UsedByGraph module~potential_random potential_random module~potential_factory potential_factory module~potential_factory->module~potential_random Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine potential_random_uniform (W, L, seed, V, ierr) Random potential with uniform distribution: V(i) ~ U[-W, W] Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: W integer, intent(in) :: L integer, intent(in) :: seed real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr public  subroutine potential_random_gaussian (sigma, L, seed, V, ierr) Random potential with Gaussian distribution: V(i) ~ N(0, σ²) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sigma integer, intent(in) :: L integer, intent(in) :: seed real(kind=dp), intent(out), dimension(L) :: V integer, intent(out) :: ierr","tags":"","url":"module/potential_random.html"},{"title":"boundary_conditions – LSDA-Hubbard-Fortran","text":"Uses lsda_errors lsda_constants module~~boundary_conditions~~UsesGraph module~boundary_conditions boundary_conditions module~lsda_constants lsda_constants module~boundary_conditions->module~lsda_constants module~lsda_errors lsda_errors module~boundary_conditions->module~lsda_errors iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~boundary_conditions~~UsedByGraph module~boundary_conditions boundary_conditions module~hamiltonian_builder hamiltonian_builder module~hamiltonian_builder->module~boundary_conditions module~input_parser input_parser module~input_parser->module~boundary_conditions module~kohn_sham_cycle kohn_sham_cycle module~input_parser->module~kohn_sham_cycle module~kohn_sham_cycle->module~boundary_conditions module~kohn_sham_cycle->module~hamiltonian_builder module~output_writer output_writer module~output_writer->module~input_parser module~output_writer->module~kohn_sham_cycle Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Enumerations enum, bind(c) Enumerators enumerator :: BC_OPEN = 1 enumerator :: BC_PERIODIC = 2 enumerator :: BC_TWISTED = 3 Subroutines public  subroutine validate_bc_parameters (bc_type, theta, L, ierr) Validate boundary condition parameters Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: bc_type real(kind=dp), intent(in), optional :: theta integer, intent(in) :: L integer, intent(out) :: ierr public  subroutine apply_boundary_conditions (H, L, bc_type, theta, ierr) Apply boundary conditions to real Hamiltonian matrix Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: H (:,:) integer, intent(in) :: L integer, intent(in) :: bc_type real(kind=dp), intent(in), optional :: theta integer, intent(out) :: ierr public  subroutine apply_boundary_conditions_complex (H, L, bc_type, theta, ierr) Apply boundary conditions to complex Hamiltonian matrix Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: H (:,:) integer, intent(in) :: L integer, intent(in) :: bc_type real(kind=dp), intent(in), optional :: theta integer, intent(out) :: ierr public  subroutine get_free_particle_eigenvalues (L, bc_type, theta, eigenvalues, ierr) Calculate analytical eigenvalues for free particles (U=0, V=0) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: L integer, intent(in) :: bc_type real(kind=dp), intent(in), optional :: theta real(kind=dp), intent(out) :: eigenvalues (:) integer, intent(out) :: ierr","tags":"","url":"module/boundary_conditions.html"},{"title":"adaptive_mixing – LSDA-Hubbard-Fortran","text":"Adaptive mixing scheme for SCF convergence Uses lsda_errors lsda_constants module~~adaptive_mixing~~UsesGraph module~adaptive_mixing adaptive_mixing module~lsda_constants lsda_constants module~adaptive_mixing->module~lsda_constants module~lsda_errors lsda_errors module~adaptive_mixing->module~lsda_errors iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~adaptive_mixing~~UsedByGraph module~adaptive_mixing adaptive_mixing module~kohn_sham_cycle kohn_sham_cycle module~kohn_sham_cycle->module~adaptive_mixing module~input_parser input_parser module~input_parser->module~kohn_sham_cycle module~output_writer output_writer module~output_writer->module~kohn_sham_cycle module~output_writer->module~input_parser Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: adaptive_mix_t Adaptive mixing control parameters Components Type Visibility Attributes Name Initial integer, public :: iter = 0 Current iteration integer, public :: count_sc = 0 Count within energy band integer, public :: count_bot = 0 Count when hitting bottom integer, public :: count_top = 0 Count when hitting top integer, public :: count_sc_max = 10 Max iterations in band before UpMix real(kind=dp), public :: mix = INITIAL_MIX Current mixing parameter (C++ convention) real(kind=dp), public :: energy_top = 0.0_dp Upper energy bound real(kind=dp), public :: energy_bot = 0.0_dp Lower energy bound real(kind=dp), public :: energy_new = 0.0_dp Current energy real(kind=dp), public :: energy_old = 0.0_dp Previous energy real(kind=dp), public :: tol = 1.0e-8_dp Convergence tolerance logical, public :: converged = .false. Convergence flag Functions public  function adaptive_mix_get_alpha (mix_ctrl) result(alpha) Get alpha (Fortran convention) from mix (C++ convention) Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(in) :: mix_ctrl Return Value real(kind=dp) Subroutines public  subroutine adaptive_mix_init (mix_ctrl, tol) Initialize adaptive mixing Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(out) :: mix_ctrl real(kind=dp), intent(in), optional :: tol public  subroutine adaptive_mix_update (mix_ctrl, energy) Update adaptive mixing based on new energy Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(inout) :: mix_ctrl real(kind=dp), intent(in) :: energy public  subroutine adaptive_mix_reset (mix_ctrl) Reset adaptive mixing counters (keep Mix value) Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(inout) :: mix_ctrl private  subroutine up_mix (mix_ctrl) Increase mixing parameter (more conservative) Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(inout) :: mix_ctrl private  subroutine dw_mix (mix_ctrl) Decrease mixing parameter (more aggressive) Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(inout) :: mix_ctrl private  subroutine reset_counts (mix_ctrl) Reset counters only (internal helper) Arguments Type Intent Optional Attributes Name type( adaptive_mix_t ), intent(inout) :: mix_ctrl","tags":"","url":"module/adaptive_mixing.html"},{"title":"density_calculator – LSDA-Hubbard-Fortran","text":"Uses lsda_errors lsda_constants module~~density_calculator~~UsesGraph module~density_calculator density_calculator module~lsda_constants lsda_constants module~density_calculator->module~lsda_constants module~lsda_errors lsda_errors module~density_calculator->module~lsda_errors iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~lsda_errors->module~lsda_constants Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~density_calculator~~UsedByGraph module~density_calculator density_calculator module~kohn_sham_cycle kohn_sham_cycle module~kohn_sham_cycle->module~density_calculator module~input_parser input_parser module~input_parser->module~kohn_sham_cycle module~output_writer output_writer module~output_writer->module~kohn_sham_cycle module~output_writer->module~input_parser Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: TOL = 1.0e-10_dp Interfaces public        interface compute_density_spin private  subroutine compute_density_spin_real (eigvecs, L, n_elec, density, ierr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigvecs (:,:) integer, intent(in) :: L integer, intent(in) :: n_elec real(kind=dp), intent(out) :: density (:) integer, intent(out) :: ierr private  subroutine compute_density_spin_complex (eigvecs, L, n_elec, density, ierr) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: eigvecs (:,:) integer, intent(in) :: L integer, intent(in) :: n_elec real(kind=dp), intent(out) :: density (:) integer, intent(out) :: ierr Subroutines private  subroutine compute_density_spin_real (eigvecs, L, n_elec, density, ierr) Compute density from real eigenvectors (Open/Periodic BC) Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigvecs (:,:) integer, intent(in) :: L integer, intent(in) :: n_elec real(kind=dp), intent(out) :: density (:) integer, intent(out) :: ierr private  subroutine compute_density_spin_complex (eigvecs, L, n_elec, density, ierr) Compute density from complex eigenvectors (Twisted BC) Read more… Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: eigvecs (:,:) integer, intent(in) :: L integer, intent(in) :: n_elec real(kind=dp), intent(out) :: density (:) integer, intent(out) :: ierr public  subroutine compute_total_density (density_up, density_dw, density_total, ierr) Compute total density from spin-resolved densities Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: density_up (:) real(kind=dp), intent(in) :: density_dw (:) real(kind=dp), intent(out) :: density_total (:) integer, intent(out) :: ierr public  subroutine verify_particle_number (density, L, n_expected, is_conserved, ierr) Verify particle number conservation Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: density (:) integer, intent(in) :: L integer, intent(in) :: n_expected logical, intent(out) :: is_conserved integer, intent(out) :: ierr public  subroutine check_density_bounds (density_up, density_dw, L, all_valid, ierr) Check if densities satisfy physical bounds Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: density_up (:) real(kind=dp), intent(in) :: density_dw (:) integer, intent(in) :: L logical, intent(out) :: all_valid integer, intent(out) :: ierr","tags":"","url":"module/density_calculator.html"},{"title":"continuation – LSDA-Hubbard-Fortran","text":"Continuation methods for solving Bethe Ansatz equations across parameter ranges Uses bethe_equations nonlinear_solvers lsda_constants module~~continuation~~UsesGraph module~continuation continuation module~bethe_equations bethe_equations module~continuation->module~bethe_equations module~lsda_constants lsda_constants module~continuation->module~lsda_constants module~nonlinear_solvers nonlinear_solvers module~continuation->module~nonlinear_solvers module~bethe_equations->module~lsda_constants iso_fortran_env iso_fortran_env module~lsda_constants->iso_fortran_env module~nonlinear_solvers->module~bethe_equations module~nonlinear_solvers->module~lsda_constants ieee_arithmetic ieee_arithmetic module~nonlinear_solvers->ieee_arithmetic Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function estimate_dxdU (x_old, x_current, dU) result(dxdU) Estimates dx/dU using finite differences Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x_old (:) real(kind=dp), intent(in) :: x_current (:) real(kind=dp), intent(in) :: dU Return Value real(kind=dp), (size(x_current)) Subroutines public  subroutine sweep_U_forward (I, J, L, U_values, solutions, energies, converged_flags) Forward sweep in U with predictor-corrector method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U_values (:) real(kind=dp), intent(out) :: solutions (:,:) real(kind=dp), intent(out) :: energies (:) logical, intent(out) :: converged_flags (:) public  subroutine sweep_U_backward (I, J, L, U_values, solutions, energies, converged_flags) Backward sweep in U with predictor-corrector method Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U_values (:) real(kind=dp), intent(out) :: solutions (:,:) real(kind=dp), intent(out) :: energies (:) logical, intent(out) :: converged_flags (:) public  subroutine sweep_U_bidirectional (I, J, L, U_values, solutions, energies, converged_flags) Bidirectional sweep with refinement (forward + backward average) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: I (:) real(kind=dp), intent(in) :: J (:) integer, intent(in) :: L real(kind=dp), intent(in) :: U_values (:) real(kind=dp), intent(out) :: solutions (:,:) real(kind=dp), intent(out) :: energies (:) logical, intent(out) :: converged_flags (:)","tags":"","url":"module/continuation.html"},{"title":"  system – LSDA-Hubbard-Fortran\n","text":"Variables Name Type Default Description L integer None Nup integer None Ndown integer None U real(kind=dp) None bc character(len=20) None phase real(kind=dp) None","tags":"","url":"namelist/system.html"},{"title":"  potential – LSDA-Hubbard-Fortran\n","text":"Variables Name Type Default Description potential_type character(len=20) None V0 real(kind=dp) None pot_center real(kind=dp) None pot_width real(kind=dp) None concentration real(kind=dp) None pot_seed integer None imp_positions_str character(len=500) None disorder_strength real(kind=dp) None distribution character(len=20) None position integer None width integer None barrier_width real(kind=dp) None well_depth real(kind=dp) None well_width real(kind=dp) None position1 integer None width1 integer None position2 integer None width2 integer None","tags":"","url":"namelist/potential.html"},{"title":"  scf – LSDA-Hubbard-Fortran\n","text":"Variables Name Type Default Description max_iter integer None density_tol real(kind=dp) None energy_tol real(kind=dp) None mixing_alpha real(kind=dp) None verbose logical None store_history logical None use_adaptive_mixing logical None","tags":"","url":"namelist/scf.html"},{"title":"  output – LSDA-Hubbard-Fortran\n","text":"Variables Name Type Default Description output_prefix character(len=100) None save_density logical None save_eigenvalues logical None save_wavefunction logical None","tags":"","url":"namelist/output.html"},{"title":"output_writer.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~output_writer.f90~~EfferentGraph sourcefile~output_writer.f90 output_writer.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~output_writer.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~output_writer.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_types.f90 lsda_types.f90 sourcefile~output_writer.f90->sourcefile~lsda_types.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~input_parser.f90->sourcefile~lsda_constants.f90 sourcefile~input_parser.f90->sourcefile~lsda_errors.f90 sourcefile~input_parser.f90->sourcefile~lsda_types.f90 sourcefile~boundary_conditions.f90 boundary_conditions.f90 sourcefile~input_parser.f90->sourcefile~boundary_conditions.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_constants.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_errors.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_types.f90 sourcefile~adaptive_mixing.f90 adaptive_mixing.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~adaptive_mixing.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~boundary_conditions.f90 sourcefile~convergence_monitor.f90 convergence_monitor.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~convergence_monitor.f90 sourcefile~density_calculator.f90 density_calculator.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~density_calculator.f90 sourcefile~hamiltonian_builder.f90 hamiltonian_builder.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~hamiltonian_builder.f90 sourcefile~lapack_wrapper.f90 lapack_wrapper.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lapack_wrapper.f90 sourcefile~mixing_schemes.f90 mixing_schemes.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~mixing_schemes.f90 sourcefile~xc_lsda.f90 xc_lsda.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~xc_lsda.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_types.f90->sourcefile~lsda_constants.f90 sourcefile~adaptive_mixing.f90->sourcefile~lsda_constants.f90 sourcefile~adaptive_mixing.f90->sourcefile~lsda_errors.f90 sourcefile~boundary_conditions.f90->sourcefile~lsda_constants.f90 sourcefile~boundary_conditions.f90->sourcefile~lsda_errors.f90 sourcefile~convergence_monitor.f90->sourcefile~lsda_constants.f90 sourcefile~convergence_monitor.f90->sourcefile~lsda_errors.f90 sourcefile~density_calculator.f90->sourcefile~lsda_constants.f90 sourcefile~density_calculator.f90->sourcefile~lsda_errors.f90 sourcefile~hamiltonian_builder.f90->sourcefile~lsda_constants.f90 sourcefile~hamiltonian_builder.f90->sourcefile~lsda_errors.f90 sourcefile~hamiltonian_builder.f90->sourcefile~boundary_conditions.f90 sourcefile~lapack_wrapper.f90->sourcefile~lsda_constants.f90 sourcefile~lapack_wrapper.f90->sourcefile~lsda_errors.f90 sourcefile~mixing_schemes.f90->sourcefile~lsda_constants.f90 sourcefile~mixing_schemes.f90->sourcefile~lsda_errors.f90 sourcefile~xc_lsda.f90->sourcefile~lsda_constants.f90 sourcefile~xc_lsda.f90->sourcefile~lsda_errors.f90 sourcefile~spline2d.f90 spline2d.f90 sourcefile~xc_lsda.f90->sourcefile~spline2d.f90 sourcefile~table_io.f90 table_io.f90 sourcefile~xc_lsda.f90->sourcefile~table_io.f90 sourcefile~spline2d.f90->sourcefile~lsda_constants.f90 sourcefile~table_io.f90->sourcefile~lsda_constants.f90 sourcefile~table_io.f90->sourcefile~lsda_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Module for writing simulation results to files !! !! Provides formatted output for: !! - Density profiles (spin-up, spin-down, total) !! - Eigenvalues and eigenvectors !! - Convergence history !! - Summary information module output_writer use lsda_constants , only : dp use lsda_types , only : system_params_t use kohn_sham_cycle , only : scf_results_t , scf_params_t use input_parser , only : input_params_t use lsda_errors , only : ERROR_SUCCESS , ERROR_FILE_WRITE implicit none private public :: write_results public :: write_density_profile public :: write_eigenvalues public :: write_convergence_history public :: write_summary contains !> Write all simulation results !! !! @param[in] results      SCF results !! @param[in] sys_params   System parameters !! @param[in] inputs       Input parameters !! @param[out] ierr        Error code subroutine write_results ( results , sys_params , inputs , ierr ) type ( scf_results_t ), intent ( in ) :: results type ( system_params_t ), intent ( in ) :: sys_params type ( input_params_t ), intent ( in ) :: inputs integer , intent ( out ) :: ierr character ( len = 256 ) :: prefix ierr = ERROR_SUCCESS prefix = trim ( inputs % output_prefix ) call write_summary ( results , sys_params , inputs , ierr ) if ( ierr /= ERROR_SUCCESS ) return if ( inputs % save_density ) then call write_density_profile ( results , sys_params , prefix , ierr ) if ( ierr /= ERROR_SUCCESS ) return end if if ( inputs % save_eigenvalues ) then call write_eigenvalues ( results , sys_params , prefix , ierr ) if ( ierr /= ERROR_SUCCESS ) return end if if ( inputs % store_history . and . allocated ( results % history % density_norms )) then call write_convergence_history ( results , prefix , ierr ) if ( ierr /= ERROR_SUCCESS ) return end if end subroutine write_results !> Write summary to stdout and file !! !! @param[in] results      SCF results !! @param[in] sys_params   System parameters !! @param[in] inputs       Input parameters !! @param[out] ierr        Error code subroutine write_summary ( results , sys_params , inputs , ierr ) type ( scf_results_t ), intent ( in ) :: results type ( system_params_t ), intent ( in ) :: sys_params type ( input_params_t ), intent ( in ) :: inputs integer , intent ( out ) :: ierr character ( len = 256 ) :: filename integer :: io_unit , io_stat real ( dp ) :: total_density ierr = ERROR_SUCCESS print '(A)' , \"\" print '(A)' , \"==========================================\" print '(A)' , \"         SIMULATION RESULTS\" print '(A)' , \"==========================================\" print '(A)' , \"\" print '(A)' , \"System Parameters:\" print '(A,I0)' , \"  L (sites):        \" , sys_params % L print '(A,I0)' , \"  N_up:             \" , sys_params % Nup print '(A,I0)' , \"  N_down:           \" , sys_params % Ndown print '(A,I0)' , \"  N_total:          \" , sys_params % Nup + sys_params % Ndown print '(A,F0.4)' , \"  U:                \" , sys_params % U if ( sys_params % bc == 2 ) then print '(A,F0.4)' , \"  Phase:            \" , sys_params % phase end if print '(A)' , \"\" print '(A)' , \"SCF Convergence:\" if ( results % converged ) then print '(A)' , \"  Status:           ✓ CONVERGED\" else print '(A)' , \"  Status:           ✗ NOT CONVERGED\" end if print '(A,I0)' , \"  Iterations:       \" , results % n_iterations print '(A,ES12.4)' , \"  Final |Δn|:       \" , results % final_density_error if ( allocated ( results % density_up )) then print '(A,F20.12)' , \"  Final Energy per site: \" , results % final_energy / size ( results % density_up ) else print '(A,F20.12)' , \"  Final Energy per site: \" , results % final_energy end if print '(A)' , \"\" if ( allocated ( results % density_up )) then total_density = sum ( results % density_up ) + sum ( results % density_down ) print '(A)' , \"Density Check:\" print '(A,F12.6)' , \"  ∫n_up dx:         \" , sum ( results % density_up ) print '(A,F12.6)' , \"  ∫n_down dx:       \" , sum ( results % density_down ) print '(A,F12.6)' , \"  ∫n_total dx:      \" , total_density print '(A,F12.6)' , \"  Expected N:       \" , real ( sys_params % Nup + sys_params % Ndown , dp ) print '(A,ES12.4)' , \"  Error:            \" , abs ( total_density - real ( sys_params % Nup + sys_params % Ndown , dp )) print '(A)' , \"\" end if print '(A)' , \"Output Files:\" print '(A,A)' , \"  Prefix:           \" , trim ( inputs % output_prefix ) if ( inputs % save_density ) then print '(A,A)' , \"  Density:          \" , trim ( inputs % output_prefix ) // \"_density.dat\" end if if ( inputs % save_eigenvalues ) then print '(A,A)' , \"  Eigenvalues:      \" , trim ( inputs % output_prefix ) // \"_eigenvalues.dat\" end if if ( inputs % store_history ) then print '(A,A)' , \"  Convergence:      \" , trim ( inputs % output_prefix ) // \"_convergence.dat\" end if print '(A)' , \"\" print '(A)' , \"==========================================\" print '(A)' , \"\" filename = trim ( inputs % output_prefix ) // \"_summary.txt\" open ( newunit = io_unit , file = filename , status = 'replace' , iostat = io_stat ) if ( io_stat /= 0 ) then print * , \"WARNING: Could not write summary file: \" , trim ( filename ) ierr = ERROR_FILE_WRITE return end if write ( io_unit , '(A)' ) \"LSDA-Hubbard Simulation Summary\" write ( io_unit , '(A)' ) \"================================\" write ( io_unit , '(A)' ) \"\" write ( io_unit , '(A,I0)' ) \"L = \" , sys_params % L write ( io_unit , '(A,I0)' ) \"Nup = \" , sys_params % Nup write ( io_unit , '(A,I0)' ) \"Ndown = \" , sys_params % Ndown write ( io_unit , '(A,F0.4)' ) \"U = \" , sys_params % U write ( io_unit , '(A)' ) \"\" if ( results % converged ) then write ( io_unit , '(A)' ) \"SCF: CONVERGED\" else write ( io_unit , '(A)' ) \"SCF: NOT CONVERGED\" end if write ( io_unit , '(A,I0)' ) \"Iterations: \" , results % n_iterations write ( io_unit , '(A,ES12.4)' ) \"Final |Δn|: \" , results % final_density_error if ( allocated ( results % density_up )) then write ( io_unit , '(A,F20.12)' ) \"Final Energy: \" , results % final_energy / size ( results % density_up ) else write ( io_unit , '(A,F20.12)' ) \"Final Energy: \" , results % final_energy end if close ( io_unit ) ierr = ERROR_SUCCESS end subroutine write_summary !> Write density profile to file !! !! Format: site n_up(i) n_down(i) n_total(i) !! !! @param[in] results      SCF results !! @param[in] sys_params   System parameters !! @param[in] prefix       Output file prefix !! @param[out] ierr        Error code subroutine write_density_profile ( results , sys_params , prefix , ierr ) type ( scf_results_t ), intent ( in ) :: results type ( system_params_t ), intent ( in ) :: sys_params character ( len =* ), intent ( in ) :: prefix integer , intent ( out ) :: ierr character ( len = 256 ) :: filename integer :: io_unit , io_stat , i ierr = ERROR_SUCCESS if (. not . allocated ( results % density_up )) then print * , \"WARNING: Density not available, skipping density output\" return end if filename = trim ( prefix ) // \"_density.dat\" open ( newunit = io_unit , file = filename , status = 'replace' , iostat = io_stat ) if ( io_stat /= 0 ) then print * , \"ERROR: Could not write density file: \" , trim ( filename ) ierr = ERROR_FILE_WRITE return end if write ( io_unit , '(A)' ) \"# Density profile from LSDA-Hubbard calculation\" write ( io_unit , '(A,I0)' ) \"# L = \" , sys_params % L write ( io_unit , '(A,I0)' ) \"# Nup = \" , sys_params % Nup write ( io_unit , '(A,I0)' ) \"# Ndown = \" , sys_params % Ndown write ( io_unit , '(A,F0.4)' ) \"# U = \" , sys_params % U write ( io_unit , '(A)' ) \"#\" write ( io_unit , '(A)' ) \"# Columns: site  n_up  n_down  n_total\" do i = 1 , sys_params % L write ( io_unit , '(I6,3ES20.10)' ) i , results % density_up ( i ), & results % density_down ( i ), & results % density_up ( i ) + results % density_down ( i ) end do close ( io_unit ) print '(A,A)' , \"  Density profile written to: \" , trim ( filename ) ierr = ERROR_SUCCESS end subroutine write_density_profile !> Write eigenvalues to file !! !! Format: index spin eigenvalue !! !! @param[in] results      SCF results !! @param[in] sys_params   System parameters !! @param[in] prefix       Output file prefix !! @param[out] ierr        Error code subroutine write_eigenvalues ( results , sys_params , prefix , ierr ) type ( scf_results_t ), intent ( in ) :: results type ( system_params_t ), intent ( in ) :: sys_params character ( len =* ), intent ( in ) :: prefix integer , intent ( out ) :: ierr character ( len = 256 ) :: filename integer :: io_unit , io_stat , i , L ierr = ERROR_SUCCESS if (. not . allocated ( results % eigvals )) then print * , \"WARNING: Eigenvalues not available, skipping eigenvalue output\" return end if L = sys_params % L filename = trim ( prefix ) // \"_eigenvalues.dat\" open ( newunit = io_unit , file = filename , status = 'replace' , iostat = io_stat ) if ( io_stat /= 0 ) then print * , \"ERROR: Could not write eigenvalues file: \" , trim ( filename ) ierr = ERROR_FILE_WRITE return end if ! Write header write ( io_unit , '(A)' ) \"# Eigenvalues from LSDA-Hubbard calculation\" write ( io_unit , '(A,I0)' ) \"# L = \" , L write ( io_unit , '(A,I0)' ) \"# Nup = \" , sys_params % Nup write ( io_unit , '(A,I0)' ) \"# Ndown = \" , sys_params % Ndown write ( io_unit , '(A,F0.4)' ) \"# U = \" , sys_params % U write ( io_unit , '(A)' ) \"#\" write ( io_unit , '(A)' ) \"# First L eigenvalues: spin-up\" write ( io_unit , '(A)' ) \"# Last L eigenvalues: spin-down\" write ( io_unit , '(A)' ) \"#\" write ( io_unit , '(A)' ) \"# Columns: index  spin  eigenvalue  occupied\" do i = 1 , L if ( i <= sys_params % Nup ) then write ( io_unit , '(I6,A8,ES20.10,A8)' ) i , \"up\" , results % eigvals ( i ), \"yes\" else write ( io_unit , '(I6,A8,ES20.10,A8)' ) i , \"up\" , results % eigvals ( i ), \"no\" end if end do do i = 1 , L if ( i <= sys_params % Ndown ) then write ( io_unit , '(I6,A8,ES20.10,A8)' ) i , \"down\" , results % eigvals ( L + i ), \"yes\" else write ( io_unit , '(I6,A8,ES20.10,A8)' ) i , \"down\" , results % eigvals ( L + i ), \"no\" end if end do close ( io_unit ) print '(A,A)' , \"  Eigenvalues written to: \" , trim ( filename ) ierr = ERROR_SUCCESS end subroutine write_eigenvalues !> Write convergence history to file !! !! Format: iteration density_error energy !! !! @param[in] results  SCF results !! @param[in] prefix   Output file prefix !! @param[out] ierr    Error code subroutine write_convergence_history ( results , prefix , ierr ) type ( scf_results_t ), intent ( in ) :: results character ( len =* ), intent ( in ) :: prefix integer , intent ( out ) :: ierr character ( len = 256 ) :: filename integer :: io_unit , io_stat , i ierr = ERROR_SUCCESS if (. not . allocated ( results % history % density_norms )) then return end if filename = trim ( prefix ) // \"_convergence.dat\" open ( newunit = io_unit , file = filename , status = 'replace' , iostat = io_stat ) if ( io_stat /= 0 ) then print * , \"ERROR: Could not write convergence file: \" , trim ( filename ) ierr = ERROR_FILE_WRITE return end if write ( io_unit , '(A)' ) \"# SCF convergence history\" write ( io_unit , '(A)' ) \"#\" write ( io_unit , '(A)' ) \"# Columns: iteration  |Δn|  energy\" do i = 1 , results % history % current_iter write ( io_unit , '(I6,2ES20.10)' ) i , & results % history % density_norms ( i ), & results % history % energies ( i ) end do close ( io_unit ) print '(A,A)' , \"  Convergence history written to: \" , trim ( filename ) ierr = ERROR_SUCCESS end subroutine write_convergence_history end module output_writer","tags":"","url":"sourcefile/output_writer.f90.html"},{"title":"kohn_sham_cycle.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~kohn_sham_cycle.f90~~EfferentGraph sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~adaptive_mixing.f90 adaptive_mixing.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~adaptive_mixing.f90 sourcefile~boundary_conditions.f90 boundary_conditions.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~boundary_conditions.f90 sourcefile~convergence_monitor.f90 convergence_monitor.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~convergence_monitor.f90 sourcefile~density_calculator.f90 density_calculator.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~density_calculator.f90 sourcefile~hamiltonian_builder.f90 hamiltonian_builder.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~hamiltonian_builder.f90 sourcefile~lapack_wrapper.f90 lapack_wrapper.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lapack_wrapper.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_types.f90 lsda_types.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_types.f90 sourcefile~mixing_schemes.f90 mixing_schemes.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~mixing_schemes.f90 sourcefile~xc_lsda.f90 xc_lsda.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~xc_lsda.f90 sourcefile~adaptive_mixing.f90->sourcefile~lsda_constants.f90 sourcefile~adaptive_mixing.f90->sourcefile~lsda_errors.f90 sourcefile~boundary_conditions.f90->sourcefile~lsda_constants.f90 sourcefile~boundary_conditions.f90->sourcefile~lsda_errors.f90 sourcefile~convergence_monitor.f90->sourcefile~lsda_constants.f90 sourcefile~convergence_monitor.f90->sourcefile~lsda_errors.f90 sourcefile~density_calculator.f90->sourcefile~lsda_constants.f90 sourcefile~density_calculator.f90->sourcefile~lsda_errors.f90 sourcefile~hamiltonian_builder.f90->sourcefile~boundary_conditions.f90 sourcefile~hamiltonian_builder.f90->sourcefile~lsda_constants.f90 sourcefile~hamiltonian_builder.f90->sourcefile~lsda_errors.f90 sourcefile~lapack_wrapper.f90->sourcefile~lsda_constants.f90 sourcefile~lapack_wrapper.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_types.f90->sourcefile~lsda_constants.f90 sourcefile~mixing_schemes.f90->sourcefile~lsda_constants.f90 sourcefile~mixing_schemes.f90->sourcefile~lsda_errors.f90 sourcefile~xc_lsda.f90->sourcefile~lsda_constants.f90 sourcefile~xc_lsda.f90->sourcefile~lsda_errors.f90 sourcefile~spline2d.f90 spline2d.f90 sourcefile~xc_lsda.f90->sourcefile~spline2d.f90 sourcefile~table_io.f90 table_io.f90 sourcefile~xc_lsda.f90->sourcefile~table_io.f90 sourcefile~spline2d.f90->sourcefile~lsda_constants.f90 sourcefile~table_io.f90->sourcefile~lsda_constants.f90 sourcefile~table_io.f90->sourcefile~lsda_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~kohn_sham_cycle.f90~~AfferentGraph sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module kohn_sham_cycle use lsda_constants , only : dp , SCF_DENSITY_TOL , SCF_ENERGY_TOL , ITER_MAX , MIX_ALPHA use lsda_types , only : system_params_t use lsda_errors , only : ERROR_SUCCESS , ERROR_INVALID_INPUT , & ERROR_CONVERGENCE_FAILED , ERROR_SIZE_MISMATCH use boundary_conditions , only : apply_boundary_conditions , apply_boundary_conditions_complex use hamiltonian_builder , only : build_hamiltonian , build_hamiltonian_complex use lapack_wrapper , only : diagonalize_symmetric_real , diagonalize_hermitian_complex use density_calculator , only : compute_density_spin use xc_lsda , only : xc_lsda_t , get_vxc , get_exc use convergence_monitor , only : compute_density_difference , check_scf_convergence , & convergence_history_t , init_convergence_history , & update_convergence_history , cleanup_convergence_history , & L2 , compute_density_norm use mixing_schemes , only : linear_mixing use adaptive_mixing , only : adaptive_mix_t , adaptive_mix_init , adaptive_mix_update , & adaptive_mix_get_alpha , adaptive_mix_reset implicit none private !> @brief Parameters for SCF cycle type :: scf_params_t integer :: max_iter = ITER_MAX ! Maximum SCF iterations real ( dp ) :: density_tol = SCF_DENSITY_TOL ! Convergence tolerance for density real ( dp ) :: energy_tol = SCF_ENERGY_TOL ! Convergence tolerance for energy real ( dp ) :: mixing_alpha = MIX_ALPHA ! Linear mixing parameter (used if use_adaptive_mixing = .false.) logical :: verbose = . false . ! Print convergence info logical :: store_history = . true . ! Store convergence history logical :: use_adaptive_mixing = . true . ! Use adaptive mixing (C++ behavior) end type scf_params_t !> @brief Results from SCF cycle type :: scf_results_t logical :: converged ! Did SCF converge? integer :: n_iterations ! Number of iterations performed real ( dp ) :: final_density_error ! Final ||Δn||₂ real ( dp ) :: final_energy ! Final total energy real ( dp ), allocatable :: density_up (:) ! Converged spin-up density real ( dp ), allocatable :: density_down (:) ! Converged spin-down density real ( dp ), allocatable :: eigvals (:) ! Final eigenvalues (both spins) type ( convergence_history_t ) :: history ! Convergence history end type scf_results_t public :: scf_params_t , scf_results_t public :: compute_total_energy public :: run_kohn_sham_scf_real public :: run_kohn_sham_scf_complex public :: init_scf_results , cleanup_scf_results contains !> @brief Compute total Kohn-Sham energy !! !! E_tot = Σ_σ Σ_j ε_j,σ - U·Σ(n_up·n_down) - Σ(V_xc·n) + Σ(ε_xc) !! !! This formula matches the C++ original (lsdaks.cc lines 676-679). !! !! The eigenvalues ε_j already include V_eff = V_ext + U·n_other + V_xc. !! When summing eigenvalues, we get contributions from both spins: !!   - Spin up sees:   V_ext + U·n_down + V_xc_up !!   - Spin down sees: V_ext + U·n_up + V_xc_down !! This means the Hartree term U·n_other appears TWICE (once for each spin), !! giving 2·U·n_up·n_down instead of the correct U·n_up·n_down. !! !! The double-counting correction: !! - Band energy: Σε_j (includes 2·U·n_up·n_down) !! - Hartree correction: -U·Σ(n_up·n_down) (removes one copy) !! - V_xc correction: -Σ(V_xc·n) (removes V_xc from eigenvalues) !! - XC energy: +Σ(ε_xc) (adds true XC energy) !! !! Note: ε_xc from tables is the TOTAL XC energy at each site, not per particle! !! !! @param[in] eigvalues_up Spin-up eigenvalues (occupied ones) !! @param[in] eigvalues_down Spin-down eigenvalues (occupied ones) !! @param[in] n_up Number of spin-up electrons !! @param[in] n_down Number of spin-down electrons !! @param[in] density_up Spin-up density (length L) !! @param[in] density_down Spin-down density (length L) !! @param[in] V_ext External potential (length L) !! @param[in] xc_func XC functional object !! @param[in] U Hubbard interaction strength !! @param[in] L System size !! @param[out] total_energy Total energy !! @param[out] ierr Error code (0 = success) subroutine compute_total_energy ( eigvals_up , eigvals_down , n_up , n_down , density_up , density_down , & V_ext , xc_func , U , L , total_energy , ierr ) real ( dp ), intent ( in ) :: eigvals_up (:), eigvals_down (:) integer , intent ( in ) :: n_up , n_down real ( dp ), intent ( in ) :: density_up (:), density_down (:), V_ext (:) type ( xc_lsda_t ), intent ( in ) :: xc_func real ( dp ), intent ( in ) :: U integer , intent ( in ) :: L real ( dp ), intent ( out ) :: total_energy integer , intent ( out ) :: ierr real ( dp ) :: E_band , E_hartree , E_xc_total , V_xc_correction real ( dp ) :: exc_val , V_xc_up , V_xc_down integer :: i ! 1. Band energy (sum of occupied eigenvalues) E_band = sum ( eigvals_up ( 1 : n_up )) + sum ( eigvals_down ( 1 : n_down )) ! 2. Hartree energy: -U*Σ(n_up*n_down) !    Double-counting correction (matches C++ lsdaks.cc lines 676-679) !    Derivation: eigenvalues include V_eff = V_ext + U*n_other + V_xc !    When we sum v_eff*n for both spins, we get 2*U*n_up*n_down !    But we only want U*n_up*n_down, so we SUBTRACT U*n_up*n_down E_hartree = 0.0_dp do i = 1 , L E_hartree = E_hartree + density_up ( i ) * density_down ( i ) end do E_hartree = - U * E_hartree ! Negative sign! ! 3. Exchange-correlation energy and potential correction E_xc_total = 0.0_dp V_xc_correction = 0.0_dp do i = 1 , L call get_exc ( xc_func , density_up ( i ), density_down ( i ), exc_val , ierr ) if ( ierr /= ERROR_SUCCESS ) then return end if call get_vxc ( xc_func , density_up ( i ), density_down ( i ), & V_xc_up , V_xc_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then return end if ! Note: exc_val is already the total XC energy at site i, not per particle! ! C++ just adds exc[i], not exc[i]*n_total[i] E_xc_total = E_xc_total + exc_val ! V_xc correction for double-counting V_xc_correction = V_xc_correction + V_xc_up * density_up ( i ) + V_xc_down * density_down ( i ) end do ! Total: E_band + E_hartree + E_xc - V_xc (matches C++ lsdaks.cc line 676-679) total_energy = E_band + E_hartree + E_xc_total - V_xc_correction ierr = ERROR_SUCCESS end subroutine compute_total_energy !> @brief Validate inputs for Kohn-Sham SCF cycle !! !! Performs comprehensive validation of system and SCF parameters before !! starting the self-consistent field iteration. Ensures physical consistency !! and prevents runtime errors from invalid inputs. !! !! Validation checks: !! - System size L > 0 (at least one lattice site) !! - Particle numbers Nup, Ndown >= 0 (non-negative) !! - Total particles N = Nup + Ndown <= L (Pauli exclusion: max 2 per site) !! - External potential size matches system size: size(V_ext) = L !! - SCF max_iter > 0 (at least one iteration allowed) !! - Mixing parameter 0 < mixing_alpha <= 1 (valid range for linear mixing) !! !! @param[in]  params     System parameters (L, Nup, Ndown, bc, U, phase) !! @param[in]  scf_params SCF control parameters (max_iter, tolerances, mixing_alpha) !! @param[in]  V_ext      External potential array (length L) !! @param[out] ierr       Error code (ERROR_SUCCESS, ERROR_INVALID_INPUT, or ERROR_SIZE_MISMATCH) subroutine validate_kohn_sham_cycle_inputs ( params , scf_params , V_ext , ierr ) type ( system_params_t ), intent ( in ) :: params type ( scf_params_t ), intent ( in ) :: scf_params real ( dp ), intent ( in ) :: V_ext (:) integer , intent ( out ) :: ierr integer :: L , Nup , Ndown L = params % L Nup = params % Nup Ndown = params % Ndown if ( L <= 0 . or . Nup < 0 . or . Ndown < 0 . or . ( Nup + Ndown ) > 2 * L ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( V_ext ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( scf_params % max_iter <= 0 . or . scf_params % mixing_alpha < 0.0_dp . or . & scf_params % mixing_alpha > 1.0_dp ) then ierr = ERROR_INVALID_INPUT return end if ierr = ERROR_SUCCESS end subroutine validate_kohn_sham_cycle_inputs !> @brief Run self-consistent Kohn-Sham cycle (real Hamiltonian) !! !! Iterates density → V_xc → H → diagonalize → new density until convergence. !! Uses linear mixing to stabilize convergence. !! !! @param[in] params System parameters (L, n_up, n_down, hopping, BC type) !! @param[in] scf_params SCF control parameters (max_iter, tolerances, mixing) !! @param[in] V_ext External potential V_ext(i) (length L) !! @param[in] xc_func XC functional object (already initialized with tables) !! @param[out] results SCF results (densities, eigenvalues, convergence info) !! @param[out] ierr Error code (0 = success) subroutine run_kohn_sham_scf_real ( params , scf_params , V_ext , xc_func , results , ierr ) type ( system_params_t ), intent ( in ) :: params type ( scf_params_t ), intent ( in ) :: scf_params real ( dp ), intent ( in ) :: V_ext (:) type ( xc_lsda_t ), intent ( in ) :: xc_func type ( scf_results_t ), intent ( out ) :: results integer , intent ( out ) :: ierr integer :: iter , i , L , Nup , Ndown real ( dp ) :: density_error , total_energy logical :: is_converged type ( adaptive_mix_t ) :: mix_ctrl real ( dp ) :: current_alpha real ( dp ), allocatable :: n_up_in (:), n_down_in (:), n_up_out (:), n_down_out (:), V_xc_up (:), & V_xc_down (:), H_up (:,:), H_down (:,:), eigvals_up (:), & eigvals_down (:), eigvecs_up (:,:), eigvecs_down (:,:), delta_n_up (:), delta_n_down (:), & delta_n_total (:), V_eff_up (:), V_eff_down (:), V_eff_up_calc (:), V_eff_down_calc (:), & V_zero (:) call validate_kohn_sham_cycle_inputs ( params , scf_params , V_ext , ierr ) if ( ierr /= ERROR_SUCCESS ) then return end if L = params % L Nup = params % Nup Ndown = params % Ndown allocate ( n_up_in ( L ), n_down_in ( L ), n_up_out ( L ), n_down_out ( L ), V_xc_up ( L ), V_xc_down ( L ), & H_up ( L , L ), H_down ( L , L ), eigvals_up ( L ), eigvals_down ( L ), & eigvecs_up ( L , L ), eigvecs_down ( L , L ), delta_n_up ( L ), delta_n_down ( L ), delta_n_total ( L ), & V_eff_up ( L ), V_eff_down ( L ), V_eff_up_calc ( L ), V_eff_down_calc ( L ), V_zero ( L )) ! Initialize zero array for Hamiltonian builder V_zero (:) = 0.0_dp call init_convergence_history ( results % history , scf_params % max_iter , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for history init deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc ) return end if ! Initialize densities (uniform guess) n_up_in (:) = real ( params % Nup , dp ) / real ( params % L , dp ) n_down_in (:) = real ( params % Ndown , dp ) / real ( params % L , dp ) ! Initialize effective potentials from initial density guess ! This matches C++ initial_guess() function (lsdaks.cc lines 520-521) ! V_eff = V_ext + U*n_other + V_xc do i = 1 , params % L ! Get V_xc from initial uniform density call get_vxc ( xc_func , n_up_in ( i ), n_down_in ( i ), V_xc_up ( i ), V_xc_down ( i ), ierr ) if ( ierr /= ERROR_SUCCESS ) then deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if ! Initialize V_eff = V_ext + U*n_other + V_xc (like C++) V_eff_up ( i ) = V_ext ( i ) + params % U * n_down_in ( i ) + V_xc_up ( i ) V_eff_down ( i ) = V_ext ( i ) + params % U * n_up_in ( i ) + V_xc_down ( i ) end do ! ================================= ! Initialize adaptive mixing (if enabled) ! ================================= if ( scf_params % use_adaptive_mixing ) then call adaptive_mix_init ( mix_ctrl , scf_params % energy_tol ) if ( scf_params % verbose ) then print '(A)' , \"  Using adaptive mixing (C++ behavior)\" end if else if ( scf_params % verbose ) then print '(A,F6.4)' , \"  Using fixed mixing alpha = \" , scf_params % mixing_alpha end if end if ! ================= ! STEP 1: SCF loop ! ================= do iter = 1 , scf_params % max_iter ! ------------------------------------------------- ! 1a. Compute V_xc from current densities ! ------------------------------------------------- do i = 1 , params % L call get_vxc ( xc_func , n_up_in ( i ), n_down_in ( i ), V_xc_up ( i ), V_xc_down ( i ), ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for V_xc calculation deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if end do ! ------------------------------------------------------------- ! 1b. Calculate effective potentials V_eff = V_ext + U*n_other + V_xc ! (This is what C++ calls \"v_ext[σ][j] + u*dens[other][j] + Vxc[σ][j]\") ! ------------------------------------------------------------- do i = 1 , params % L ! V_eff_up_calc = V_ext + U*n_down + V_xc_up V_eff_up_calc ( i ) = V_ext ( i ) + params % U * n_down_in ( i ) + V_xc_up ( i ) ! V_eff_down_calc = V_ext + U*n_up + V_xc_down V_eff_down_calc ( i ) = V_ext ( i ) + params % U * n_up_in ( i ) + V_xc_down ( i ) end do ! ------------------------------------------------------------- ! 1c. Mix potentials (C++ convention: Mix = weight of OLD) ! V_eff_new = Mix*V_eff_old + (1-Mix)*V_eff_calc ! ------------------------------------------------------------- if ( scf_params % use_adaptive_mixing ) then ! Adaptive mixing uses the Mix parameter (updated each iteration) ! Convert to fortran alpha: alpha = 1 - Mix current_alpha = adaptive_mix_get_alpha ( mix_ctrl ) ! Apply mixing: V = (1-α)*V_old + α*V_calc = Mix*V_old + (1-Mix)*V_calc ! Since alpha = 1-Mix, we have: V = Mix*V_old + (1-Mix)*V_calc ✓ do i = 1 , params % L V_eff_up ( i ) = ( 1.0_dp - current_alpha ) * V_eff_up ( i ) + current_alpha * V_eff_up_calc ( i ) V_eff_down ( i ) = ( 1.0_dp - current_alpha ) * V_eff_down ( i ) + current_alpha * V_eff_down_calc ( i ) end do else ! Fixed mixing: alpha = weight of new current_alpha = scf_params % mixing_alpha do i = 1 , params % L V_eff_up ( i ) = ( 1.0_dp - current_alpha ) * V_eff_up ( i ) + current_alpha * V_eff_up_calc ( i ) V_eff_down ( i ) = ( 1.0_dp - current_alpha ) * V_eff_down ( i ) + current_alpha * V_eff_down_calc ( i ) end do end if ! ------------------------------------- ! 1d. Build Hamiltonians with mixed V_eff ! (C++ passes v_eff to hamiltonian_ks) ! ------------------------------------- call build_hamiltonian ( params % L , V_eff_up , V_zero , params % bc , params % phase , H_up , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Hamiltonian Nup build deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if call build_hamiltonian ( params % L , V_eff_down , V_zero , params % bc , params % phase , H_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Hamiltonian Ndown build deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if ! --------------------------------- ! 1d. Diagonalize both Hamiltonians ! --------------------------------- call diagonalize_symmetric_real ( H_up , params % L , eigvals_up , eigvecs_up , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for diagonalization Nup Hamiltonian deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if call diagonalize_symmetric_real ( H_down , params % L , eigvals_down , eigvecs_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for diagonalization Ndown Hamiltonian deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ---------------------------------------------- ! 1e. Compute new densities from eigenvectors ! ---------------------------------------------- call compute_density_spin ( eigvecs_up , params % L , params % Nup , n_up_out , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for density calculation Nup deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if call compute_density_spin ( eigvecs_down , params % L , params % Ndown , n_down_out , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for density calculation Ndown deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ---------------------------------------------- ! 1f. Compute density differences ! ---------------------------------------------- call compute_density_difference ( n_up_out , n_up_in , params % L , delta_n_up , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Nup density difference deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if call compute_density_difference ( n_down_out , n_down_in , params % L , delta_n_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Ndown density difference deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------------------ ! 1g. Compute total density error ! ------------------------------ delta_n_total = delta_n_up + delta_n_down call compute_density_norm ( delta_n_total , params % L , L2 , density_error , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for total density up norm deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------------ ! 1h. Compute total energy ! ------------------------ call compute_total_energy ( eigvals_up , eigvals_down , params % Nup , params % Ndown , n_up_out , n_down_out , & V_ext , xc_func , params % U , params % L , total_energy , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for total energy calculation deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------ ! 1i. Store history ! ------------------ if ( scf_params % store_history ) then call update_convergence_history ( iter , density_error , total_energy , results % history , ierr ) end if if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for history update deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------------------ ! 1j. Update adaptive mixing (if enabled) ! ------------------------------ if ( scf_params % use_adaptive_mixing ) then call adaptive_mix_update ( mix_ctrl , total_energy ) current_alpha = adaptive_mix_get_alpha ( mix_ctrl ) if ( scf_params % verbose ) then print '(A,I4,A,ES12.4,A,F16.8,A,F7.5)' , \"  Iter \" , iter , \"  |Δn| = \" , density_error , & \"  E_tot = \" , total_energy , \"  α = \" , current_alpha end if ! Check convergence: density-based (primary) OR energy-based (fallback) ! With potential mixing, density converges even if energy oscillates slightly call check_scf_convergence ( delta_n_total , params % L , scf_params % density_tol , & is_converged , ierr ) if ( ierr /= ERROR_SUCCESS . or . . not . is_converged ) then ! Density not converged OR error - fall back to energy-based check is_converged = mix_ctrl % converged end if else current_alpha = scf_params % mixing_alpha if ( scf_params % verbose ) then print '(A,I4,A,ES12.4,A,F16.8)' , \"  Iter \" , iter , \"  |Δn| = \" , density_error , & \"  E_tot = \" , total_energy end if ! 1k. Check convergence (fixed mixing) call check_scf_convergence ( delta_n_total , params % L , scf_params % density_tol , & is_converged , ierr ) end if ! Validate convergence check if (. not . scf_params % use_adaptive_mixing . and . ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for convergence check deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if if ( is_converged ) then ! SUCCESS: Converged! results % converged = . true . results % n_iterations = iter results % final_density_error = density_error results % final_energy = total_energy ! Store final densities and eigenvalues allocate ( results % density_up ( params % L )) allocate ( results % density_down ( params % L )) allocate ( results % eigvals ( 2 * params % L )) results % density_up = n_up_out results % density_down = n_down_out results % eigvals ( 1 : params % L ) = eigvals_up results % eigvals ( params % L + 1 : 2 * params % L ) = eigvals_down ierr = ERROR_SUCCESS return ! return SCF LOOP end if ! ----------------------------------------------------------------------- ! 1l. Copy densities directly (NO MIXING!) ! ----------------------------------------------------------------------- ! C++ code does: dens[0][i] = next_dens[0][i]  (line 695-696 in lsdaks.cc) ! Mixing is applied to POTENTIALS, not densities! n_up_in = n_up_out n_down_in = n_down_out end do ! ======================== ! STEP 2: Did not converge ! ======================== results % converged = . false . results % n_iterations = scf_params % max_iter results % final_density_error = density_error results % final_energy = total_energy ierr = ERROR_CONVERGENCE_FAILED deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) end subroutine run_kohn_sham_scf_real !> @brief Run self-consistent Kohn-Sham cycle (complex Hamiltonian) !! !! Iterates density → V_xc → H → diagonalize → new density until convergence. !! Uses linear mixing to stabilize convergence. !! !! @param[in] params System parameters (L, n_up, n_down, hopping, BC type) !! @param[in] scf_params SCF control parameters (max_iter, tolerances, mixing) !! @param[in] V_ext External potential V_ext(i) (length L) !! @param[in] xc_func XC functional object (already initialized with tables) !! @param[out] results SCF results (densities, eigenvalues, convergence info) !! @param[out] ierr Error code (0 = success) subroutine run_kohn_sham_scf_complex ( params , scf_params , V_ext , xc_func , results , ierr ) type ( system_params_t ), intent ( in ) :: params type ( scf_params_t ), intent ( in ) :: scf_params real ( dp ), intent ( in ) :: V_ext (:) type ( xc_lsda_t ), intent ( in ) :: xc_func type ( scf_results_t ), intent ( out ) :: results integer , intent ( out ) :: ierr integer :: iter , i , L , Nup , Ndown real ( dp ) :: density_error , total_energy logical :: is_converged type ( adaptive_mix_t ) :: mix_ctrl real ( dp ) :: current_alpha real ( dp ), allocatable :: n_up_in (:), n_down_in (:), n_up_out (:), n_down_out (:), V_xc_up (:), & V_xc_down (:), eigvals_up (:), eigvals_down (:), delta_n_up (:), delta_n_down (:), & delta_n_total (:), V_eff_up (:), V_eff_down (:), V_eff_up_calc (:), V_eff_down_calc (:), & V_zero (:) complex ( dp ), allocatable :: H_up (:,:), H_down (:,:), eigvecs_up (:,:), eigvecs_down (:,:) call validate_kohn_sham_cycle_inputs ( params , scf_params , V_ext , ierr ) if ( ierr /= ERROR_SUCCESS ) then return end if L = params % L Nup = params % Nup Ndown = params % Ndown allocate ( n_up_in ( L ), n_down_in ( L ), n_up_out ( L ), n_down_out ( L ), V_xc_up ( L ), V_xc_down ( L ), & H_up ( L , L ), H_down ( L , L ), eigvals_up ( L ), eigvals_down ( L ), & eigvecs_up ( L , L ), eigvecs_down ( L , L ), delta_n_up ( L ), delta_n_down ( L ), delta_n_total ( L ), & V_eff_up ( L ), V_eff_down ( L ), V_eff_up_calc ( L ), V_eff_down_calc ( L ), V_zero ( L )) ! Initialize zero array for Hamiltonian builder V_zero (:) = 0.0_dp call init_convergence_history ( results % history , scf_params % max_iter , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for history init deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if ! Initialize densities (uniform guess) n_up_in (:) = real ( params % Nup , dp ) / real ( params % L , dp ) n_down_in (:) = real ( params % Ndown , dp ) / real ( params % L , dp ) ! Initialize effective potentials from initial density guess ! This matches C++ initial_guess() function (lsdaks.cc lines 520-521) ! V_eff = V_ext + U*n_other + V_xc do i = 1 , params % L ! Get V_xc from initial uniform density call get_vxc ( xc_func , n_up_in ( i ), n_down_in ( i ), V_xc_up ( i ), V_xc_down ( i ), ierr ) if ( ierr /= ERROR_SUCCESS ) then deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if ! Initialize V_eff = V_ext + U*n_other + V_xc (like C++) V_eff_up ( i ) = V_ext ( i ) + params % U * n_down_in ( i ) + V_xc_up ( i ) V_eff_down ( i ) = V_ext ( i ) + params % U * n_up_in ( i ) + V_xc_down ( i ) end do ! ================================= ! Initialize adaptive mixing (if enabled) ! ================================= if ( scf_params % use_adaptive_mixing ) then call adaptive_mix_init ( mix_ctrl , scf_params % energy_tol ) if ( scf_params % verbose ) then print '(A)' , \"  Using adaptive mixing (C++ behavior)\" end if else if ( scf_params % verbose ) then print '(A,F6.4)' , \"  Using fixed mixing alpha = \" , scf_params % mixing_alpha end if end if ! ================= ! STEP 1: SCF loop ! ================= do iter = 1 , scf_params % max_iter ! ------------------------------------------------- ! 1a. Compute V_xc from current densities ! ------------------------------------------------- do i = 1 , params % L call get_vxc ( xc_func , n_up_in ( i ), n_down_in ( i ), V_xc_up ( i ), V_xc_down ( i ), ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for V_xc calculation deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if end do ! ------------------------------------------------------------- ! 1b. Calculate effective potentials V_eff = V_ext + U*n_other + V_xc ! (This is what C++ calls \"v_ext[σ][j] + u*dens[other][j] + Vxc[σ][j]\") ! ------------------------------------------------------------- do i = 1 , params % L ! V_eff_up_calc = V_ext + U*n_down + V_xc_up V_eff_up_calc ( i ) = V_ext ( i ) + params % U * n_down_in ( i ) + V_xc_up ( i ) ! V_eff_down_calc = V_ext + U*n_up + V_xc_down V_eff_down_calc ( i ) = V_ext ( i ) + params % U * n_up_in ( i ) + V_xc_down ( i ) end do ! ------------------------------------------------------------- ! 1c. Mix potentials (C++ convention: Mix = weight of OLD) ! V_eff_new = Mix*V_eff_old + (1-Mix)*V_eff_calc ! ------------------------------------------------------------- if ( scf_params % use_adaptive_mixing ) then ! Adaptive mixing uses the Mix parameter (updated each iteration) ! Convert to fortran alpha: alpha = 1 - Mix current_alpha = adaptive_mix_get_alpha ( mix_ctrl ) ! Apply mixing: V = (1-α)*V_old + α*V_calc = Mix*V_old + (1-Mix)*V_calc ! Since alpha = 1-Mix, we have: V = Mix*V_old + (1-Mix)*V_calc ✓ do i = 1 , params % L V_eff_up ( i ) = ( 1.0_dp - current_alpha ) * V_eff_up ( i ) + current_alpha * V_eff_up_calc ( i ) V_eff_down ( i ) = ( 1.0_dp - current_alpha ) * V_eff_down ( i ) + current_alpha * V_eff_down_calc ( i ) end do else ! Fixed mixing: alpha = weight of new current_alpha = scf_params % mixing_alpha do i = 1 , params % L V_eff_up ( i ) = ( 1.0_dp - current_alpha ) * V_eff_up ( i ) + current_alpha * V_eff_up_calc ( i ) V_eff_down ( i ) = ( 1.0_dp - current_alpha ) * V_eff_down ( i ) + current_alpha * V_eff_down_calc ( i ) end do end if ! ------------------------------------- ! 1d. Build Hamiltonians with mixed V_eff ! (C++ passes v_eff to hamiltonian_ks) ! ------------------------------------- call build_hamiltonian_complex ( params % L , V_eff_up , V_zero , params % bc , params % phase , H_up , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Hamiltonian Nup build deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if call build_hamiltonian_complex ( params % L , V_eff_down , V_zero , params % bc , params % phase , H_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Hamiltonian Ndown build deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total , V_eff_up , V_eff_down , V_eff_up_calc , V_eff_down_calc , V_zero ) return end if ! --------------------------------- ! 1d. Diagonalize both Hamiltonians ! --------------------------------- call diagonalize_hermitian_complex ( H_up , params % L , eigvals_up , eigvecs_up , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for diagonalization Nup Hamiltonian deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if call diagonalize_hermitian_complex ( H_down , params % L , eigvals_down , eigvecs_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for diagonalization Ndown Hamiltonian deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ---------------------------------------------- ! 1e. Compute new densities from eigenvectors ! ---------------------------------------------- call compute_density_spin ( eigvecs_up , params % L , params % Nup , n_up_out , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for density calculation Nup deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if call compute_density_spin ( eigvecs_down , params % L , params % Ndown , n_down_out , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for density calculation Ndown deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ---------------------------------------------- ! 1f. Compute density differences ! ---------------------------------------------- call compute_density_difference ( n_up_out , n_up_in , params % L , delta_n_up , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Nup density difference deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if call compute_density_difference ( n_down_out , n_down_in , params % L , delta_n_down , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for Ndown density difference deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------------------ ! 1g. Compute total density error ! ------------------------------ delta_n_total = delta_n_up + delta_n_down call compute_density_norm ( delta_n_total , params % L , L2 , density_error , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for total density up norm deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------------ ! 1h. Compute total energy ! ------------------------ call compute_total_energy ( eigvals_up , eigvals_down , params % Nup , params % Ndown , n_up_out , n_down_out , & V_ext , xc_func , params % U , params % L , total_energy , ierr ) if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for total energy calculation deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------ ! 1i. Store history ! ------------------ if ( scf_params % store_history ) then call update_convergence_history ( iter , density_error , total_energy , results % history , ierr ) end if if ( ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for history update deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if ! ------------------------------ ! 1j. Update adaptive mixing (if enabled) ! ------------------------------ if ( scf_params % use_adaptive_mixing ) then call adaptive_mix_update ( mix_ctrl , total_energy ) current_alpha = adaptive_mix_get_alpha ( mix_ctrl ) if ( scf_params % verbose ) then print '(A,I4,A,ES12.4,A,F16.8,A,F7.5)' , \"  Iter \" , iter , \"  |Δn| = \" , density_error , & \"  E_tot = \" , total_energy , \"  α = \" , current_alpha end if ! Check convergence: density-based (primary) OR energy-based (fallback) ! With potential mixing, density converges even if energy oscillates slightly call check_scf_convergence ( delta_n_total , params % L , scf_params % density_tol , & is_converged , ierr ) if ( ierr /= ERROR_SUCCESS . or . . not . is_converged ) then ! Density not converged OR error - fall back to energy-based check is_converged = mix_ctrl % converged end if else current_alpha = scf_params % mixing_alpha if ( scf_params % verbose ) then print '(A,I4,A,ES12.4,A,F16.8)' , \"  Iter \" , iter , \"  |Δn| = \" , density_error , & \"  E_tot = \" , total_energy end if ! 1k. Check convergence (fixed mixing) call check_scf_convergence ( delta_n_total , params % L , scf_params % density_tol , & is_converged , ierr ) end if ! Validate convergence check if (. not . scf_params % use_adaptive_mixing . and . ierr /= ERROR_SUCCESS ) then ! TODO: Proper error handling for convergence check deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) return end if if ( is_converged ) then ! SUCCESS: Converged! results % converged = . true . results % n_iterations = iter results % final_density_error = density_error results % final_energy = total_energy ! Store final densities and eigenvalues allocate ( results % density_up ( params % L )) allocate ( results % density_down ( params % L )) allocate ( results % eigvals ( 2 * params % L )) results % density_up = n_up_out results % density_down = n_down_out results % eigvals ( 1 : params % L ) = eigvals_up results % eigvals ( params % L + 1 : 2 * params % L ) = eigvals_down ierr = ERROR_SUCCESS return ! return SCF LOOP end if ! ----------------------------------------------------------------------- ! 1l. Copy densities directly (NO MIXING!) ! ----------------------------------------------------------------------- ! C++ code does: dens[0][i] = next_dens[0][i]  (line 695-696 in lsdaks.cc) ! Mixing is applied to POTENTIALS, not densities! n_up_in = n_up_out n_down_in = n_down_out end do ! ======================== ! STEP 2: Did not converge ! ======================== results % converged = . false . results % n_iterations = scf_params % max_iter results % final_density_error = density_error results % final_energy = total_energy ierr = ERROR_CONVERGENCE_FAILED deallocate ( n_up_in , n_down_in , n_up_out , n_down_out , V_xc_up , V_xc_down , & H_up , H_down , eigvals_up , eigvals_down , eigvecs_up , eigvecs_down , delta_n_up , & delta_n_down , delta_n_total ) end subroutine run_kohn_sham_scf_complex !> @brief Initialize SCF results structure !! !! @param[out] results SCF results object !! @param[in] L System size !! @param[in] store_history Whether to allocate convergence history !! @param[in] max_iter Maximum iterations (for history size) !! @param[out] ierr Error code (0 = success) subroutine init_scf_results ( results , L , store_history , max_iter , ierr ) type ( scf_results_t ), intent ( out ) :: results integer , intent ( in ) :: L , max_iter logical , intent ( in ) :: store_history integer , intent ( out ) :: ierr results % converged = . false . results % n_iterations = 0 results % final_density_error = 0.0_dp results % final_energy = 0.0_dp if ( store_history ) then call init_convergence_history ( results % history , max_iter , ierr ) end if ierr = ERROR_SUCCESS end subroutine init_scf_results !> @brief Deallocate SCF results !! !! @param[inout] results SCF results object !! @param[out] ierr Error code (0 = success) subroutine cleanup_scf_results ( results , ierr ) type ( scf_results_t ), intent ( inout ) :: results integer , intent ( out ) :: ierr if ( allocated ( results % density_up )) deallocate ( results % density_up ) if ( allocated ( results % density_down )) deallocate ( results % density_down ) if ( allocated ( results % eigvals )) deallocate ( results % eigvals ) call cleanup_convergence_history ( results % history , ierr ) end subroutine cleanup_scf_results end module kohn_sham_cycle","tags":"","url":"sourcefile/kohn_sham_cycle.f90.html"},{"title":"nonlinear_solvers.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~nonlinear_solvers.f90~~EfferentGraph sourcefile~nonlinear_solvers.f90 nonlinear_solvers.f90 sourcefile~bethe_equations.f90 bethe_equations.f90 sourcefile~nonlinear_solvers.f90->sourcefile~bethe_equations.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~nonlinear_solvers.f90->sourcefile~lsda_constants.f90 sourcefile~bethe_equations.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~nonlinear_solvers.f90~~AfferentGraph sourcefile~nonlinear_solvers.f90 nonlinear_solvers.f90 sourcefile~bethe_tables.f90 bethe_tables.f90 sourcefile~bethe_tables.f90->sourcefile~nonlinear_solvers.f90 sourcefile~continuation.f90 continuation.f90 sourcefile~continuation.f90->sourcefile~nonlinear_solvers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Nonlinear solvers for the Bethe Ansatz equations !! !! This module provides robust numerical methods to solve the nonlinear system !! F(x) = 0 arising from the Lieb-Wu equations of the 1D Hubbard model. !! !! Main components: !! - Newton-Raphson method with analytical Jacobian !! - Armijo line search for global convergence !! - LAPACK interface for linear systems !! !! @note All solvers use double precision (real64) arithmetic module nonlinear_solvers use lsda_constants , only : dp , TWOPI , U_SMALL , NEWTON_TOL , NEWTON_MAX_ITER use , intrinsic :: ieee_arithmetic , only : ieee_is_nan use bethe_equations implicit none private public :: solve_newton public :: solve_linear_system public :: line_search !> Armijo condition parameter (c ∈ (0,1)) !! Smaller values = more aggressive line search real ( dp ), parameter :: ARMIJO_C = 1.0e-4_dp !> Maximum iterations for line search backtracking integer , parameter :: MAX_LS_ITER = 20 !> LAPACK interface for solving linear systems A·x = b !! Uses LU decomposition with partial pivoting (DGESV) interface subroutine DGESV ( N , NRHS , A , LDA , IPIV , B , LDB , INFO ) import :: dp integer , intent ( in ) :: N , NRHS , LDA , LDB real ( dp ), intent ( inout ) :: A ( LDA , * ) integer , intent ( out ) :: IPIV ( * ) real ( dp ), intent ( inout ) :: B ( LDB , * ) integer , intent ( out ) :: INFO end subroutine DGESV end interface contains !> Solves linear system A·x = b using LAPACK DGESV !! !! Wrapper for LAPACK's DGESV routine (LU decomposition with partial pivoting). !! Preserves input arrays by creating internal copies. !! !! @param[in]  A  Coefficient matrix (N×N, must be square and non-singular) !! @param[out] x  Solution vector (N) !! @param[in]  b  Right-hand side vector (N) !! !! @note A and b are not modified (copies are used internally) !! @note Stops execution if matrix is singular or dimensions are incompatible !! !! Algorithm: !! 1. Validate dimensions (A square, b and x compatible) !! 2. Create working copies (DGESV destroys input) !! 3. Call DGESV: A = P·L·U, solve L·U·x = P·b !! 4. Check INFO flag (0=success, >0=singular, <0=invalid argument) !! !! @see LAPACK DGESV documentation: https://netlib.org/lapack/explore-html/ subroutine solve_linear_system ( A , x , b ) real ( dp ), intent ( in ) :: A (:,:), b (:) real ( dp ), intent ( out ) :: x (:) integer :: N , LDA , LDB , INFO , NRHS integer , allocatable :: IPIV (:) real ( dp ), allocatable :: A_copy (:,:), b_copy (:) N = size ( A , 1 ) if ( size ( A , 1 ) /= size ( A , 2 )) then error stop \"solve_linear_system: A must be square!\" end if if ( size ( b ) /= N . or . size ( x ) /= N ) then error stop \"solve_linear_system: incompatible dimensions!\" end if ! LAPACK parameters NRHS = 1 ! Number of right-hand sides (solving A·x = b, not A·X = B) LDA = N ! Leading dimension of A LDB = N ! Leading dimension of b allocate ( A_copy ( N , N )) allocate ( b_copy ( N )) allocate ( IPIV ( N )) A_copy = A b_copy = b call DGESV ( N , NRHS , A_copy , LDA , IPIV , b_copy , LDB , INFO ) if ( info == 0 ) then ! Sucess x = b_copy else if ( info > 0 ) then ! Singular matrix (there is no unique solution) write ( * , '(A,I0,A)' ) \"ERROR: Matrix is singular (pivot \" , info , \" is zero)\" error stop \"solve_linear_system: singular matrix!\" else ! info < 0: invalid argument write ( * , '(A,I0,A)' ) \"ERROR: Invalid argument \" , - info , \" in DGESV\" error stop \"solve_linear_system: LAPACK error!\" end if deallocate ( A_copy , b_copy , IPIV ) end subroutine !> Armijo backtracking line search for Newton-Raphson !! !! Finds step size α ∈ (0,1] that satisfies the Armijo condition: !! ||F(x + α·dx)|| < (1 - c·α)·||F(x)|| !! !! This ensures sufficient decrease in the residual norm, providing !! global convergence guarantees for Newton's method. !! !! @param[in] x      Current iterate [k, Λ] (size N↑+M) !! @param[in] dx     Search direction (Newton step) !! @param[in] F_old  Residual at current point !! @param[in] I      Charge quantum numbers !! @param[in] J      Spin quantum numbers !! @param[in] L      Number of lattice sites !! @param[in] U      Hubbard interaction strength !! @return    alpha  Step size (1.0 if full step works, smaller if backtracking) !! !! Algorithm: !! 1. Try full step (α = 1) !! 2. Compute trial point: x_trial = x + α·dx !! 3. Evaluate residual: F_trial = F(x_trial) !! 4. Check Armijo condition: ||F_trial|| < (1 - c·α)·||F_old|| !! 5. If satisfied: return α !! 6. If not: reduce α ← α/2 and repeat (max 20 iterations) !! 7. Fallback: return best α found (even if Armijo fails) !! !! @note If Armijo condition never satisfied, returns α that gives smallest residual !! @note Prints warning if line search fails completely function line_search ( x , dx , F_old , I , J , L , U ) result ( alpha ) real ( dp ), intent ( in ) :: x (:), dx (:), F_old (:), I (:), J (:) real ( dp ), intent ( in ) :: U integer , intent ( in ) :: L real ( dp ) :: alpha , best_alpha , best_norm , norm_F_old , norm_F_trial real ( dp ), allocatable :: k (:), Lambda (:), x_trial (:), F_trial (:) integer :: Nup , M , step alpha = 1.0_dp ! Start with full Newton step best_alpha = alpha best_norm = HUGE ( 1.0_dp ) ! Worst possible norm (infinity) norm_F_old = NORM2 ( F_old ) Nup = size ( I ) M = size ( J ) allocate ( x_trial ( Nup + M )) allocate ( k ( Nup ), Lambda ( M )) do step = 1 , MAX_LS_ITER x_trial = x + alpha * dx k = x_trial ( 1 : Nup ) Lambda = x_trial ( Nup + 1 :) F_trial = compute_residual ( k , Lambda , I , J , L , U ) norm_F_trial = NORM2 ( F_trial ) if ( norm_F_trial < best_norm ) then best_alpha = alpha best_norm = norm_F_trial end if if ( norm_F_trial < ( 1.0_dp - ARMIJO_C * alpha ) * norm_F_old ) then deallocate ( x_trial , k , Lambda ) return end if alpha = alpha / 2.0_dp end do alpha = best_alpha if ( best_norm < norm_F_old ) then print * , \"Warning: Armijo failed, using best alpha =\" , alpha , & \" (reduction:\" , best_norm / norm_F_old , \")\" else print * , \"ERROR: Line search completely failed!\" end if deallocate ( x_trial , k , Lambda ) end function !> Newton-Raphson solver for Bethe Ansatz equations !! !! Solves the nonlinear system F(x) = 0 where x = [k, Λ] are the !! charge and spin rapidities of the Lieb-Wu equations. !! !! Uses Newton-Raphson iteration with: !! - Analytical Jacobian (quadratic convergence) !! - Armijo line search (global convergence) !! - Special handling for U=0 (analytical solution) !! !! @param[inout] x         Solution vector [k₁,...,k_{N↑}, Λ₁,...,Λ_M] !!                         Input: initial guess | Output: solution (if converged) !! @param[in]    I         Charge quantum numbers (N↑) !! @param[in]    J         Spin quantum numbers (M = N↓) !! @param[in]    L         Number of lattice sites !! @param[in]    U         Hubbard interaction strength !! @param[out]   converged .true. if converged, .false. otherwise !! !! Algorithm: !! 1. Special case U≈0: return analytical solution k_j = 2π·I_j/L, Λ=0 !! 2. Newton iteration (max 50 iterations): !!    a) Compute residual F(x) !!    b) Check convergence: ||F|| < TOL !!    c) Compute Jacobian J(x) !!    d) Solve linear system: J·dx = -F !!    e) Line search: find α such that ||F(x+α·dx)|| < ||F(x)|| !!    f) Update: x ← x + α·dx !!    g) Check stagnation: ||dx||/||x|| < TOL !! 3. Return converged flag !! !! Convergence criteria: !! - ||F(x)|| < 1e-10 (residual tolerance) !! - ||dx||/||x|| < 1e-10 (relative step size) !! !! @note For U=0, returns exact solution immediately (no iteration needed) !! @note Prints warnings if stagnation or non-convergence detected !! !! @see compute_residual, compute_jacobian, solve_linear_system, line_search subroutine solve_newton ( x , I , J , L , U , converged ) real ( dp ), intent ( inout ) :: x (:) real ( dp ), intent ( in ) :: I (:), J (:) integer , intent ( in ) :: L real ( dp ), intent ( in ) :: U logical , intent ( out ) :: converged integer :: Nup , M , iter real ( dp ), allocatable :: k (:), Lambda (:), F (:), Jacobian (:,:), dx (:), neg_F (:) real ( dp ) :: norm_F , alpha Nup = size ( I ) M = size ( J ) allocate ( k ( Nup ), Lambda ( M )) allocate ( F ( Nup + M ), neg_F ( Nup + M ), dx ( Nup + M )) allocate ( Jacobian ( Nup + M , Nup + M )) converged = . false . if ( abs ( U ) < U_SMALL ) then ! Analytical solution for U=0 (free Fermi gas) ! k_j = 2π·I_j/L ! Lambda is arbitrary (does not appear in the equations) x ( 1 : Nup ) = TWOPI * I / real ( L , dp ) x ( Nup + 1 :) = 0.0_dp ! Lambda = 0 (arbitrary) converged = . true . return end if do iter = 1 , NEWTON_MAX_ITER k = x ( 1 : Nup ) Lambda = x ( Nup + 1 :) F = compute_residual ( k , Lambda , I , J , L , U ) norm_F = NORM2 ( F ) if ( norm_F < NEWTON_TOL ) then converged = . true . exit end if Jacobian = compute_jacobian ( k , Lambda , L , U ) neg_F = - F call solve_linear_system ( Jacobian , dx , neg_F ) alpha = line_search ( x , dx , F , I , J , L , U ) x = x + alpha * dx if ( NORM2 ( dx ) / ( MAX ( 1.0_dp , NORM2 ( x ))) < NEWTON_TOL ) then if ( norm_F > NEWTON_TOL ) then ! Stagnated without converging print * , \"Warning: Newton-Raphson stagnated at iteration\" , iter print * , \"  Residual norm:\" , norm_F print * , \"  Step norm:\" , NORM2 ( dx ) else ! Stagnated but converged converged = . true . end if exit end if end do if (. not . converged ) then print * , \"Warning: Newton did not converge in\" , NEWTON_MAX_ITER , \"iterations.\" print * , \"  Final residual norm:\" , norm_F end if deallocate ( F , Jacobian , dx , neg_F , k , Lambda ) end subroutine end module nonlinear_solvers","tags":"","url":"sourcefile/nonlinear_solvers.f90.html"},{"title":"bethe_equations.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~bethe_equations.f90~~EfferentGraph sourcefile~bethe_equations.f90 bethe_equations.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~bethe_equations.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~bethe_equations.f90~~AfferentGraph sourcefile~bethe_equations.f90 bethe_equations.f90 sourcefile~bethe_tables.f90 bethe_tables.f90 sourcefile~bethe_tables.f90->sourcefile~bethe_equations.f90 sourcefile~nonlinear_solvers.f90 nonlinear_solvers.f90 sourcefile~bethe_tables.f90->sourcefile~nonlinear_solvers.f90 sourcefile~continuation.f90 continuation.f90 sourcefile~continuation.f90->sourcefile~bethe_equations.f90 sourcefile~continuation.f90->sourcefile~nonlinear_solvers.f90 sourcefile~nonlinear_solvers.f90->sourcefile~bethe_equations.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module bethe_equations use lsda_constants , only : dp , PI , TWOPI , U_SMALL implicit none private public :: theta , Theta_capital public :: dtheta_dx , dTheta_capital_dx public :: dtheta_dU , dTheta_capital_dU public :: initialize_quantum_numbers public :: compute_residual public :: compute_jacobian public :: compute_dFdU public :: compute_energy contains !> charge-spin scattering function θ(x, U) !! !! θ(x, U) = 2·arctan(2x/U) !! !! @param[in] x   Difference in rapidities (k - Λ) !! @param[in] U   Hubbard interaction !! @return        Value of θ(x, U) !! !! @note For U → 0, θ → π·sign(x) function theta ( x , U ) result ( res ) real ( dp ), intent ( in ) :: x , U real ( dp ) :: res if ( abs ( U ) < U_SMALL ) then res = PI * sign ( 1.0_dp , x ) else res = 2.0_dp * atan ( ( 2.0_dp * x ) / U ) end if end function theta !> spin-spin scattering function Θ(x, U) !! !! Θ(x, U) = 2·arctan(x/U) !! !! @param[in] x   Difference in rapidities (Λ - Λ') !! @param[in] U   Hubbard interaction !! @return        Value of Θ(x, U) !! !! @note For U → 0, Θ → π·sign(x) function Theta_capital ( x , U ) result ( res ) real ( dp ), intent ( in ) :: x , U real ( dp ) :: res if ( abs ( U ) < U_SMALL ) then res = PI * sign ( 1.0_dp , x ) else res = 2.0_dp * atan2 ( x , U ) end if end function Theta_capital !> Derivative of the charge-spin scattering function θ with respect to x !! !! dθ/dx = 4U / (U² + 4x²) !! !! @param[in] x   Difference in rapidities !! @param[in] U   Hubbard interaction !! @return        Value of dθ/dx !! !! @note For U → 0, dθ/dx → 0 (except at x=0 where it is singular) function dtheta_dx ( x , U ) result ( res ) real ( dp ), intent ( in ) :: x , U real ( dp ) :: res , denom denom = U ** 2 + 4.0_dp * x ** 2 if ( abs ( U ) < U_SMALL ) then res = 0.0_dp else res = ( 4.0_dp * U ) / denom end if end function dtheta_dx !> Derivative of the function Θ with respect to x !! !! dΘ/dx = 2U / (U² + x²) !! !! @param[in] x   Difference in rapidities !! @param[in] U   Hubbard interaction !! @return        Value of dΘ/dx !! !! @note For U → 0, dΘ/dx → 0 (except at x=0 where it is singular) function dTheta_capital_dx ( x , U ) result ( res ) real ( dp ), intent ( in ) :: x , U real ( dp ) :: res , denom denom = U ** 2 + x ** 2 if ( abs ( U ) < U_SMALL ) then res = 0.0_dp else res = ( 2.0_dp * U ) / denom end if end function dTheta_capital_dx !> Derivative of the charge-spin scattering function θ with respect to U !! !! Calculates ∂θ/∂U = -4x / (U² + 4x²) !! !! This derivative is needed for continuation methods (preditor-corretor) !! to estimate how rapidities change with U. !! !! @param[in] x   Difference in rapidities (k - Λ) !! @param[in] U   Hubbard interaction !! @return        Value of ∂θ/∂U !! !! @note For U → 0, ∂θ/∂U → 0 (θ becomes constant: π·sign(x)) !! @note This is NOT the same as dθ/dx (different partial derivative) !! !! @see dtheta_dx, theta function dtheta_dU ( x , U ) result ( res ) real ( dp ), intent ( in ) :: x , U real ( dp ) :: res , denom if ( abs ( U ) < U_SMALL ) then res = 0.0_dp else denom = U ** 2 + 4.0_dp * x ** 2 res = - ( 4.0_dp * x ) / denom end if end function dtheta_dU !> Derivative of the spin-spin scattering function Θ with respect to U !! !! Calculates ∂Θ/∂U = -2x / (U² + x²) !! !! This derivative is needed for continuation methods to estimate !! how spin rapidities change with the Hubbard interaction strength. !! !! @param[in] x   Difference in rapidities (Λ - Λ') !! @param[in] U   Hubbard interaction !! @return        Value of ∂Θ/∂U !! !! @note For U → 0, ∂Θ/∂U → 0 (Θ becomes constant: π·sign(x)) !! @note This is NOT the same as dΘ/dx (different partial derivative) !! !! @see dTheta_capital_dx, Theta_capital function dTheta_capital_dU ( x , U ) result ( res ) real ( dp ), intent ( in ) :: x , U real ( dp ) :: res , denom if ( abs ( U ) < U_SMALL ) then res = 0.0_dp else denom = U ** 2 + x ** 2 res = - ( 2.0_dp * x ) / denom end if end function dTheta_capital_dU !> Initialize quantum numbers for the ground state !! !! Computes I_k and J_α using Fermi distribution: !!   I_k = k - (N_up + 1)/2,    k = 1, ..., N_up !!   J_α = α - (M + 1)/2,       α = 1, ..., M !! !! @param[in]  N_up   Number of spin-up electrons !! @param[in]  M      Number of spin rapidities (= N_down) !! @param[out] I      Array of charge quantum numbers [1:N_up] !! @param[out] J      Array of spin quantum numbers [1:M] !! !! @note Arrays I and J must be pre-allocated by the caller !! !! Example: !!   N_up = 5  →  I = [-2, -1, 0, 1, 2] !!   M = 3     →  J = [-1, 0, 1] subroutine initialize_quantum_numbers ( Nup , M , I , J_capital ) integer , intent ( in ) :: Nup , M real ( dp ), intent ( out ) :: I (:), J_capital (:) real ( dp ) :: offset_I , offset_J integer :: j , alpha offset_I = ( Nup + 1 ) / 2.0_dp offset_J = ( M + 1 ) / 2.0_dp do j = 1 , Nup I ( j ) = real ( j , dp ) - offset_I end do do alpha = 1 , M J_capital ( alpha ) = real ( alpha , dp ) - offset_J end do end subroutine initialize_quantum_numbers !> Computes the residual vector F(x) for the Lieb-Wu equations of the 1D Hubbard model. !! !! This function evaluates the nonlinear system F(x) = 0, where x = [k, Λ] contains !! the charge and spin rapidities. The residual measures how far the current guess !! is from satisfying the Bethe Ansatz equations. !! !! The system consists of two sets of equations: !! !! **Charge equations** (for j = 1, ..., N↑): !!  F_j&#94;k = k_j - \\frac{2\\pi}{L} I_j - \\frac{1}{L} \\sum_{\\alpha=1}&#94;{M} \\theta(k_j - \\Lambda_\\alpha, U)  !! !! **Spin equations** (for α = 1, ..., M = N↓): !!  F_\\alpha&#94;\\Lambda = \\frac{2\\pi}{L} J_\\alpha - \\sum_{j=1}&#94;{N_\\uparrow} \\theta(\\Lambda_\\alpha - k_j, U) !!    + \\sum_{\\beta \\neq \\alpha} \\Theta(\\Lambda_\\alpha - \\Lambda_\\beta, U)  !! !! @param[in] k         Charge rapidities (size N↑) !! @param[in] Lambda    Spin rapidities (size M = N↓) !! @param[in] I         Charge quantum numbers (size N↑, can be semi-integers) !! @param[in] J_capital Spin quantum numbers (size M, can be semi-integers) !! @param[in] L         Number of lattice sites !! @param[in] U         Hubbard interaction strength !! @return F            Residual vector (size N↑ + M) !! !! @note The residual is zero (F = 0) when the rapidities satisfy the Lieb-Wu equations. !! @note Quantum numbers I and J should be initialized using `initialize_quantum_numbers`. !! !! @see theta, Theta_capital, initialize_quantum_numbers !! function compute_residual ( k , Lambda , I , J_capital , L , U ) result ( F ) real ( dp ), intent ( in ) :: k (:), Lambda (:), I (:), J_capital (:), U integer , intent ( in ) :: L integer :: j , alpha , beta , Nup , M real ( dp ) :: summ , summ1 , summ2 real ( dp ) :: F ( size ( k ) + size ( Lambda )) Nup = size ( k ) M = size ( Lambda ) ! Special case: U ≈ 0 if ( abs ( U ) < U_SMALL ) then ! For U=0, the exact solution is k_j = 2π·I_j/L ! Residual must be exactly zero F ( 1 : Nup ) = k - TWOPI * I / real ( L , dp ) F ( Nup + 1 : Nup + M ) = 0.0_dp ! Lambda is arbitrary return end if ! General case: U > 0 ! Charge equations: F&#94;k do j = 1 , Nup summ = 0.0_dp do alpha = 1 , M summ = summ + theta ( k ( j ) - Lambda ( alpha ), U ) end do F ( j ) = k ( j ) - ( TWOPI * I ( j )) / L - summ / L end do ! Spin equations: F&#94;Lambda do alpha = 1 , M summ1 = 0.0_dp summ2 = 0.0_dp do j = 1 , Nup summ1 = summ1 + theta ( Lambda ( alpha ) - k ( j ), U ) end do do beta = 1 , M if ( beta /= alpha ) then summ2 = summ2 + Theta_capital ( Lambda ( alpha ) - Lambda ( beta ), U ) end if end do F ( Nup + alpha ) = ( TWOPI * J_capital ( alpha )) / L - summ1 + summ2 end do end function compute_residual !> Computes the Jacobian matrix J = ∂F/∂x for the Lieb-Wu equations. !! !! The Jacobian is a square matrix of size (N↑ + M) × (N↑ + M) containing all !! partial derivatives of the residual F with respect to the rapidities x = [k, Λ]. !! It has a 4-block structure: !! !!  J = \\begin{bmatrix} !!   \\frac{\\partial F&#94;k}{\\partial k} & \\frac{\\partial F&#94;k}{\\partial \\Lambda} \\\\ !!   \\frac{\\partial F&#94;\\Lambda}{\\partial k} & \\frac{\\partial F&#94;\\Lambda}{\\partial \\Lambda} !! \\end{bmatrix}  !! !! **Block A** (N↑ × N↑, diagonal): !!  J_{jj} = 1 - \\frac{1}{L} \\sum_{\\alpha=1}&#94;{M} \\frac{4U}{U&#94;2 + 4(k_j - \\Lambda_\\alpha)&#94;2}  !!  J_{ji} = 0 \\quad \\text{for } i \\neq j  !! !! **Block B** (N↑ × M): !!  J_{j,N_\\uparrow+\\beta} = \\frac{1}{L} \\cdot \\frac{4U}{U&#94;2 + 4(k_j - \\Lambda_\\beta)&#94;2}  !! !! **Block C** (M × N↑): !!  J_{N_\\uparrow+\\alpha,i} = \\frac{4U}{U&#94;2 + 4(\\Lambda_\\alpha - k_i)&#94;2}  !! !! **Block D** (M × M): !!  J_{N_\\uparrow+\\alpha,N_\\uparrow+\\gamma} = \\begin{cases} !!   \\sum_j \\frac{4U}{U&#94;2 + 4(\\Lambda_\\alpha - k_j)&#94;2} + \\sum_{\\beta \\neq \\alpha} \\frac{2U}{U&#94;2 + (\\Lambda_\\alpha - \\Lambda_\\beta)&#94;2} & \\text{if } \\gamma = \\alpha \\\\ !!   -\\frac{2U}{U&#94;2 + (\\Lambda_\\alpha - \\Lambda_\\gamma)&#94;2} & \\text{if } \\gamma \\neq \\alpha !! \\end{cases}  !! !! @param[in] k       Charge rapidities (size N↑) !! @param[in] Lambda  Spin rapidities (size M = N↓) !! @param[in] L       Number of lattice sites !! @param[in] U       Hubbard interaction strength !! @return Jacobian   Jacobian matrix (size (N↑+M) × (N↑+M)) !! !! @note This Jacobian is used in Newton-Raphson method to solve J·Δx = -F. !! @note The matrix is dense and fully populated (no sparsity exploitation). !! !! @see compute_residual, dtheta_dx, dTheta_dx !! function compute_jacobian ( k , Lambda , L , U ) result ( Jacobian ) real ( dp ), intent ( in ) :: k (:), Lambda (:), U integer , intent ( in ) :: L integer :: Nup , M , i , j , alpha , beta , gamma real ( dp ) :: Jacobian ( size ( k ) + size ( Lambda ), size ( k ) + size ( Lambda )) real ( dp ) :: summ1 , summ2 Nup = size ( k ) M = size ( Lambda ) !! !!            | Block A  Block B | !! Jacobian = |                  | !!            | Block C  Block D | !! ! Special case: U ≈ 0 (free Fermi gas) if ( abs ( U ) < U_SMALL ) then ! Para U=0, o Jacobiano é identidade (equações desacoplam) Jacobian = 0.0_dp do i = 1 , Nup + M Jacobian ( i , i ) = 1.0_dp end do return end if ! General case: U > 0 !! Block A: dF&#94;k_j/dk_i do j = 1 , Nup do i = 1 , Nup if ( i == j ) then summ1 = 0.0_dp do alpha = 1 , M summ1 = summ1 + ( 4.0_dp * U ) / ( U ** 2 + 4.0_dp * ( k ( j ) - Lambda ( alpha )) ** 2 ) end do Jacobian ( j , i ) = 1.0_dp - ( 1.0_dp / L ) * summ1 else Jacobian ( j , i ) = 0.0_dp end if end do end do !! Block B: dF&#94;k_j/dLambda_beta do j = 1 , Nup do beta = 1 , M Jacobian ( j , Nup + beta ) = ( 1.0_dp / L ) * ( 4.0_dp * U ) / ( U ** 2 + 4.0_dp * ( k ( j ) - Lambda ( beta )) ** 2 ) end do end do !! Block C: dF&#94;Lambda_alpha/dk_i do alpha = 1 , M do i = 1 , Nup Jacobian ( Nup + alpha , i ) = ( 4.0_dp * U ) / ( U ** 2 + 4.0_dp * ( Lambda ( alpha ) - k ( i )) ** 2 ) end do end do !! Block D: dF&#94;Lambda_alpha/dLambda_gamma do alpha = 1 , M do gamma = 1 , M if ( alpha == gamma ) then summ1 = 0.0_dp do j = 1 , Nup summ1 = summ1 + ( 4.0_dp * U ) / ( U ** 2 + 4.0_dp * ( Lambda ( alpha ) - k ( j )) ** 2 ) end do summ2 = 0.0_dp do beta = 1 , M if ( beta /= alpha ) then summ2 = summ2 + ( 2.0_dp * U ) / ( U ** 2 + ( Lambda ( alpha ) - Lambda ( beta )) ** 2 ) end if end do Jacobian ( Nup + alpha , Nup + gamma ) = - ( summ1 - summ2 ) else Jacobian ( Nup + alpha , Nup + gamma ) = - ( 2.0_dp * U ) / ( U ** 2 + ( Lambda ( alpha ) - Lambda ( gamma )) ** 2 ) end if end do end do end function !> Computes the derivative of the residual vector with respect to U: ∂F/∂U !! !! This function calculates how the Lieb-Wu equations change when the !! Hubbard interaction U is varied. It is essential for continuation methods !! (preditor-corretor) to efficiently solve for multiple U values. !! !! The derivative is computed using the chain rule on the Bethe equations: !! !! **Charge equations:** !!  \\frac{\\partial F_j&#94;k}{\\partial U} = -\\frac{1}{L} \\sum_{\\alpha=1}&#94;{M} \\frac{\\partial \\theta}{\\partial U}(k_j - \\Lambda_\\alpha, U)  !! !! **Spin equations:** !!  \\frac{\\partial F_\\alpha&#94;\\Lambda}{\\partial U} = -\\sum_{j=1}&#94;{N_\\uparrow} \\frac{\\partial \\theta}{\\partial U}(\\Lambda_\\alpha - k_j, U) !!    + \\sum_{\\beta \\neq \\alpha} \\frac{\\partial \\Theta}{\\partial U}(\\Lambda_\\alpha - \\Lambda_\\beta, U)  !! !! @param[in] k         Charge rapidities (size N↑) !! @param[in] Lambda    Spin rapidities (size M = N↓) !! @param[in] I         Charge quantum numbers (not used, but kept for consistency) !! @param[in] J_capital Spin quantum numbers (not used, but kept for consistency) !! @param[in] L         Number of lattice sites !! @param[in] U         Hubbard interaction strength !! @return dFdU         Derivative vector ∂F/∂U (size N↑ + M) !! !! @note For U=0, ∂F/∂U = 0 (equations become independent of U) !! @note This is used in implicit derivative: dx/dU = -J⁻¹·(∂F/∂U) !! !! @see compute_residual, dtheta_dU, dTheta_capital_dU function compute_dFdU ( k , Lambda , I , J_capital , L , U ) result ( dFdU ) real ( dp ), intent ( in ) :: k (:), Lambda (:), I (:), J_capital (:), U integer , intent ( in ) :: L integer :: j , alpha , beta , Nup , M real ( dp ) :: summ , summ1 , summ2 real ( dp ) :: dFdU ( size ( k ) + size ( Lambda )) Nup = size ( k ) M = size ( Lambda ) ! Special case: U ≈ 0 if ( abs ( U ) < U_SMALL ) then ! For U=0, F does not depend on U → dF/dU = 0 dFdU = 0.0_dp return end if ! General case: U > 0 ! Charge equations: dF&#94;k/dU do j = 1 , Nup summ = 0.0_dp do alpha = 1 , M summ = summ + dtheta_dU ( k ( j ) - Lambda ( alpha ), U ) end do dFdU ( j ) = - ( 1.0_dp / L ) * summ end do ! Spin equations: dF&#94;Lambda/dU do alpha = 1 , M summ1 = 0.0_dp summ2 = 0.0_dp do j = 1 , Nup summ1 = summ1 + dtheta_dU ( Lambda ( alpha ) - k ( j ), U ) end do do beta = 1 , M if ( beta /= alpha ) then summ2 = summ2 + dTheta_capital_dU ( Lambda ( alpha ) - Lambda ( beta ), U ) end if end do dFdU ( Nup + alpha ) = - summ1 + summ2 end do end function compute_dFdU !> Computes the ground state energy from Bethe Ansatz rapidities !! !! Calculates the total energy of the system using the Bethe Ansatz solution: !! !!  E = -2 \\sum_{j=1}&#94;{N_\\uparrow} \\cos(k_j)  !! !! where k_j are the charge rapidities (momenta) of the electrons. !! !! @param[in] k  Charge rapidities (size N↑) !! @return    E  Total ground state energy !! !! @note Energy is in units of hopping t (t=1 in our convention) !! @note For free Fermi gas (U=0) with symmetric filling, E may be zero due to cancellation !! @note Energy per site: E/L is typically O(1) for moderate densities !! !! Physical interpretation: !! - E < 0: Bound state (electrons gain kinetic energy from hopping) !! - |E| increases with particle number N !! - For U=0, E = kinetic energy only !! - For U>0, this is the total energy (kinetic + interaction via BA) !! !! @see compute_residual, solve_newton function compute_energy ( k ) result ( E ) real ( dp ), intent ( in ) :: k (:) real ( dp ) :: E E = - 2.0_dp * SUM ( COS ( k )) end function compute_energy end module bethe_equations","tags":"","url":"sourcefile/bethe_equations.f90.html"},{"title":"potential_quasiperiodic.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~potential_quasiperiodic.f90~~EfferentGraph sourcefile~potential_quasiperiodic.f90 potential_quasiperiodic.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~potential_quasiperiodic.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~potential_quasiperiodic.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~potential_quasiperiodic.f90~~AfferentGraph sourcefile~potential_quasiperiodic.f90 potential_quasiperiodic.f90 sourcefile~potential_factory.f90 potential_factory.f90 sourcefile~potential_factory.f90->sourcefile~potential_quasiperiodic.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Module for quasiperiodic potential (Aubry-André-Harper model) !! !! Implements the Aubry-André-Harper (AAH) quasiperiodic potential, !! a paradigmatic model for studying localization transitions in 1D systems. !! !! Physical properties: !! - Extended (delocalized) phase for λ < 2 !! - Critical phase at λ = 2 (multifractal wavefunctions) !! - Localized phase for λ > 2 (exponentially localized states) !! !! The potential is given by: !! V(i) = λ cos(2πβi + φ) !! !! where: !! - λ (lambda) controls the potential strength !! - β (beta) is typically an irrational number (golden ratio for maximum incommensurability) !! - φ (phi) is a phase offset in radians !! !! Physics relevance: !! - Models quasicrystalline structures !! - Studies Anderson-like localization without disorder !! - Relevant for cold atoms in bichromatic optical lattices !! - Exhibits metal-insulator transitions module potential_quasiperiodic use lsda_constants , only : dp , PI , TWOPI implicit none private public :: apply_potential_quasiperiodic !> Golden ratio (default for maximum incommensurability) real ( dp ), parameter :: GOLDEN_RATIO = 0.5_dp * ( sqrt ( 5.0_dp ) - 1.0_dp ) contains !> Quasiperiodic potential: V(i) = λ cos(2πβi + φ) !! !! Computes the Aubry-André-Harper potential at all lattice sites. !! For β = golden ratio, the system exhibits: !! - λ < 2: Extended phase (delocalized states) !! - λ = 2: Critical phase (multifractal wavefunctions) !! - λ > 2: Localized phase (exponentially localized states) !! !! @param[in]  lambda  Potential strength (typical range: 0 to 10) !! @param[in]  beta    Quasiperiodic frequency (default: golden ratio ≈ 0.618) !! @param[in]  phi     Phase offset in radians (default: 0) !! @param[in]  L       Number of lattice sites !! @param[out] V       Potential array V(i) for i = 1..L !! @param[out] ierr    Error flag !! !! @note Site indexing starts at 1 (Fortran convention). !!       For site i, the argument is 2πβ(i-1) + φ to start at i=0 physically. !! @note For β = golden ratio: !!       - λ < 2: All states are extended (delocalized) !!       - λ = 2: Critical phase (multifractal wavefunctions) !!       - λ > 2: All states are localized (exponentially decaying) subroutine apply_potential_quasiperiodic ( lambda , beta , phi , L , V , ierr ) use lsda_errors , only : ERROR_SUCCESS , ERROR_NEGATIVE_VALUE , ERROR_OUT_OF_BOUNDS real ( dp ), intent ( in ) :: lambda real ( dp ), intent ( in ) :: beta real ( dp ), intent ( in ) :: phi integer , intent ( in ) :: L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr integer :: i real ( dp ) :: argument ! Initialize V = 0.0_dp ierr = ERROR_SUCCESS ! Validate lambda (potential strength) if ( lambda < 0.0_dp ) then ierr = ERROR_NEGATIVE_VALUE return end if ! Validate beta (quasiperiodic frequency) if ( beta <= 0.0_dp ) then ierr = ERROR_NEGATIVE_VALUE return end if ! Validate L if ( L < 1 ) then ierr = ERROR_OUT_OF_BOUNDS return end if ! Calculate potential at each site ! Use i-1 to make the physical site index start at 0 do i = 1 , L argument = TWOPI * beta * real ( i - 1 , dp ) + phi V ( i ) = lambda * cos ( argument ) end do end subroutine apply_potential_quasiperiodic end module potential_quasiperiodic","tags":"","url":"sourcefile/potential_quasiperiodic.f90.html"},{"title":"spline2d.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~spline2d.f90~~EfferentGraph sourcefile~spline2d.f90 spline2d.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~spline2d.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~spline2d.f90~~AfferentGraph sourcefile~spline2d.f90 spline2d.f90 sourcefile~xc_lsda.f90 xc_lsda.f90 sourcefile~xc_lsda.f90->sourcefile~spline2d.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~xc_lsda.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module spline2d use lsda_constants , only : dp implicit none private type , public :: spline2d_t integer :: n_x !< Number of points in x (n) direction integer :: n_y_max !< Maximum number of points in y (m) direction real ( dp ), allocatable :: x (:) !< Grid points in x direction: x(n_x) real ( dp ), allocatable :: y (:,:) !< Grid points in y direction: y(n_y, n_x) - varies with x! real ( dp ), allocatable :: f (:,:) !< Function values: f(n_y, n_x) integer , allocatable :: n_y (:) !< Number of y points for each x: n_y(n_x) real ( dp ), allocatable :: d2f_dy2 (:,:) !< Second derivatives in y: d2f_dy2(n_y, n_x) logical :: initialized = . false . !< Initialization flag end type spline2d_t public :: spline2d_init public :: spline2d_eval public :: spline2d_destroy private :: spline1d_coeff private :: spline1d_eval private :: find_interval contains !> Compute cubic spline coefficients (second derivatives) for 1D data !! !! Solves tridiagonal system for cubic spline with specified boundary conditions. !! !! Boundary conditions: !! - 'natural': second derivative = 0 at endpoints (natural spline) !! - 'clamped': first derivative specified at endpoints (clamped spline) !! !! Based on the C++ code \"gera_dy2_alternativa\" from the original implementation. !! !! @param[in]  x       Grid points, monotonically increasing, size n+1 (0 to n) !! @param[in]  y       Function values at grid points, size n+1 !! @param[in]  n       Number of intervals (n+1 points total) !! @param[out] d2y     Second derivatives at grid points, size n+1 !! @param[in]  bc_type Boundary condition type: 'natural' or 'clamped' !! @param[in]  dy0     First derivative at x(0) (used if bc_type='clamped') !! @param[in]  dyn     First derivative at x(n) (used if bc_type='clamped') subroutine spline1d_coeff ( x , y , n , d2y , bc_type , dy0 , dyn ) real ( dp ), intent ( in ) :: x ( 0 :), y ( 0 :), dy0 , dyn integer , intent ( in ) :: n real ( dp ), intent ( out ) :: d2y ( 0 :) character ( len =* ), intent ( in ) :: bc_type real ( dp ), allocatable :: a (:), b (:) real ( dp ) :: h0 , h1 integer :: i allocate ( a ( 0 : n ), b ( 0 : n )) if ( trim ( bc_type ) == 'clamped' ) then a ( 0 ) = ( x ( 1 ) - x ( 0 )) / 3.0_dp b ( 0 ) = ( y ( 1 ) - y ( 0 )) / ( x ( 1 ) - x ( 0 )) - dy0 do i = 1 , n - 1 a ( i ) = ( x ( i + 1 ) - x ( i - 1 )) / 3.0_dp b ( i ) = ( y ( i + 1 ) - y ( i )) / ( x ( i + 1 ) - x ( i )) - & ( y ( i ) - y ( i - 1 )) / ( x ( i ) - x ( i - 1 )) end do a ( n ) = ( x ( n ) - x ( n - 1 )) / 3.0_dp b ( n ) = dyn - ( y ( n ) - y ( n - 1 )) / ( x ( n ) - x ( n - 1 )) else a ( 0 ) = 1.0_dp b ( 0 ) = 0.0_dp do i = 1 , n - 1 a ( i ) = ( x ( i + 1 ) - x ( i - 1 )) / 3.0_dp b ( i ) = ( y ( i + 1 ) - y ( i )) / ( x ( i + 1 ) - x ( i )) - & ( y ( i ) - y ( i - 1 )) / ( x ( i ) - x ( i - 1 )) end do a ( n ) = 1.0_dp b ( n ) = 0.0_dp end if ! Forward elimination (Thomas algorithm for tridiagonal system) do i = 1 , n - 1 h0 = x ( i ) - x ( i - 1 ) h1 = x ( i + 1 ) - x ( i ) if ( trim ( bc_type ) == 'clamped' ) then a ( i ) = a ( i ) - h0 * h0 / a ( i - 1 ) / 3 6.0_dp b ( i ) = b ( i ) - b ( i - 1 ) / a ( i - 1 ) * h0 / 6.0_dp else if ( i == 1 ) then cycle end if a ( i ) = a ( i ) - h0 * h0 / a ( i - 1 ) / 3 6.0_dp b ( i ) = b ( i ) - b ( i - 1 ) / a ( i - 1 ) * h0 / 6.0_dp end if end do if ( trim ( bc_type ) == 'clamped' ) then h0 = x ( n ) - x ( n - 1 ) a ( n ) = h0 / 3.0_dp * ( 1.0_dp - h0 / a ( n - 1 ) / 1 2.0_dp ) b ( n ) = b ( n ) - b ( n - 1 ) / a ( n - 1 ) * h0 / 6.0_dp end if ! Back substitution d2y ( n ) = b ( n ) / a ( n ) do i = n - 1 , 1 , - 1 h1 = ( x ( i + 1 ) - x ( i )) / 6.0_dp d2y ( i ) = ( b ( i ) - h1 * d2y ( i + 1 )) / a ( i ) end do if ( trim ( bc_type ) == 'clamped' ) then d2y ( 0 ) = b ( 0 ) / a ( 0 ) - d2y ( 1 ) / 2.0_dp else d2y ( 0 ) = 0.0_dp end if deallocate ( a , b ) end subroutine spline1d_coeff !> Initialize 2D spline from grid data !! !! Constructs cubic spline interpolation for irregular 2D grid. !! For each fixed x_i, computes spline coefficients in y direction. !! !! @param[out] spl      Spline object to initialize !! @param[in]  x_grid   Grid points in x direction (n) !! @param[in]  y_grid   Grid points in y direction (m), shape (n_y_max, n_x) !! @param[in]  f_values Function values on grid, shape (n_y_max, n_x) !! @param[in]  n_y_pts  Number of valid y points for each x, shape (n_x) subroutine spline2d_init ( spl , x_grid , y_grid , f_values , n_y_pts ) type ( spline2d_t ), intent ( out ) :: spl real ( dp ), intent ( in ) :: x_grid (:), y_grid (:,:), f_values (:,:) integer , intent ( in ) :: n_y_pts (:) integer :: i , nx , ny_max , ny nx = size ( x_grid ) ny_max = size ( y_grid , 1 ) spl % n_x = nx spl % n_y_max = ny_max allocate ( spl % x ( nx )) allocate ( spl % y ( ny_max , nx )) allocate ( spl % f ( ny_max , nx )) allocate ( spl % n_y ( nx )) allocate ( spl % d2f_dy2 ( ny_max , nx )) spl % x = x_grid spl % y = y_grid spl % f = f_values spl % n_y = n_y_pts do i = 1 , nx ny = spl % n_y ( i ) if ( ny > 1 ) then ! Create temporary 0-indexed arrays for spline1d_coeff block real ( dp ) :: y_temp ( 0 : ny - 1 ), f_temp ( 0 : ny - 1 ), d2y_temp ( 0 : ny - 1 ) y_temp = spl % y ( 1 : ny , i ) f_temp = spl % f ( 1 : ny , i ) call spline1d_coeff ( y_temp , f_temp , ny - 1 , d2y_temp , 'natural' , 0.0_dp , 0.0_dp ) spl % d2f_dy2 ( 1 : ny , i ) = d2y_temp end block else spl % d2f_dy2 ( 1 , i ) = 0.0_dp end if end do spl % initialized = . true . end subroutine spline2d_init !> Find interval containing x in monotonic array !! !! Binary search to find i such that x_grid(i) <= x < x_grid(i+1) !! Array is assumed to be 0-indexed: x_grid(0), x_grid(1), ..., x_grid(n-1) !! !! @param[in] x_grid Monotonically increasing array (0 to n-1) !! @param[in] n      Array size !! @param[in] x      Point to locate !! @return           Index i of left endpoint (0 to n-2) function find_interval ( x_grid , n , x ) result ( i ) real ( dp ), intent ( in ) :: x_grid ( 0 :), x integer , intent ( in ) :: n integer :: left , right , mid , i if ( x <= x_grid ( 0 )) then i = 0 return end if if ( x >= x_grid ( n - 1 )) then i = n - 2 return end if left = 0 right = n - 1 do while ( right - left > 1 ) mid = ( left + right ) / 2 if ( x < x_grid ( mid )) then right = mid else left = mid end if end do i = left end function find_interval !> Evaluate cubic spline at point x given coefficients !! !! Uses the cubic spline formula with second derivatives. !! !! @param[in] x_grid Grid points (0 to n) !! @param[in] y_grid Function values (0 to n) !! @param[in] d2y    Second derivatives (from spline1d_coeff) !! @param[in] n      Number of intervals (n+1 points) !! @param[in] x      Point to evaluate !! @return           Interpolated value function spline1d_eval ( x_grid , y_grid , d2y , n , x ) result ( y_interp ) real ( dp ), intent ( in ) :: x_grid ( 0 :), y_grid ( 0 :), d2y ( 0 :), x integer , intent ( in ) :: n real ( dp ) :: y_interp , h , a , b integer :: i if ( n == 0 ) then y_interp = y_grid ( 0 ) return end if i = find_interval ( x_grid , n + 1 , x ) if ( i < 0 ) i = 0 if ( i >= n ) i = n - 1 h = x_grid ( i + 1 ) - x_grid ( i ) if ( abs ( h ) < 1.0e-15_dp ) then y_interp = y_grid ( i ) return end if a = ( x_grid ( i + 1 ) - x ) / h b = 1.0_dp - a y_interp = a * y_grid ( i ) + b * y_grid ( i + 1 ) + & (( a ** 3 - a ) * h ** 2 / 6.0_dp ) * d2y ( i ) + & (( b ** 3 - b ) * h ** 2 / 6.0_dp ) * d2y ( i + 1 ) end function spline1d_eval !> Evaluate 2D spline at point (x, y) !! !! Uses separable interpolation: !! 1. Find x interval: x_i <= x <= x_{i+1} !! 2. Evaluate 1D spline at (x_i, y) and (x_{i+1}, y) !! 3. Linearly interpolate between these values in x direction !! !! @param[in] spl Initialized spline object !! @param[in] x   X-coordinate (density n) !! @param[in] y   Y-coordinate (magnetization m) !! @return        Interpolated value f(x, y) function spline2d_eval ( spl , x , y ) result ( f_interp ) type ( spline2d_t ), intent ( in ) :: spl real ( dp ), intent ( in ) :: x , y real ( dp ) :: f_interp , f_left , f_right , t integer :: i_x if (. not . spl % initialized ) then print * , \"ERROR: spline2d not initialized!\" f_interp = 0.0_dp return end if i_x = find_interval ( spl % x , spl % n_x , x ) ! Convert 0-based index to 1-based for Fortran arrays i_x = i_x + 1 if ( spl % n_x == 1 ) then ! Single x point - evaluate 1D spline in y direction block integer :: ny1 real ( dp ) :: y_tmp ( 0 : spl % n_y ( 1 ) - 1 ), f_tmp ( 0 : spl % n_y ( 1 ) - 1 ), d2y_tmp ( 0 : spl % n_y ( 1 ) - 1 ) ny1 = spl % n_y ( 1 ) y_tmp = spl % y ( 1 : ny1 , 1 ) f_tmp = spl % f ( 1 : ny1 , 1 ) d2y_tmp = spl % d2f_dy2 ( 1 : ny1 , 1 ) f_interp = spline1d_eval ( y_tmp , f_tmp , d2y_tmp , ny1 - 1 , y ) end block return end if ! Clamp i_x to valid range if ( i_x < 1 ) i_x = 1 if ( i_x >= spl % n_x ) i_x = spl % n_x - 1 ! Evaluate at left endpoint (i_x) block integer :: ny_left real ( dp ), allocatable :: y_tmp (:), f_tmp (:), d2y_tmp (:) ny_left = spl % n_y ( i_x ) allocate ( y_tmp ( 0 : ny_left - 1 ), f_tmp ( 0 : ny_left - 1 ), d2y_tmp ( 0 : ny_left - 1 )) y_tmp = spl % y ( 1 : ny_left , i_x ) f_tmp = spl % f ( 1 : ny_left , i_x ) d2y_tmp = spl % d2f_dy2 ( 1 : ny_left , i_x ) f_left = spline1d_eval ( y_tmp , f_tmp , d2y_tmp , ny_left - 1 , y ) deallocate ( y_tmp , f_tmp , d2y_tmp ) end block ! Evaluate at right endpoint (i_x+1) block integer :: ny_right real ( dp ), allocatable :: y_tmp (:), f_tmp (:), d2y_tmp (:) ny_right = spl % n_y ( i_x + 1 ) allocate ( y_tmp ( 0 : ny_right - 1 ), f_tmp ( 0 : ny_right - 1 ), d2y_tmp ( 0 : ny_right - 1 )) y_tmp = spl % y ( 1 : ny_right , i_x + 1 ) f_tmp = spl % f ( 1 : ny_right , i_x + 1 ) d2y_tmp = spl % d2f_dy2 ( 1 : ny_right , i_x + 1 ) f_right = spline1d_eval ( y_tmp , f_tmp , d2y_tmp , ny_right - 1 , y ) deallocate ( y_tmp , f_tmp , d2y_tmp ) end block t = ( x - spl % x ( i_x )) / ( spl % x ( i_x + 1 ) - spl % x ( i_x )) f_interp = ( 1.0_dp - t ) * f_left + t * f_right end function spline2d_eval !> Clean up spline object subroutine spline2d_destroy ( spl ) type ( spline2d_t ), intent ( inout ) :: spl if ( allocated ( spl % x )) deallocate ( spl % x ) if ( allocated ( spl % y )) deallocate ( spl % y ) if ( allocated ( spl % f )) deallocate ( spl % f ) if ( allocated ( spl % n_y )) deallocate ( spl % n_y ) if ( allocated ( spl % d2f_dy2 )) deallocate ( spl % d2f_dy2 ) spl % initialized = . false . end subroutine spline2d_destroy end module spline2d","tags":"","url":"sourcefile/spline2d.f90.html"},{"title":"potential_uniform.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~potential_uniform.f90~~EfferentGraph sourcefile~potential_uniform.f90 potential_uniform.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~potential_uniform.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~potential_uniform.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~potential_uniform.f90~~AfferentGraph sourcefile~potential_uniform.f90 potential_uniform.f90 sourcefile~potential_factory.f90 potential_factory.f90 sourcefile~potential_factory.f90->sourcefile~potential_uniform.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Module for uniform (constant) external potential !! !! Implements a constant potential V(i) = V₀ for all sites. !! This is equivalent to a global energy shift and does not affect !! the physics of the system (only absolute energy scale). module potential_uniform use lsda_constants , only : dp implicit none private public :: apply_potential_uniform contains !> Uniform potential: V(i) = V₀ for all i !! !! Creates a constant potential across all lattice sites. !! This corresponds to a global energy shift. !! !! @param[in]  V0    Potential amplitude (constant value) !! @param[in]  L     Number of lattice sites !! @param[out] V     Potential array V(i) = V0 for i = 1..L !! @param[out] ierr  Error flag (always ERROR_SUCCESS for this potential) subroutine apply_potential_uniform ( V0 , L , V , ierr ) use lsda_errors , only : ERROR_SUCCESS real ( dp ), intent ( in ) :: V0 integer , intent ( in ) :: L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr V = V0 ierr = ERROR_SUCCESS end subroutine apply_potential_uniform end module potential_uniform","tags":"","url":"sourcefile/potential_uniform.f90.html"},{"title":"input_parser.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~input_parser.f90~~EfferentGraph sourcefile~input_parser.f90 input_parser.f90 sourcefile~boundary_conditions.f90 boundary_conditions.f90 sourcefile~input_parser.f90->sourcefile~boundary_conditions.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~input_parser.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~input_parser.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_types.f90 lsda_types.f90 sourcefile~input_parser.f90->sourcefile~lsda_types.f90 sourcefile~boundary_conditions.f90->sourcefile~lsda_constants.f90 sourcefile~boundary_conditions.f90->sourcefile~lsda_errors.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~boundary_conditions.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_constants.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_errors.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_types.f90 sourcefile~adaptive_mixing.f90 adaptive_mixing.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~adaptive_mixing.f90 sourcefile~convergence_monitor.f90 convergence_monitor.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~convergence_monitor.f90 sourcefile~density_calculator.f90 density_calculator.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~density_calculator.f90 sourcefile~hamiltonian_builder.f90 hamiltonian_builder.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~hamiltonian_builder.f90 sourcefile~lapack_wrapper.f90 lapack_wrapper.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lapack_wrapper.f90 sourcefile~mixing_schemes.f90 mixing_schemes.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~mixing_schemes.f90 sourcefile~xc_lsda.f90 xc_lsda.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~xc_lsda.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_types.f90->sourcefile~lsda_constants.f90 sourcefile~adaptive_mixing.f90->sourcefile~lsda_constants.f90 sourcefile~adaptive_mixing.f90->sourcefile~lsda_errors.f90 sourcefile~convergence_monitor.f90->sourcefile~lsda_constants.f90 sourcefile~convergence_monitor.f90->sourcefile~lsda_errors.f90 sourcefile~density_calculator.f90->sourcefile~lsda_constants.f90 sourcefile~density_calculator.f90->sourcefile~lsda_errors.f90 sourcefile~hamiltonian_builder.f90->sourcefile~boundary_conditions.f90 sourcefile~hamiltonian_builder.f90->sourcefile~lsda_constants.f90 sourcefile~hamiltonian_builder.f90->sourcefile~lsda_errors.f90 sourcefile~lapack_wrapper.f90->sourcefile~lsda_constants.f90 sourcefile~lapack_wrapper.f90->sourcefile~lsda_errors.f90 sourcefile~mixing_schemes.f90->sourcefile~lsda_constants.f90 sourcefile~mixing_schemes.f90->sourcefile~lsda_errors.f90 sourcefile~xc_lsda.f90->sourcefile~lsda_constants.f90 sourcefile~xc_lsda.f90->sourcefile~lsda_errors.f90 sourcefile~spline2d.f90 spline2d.f90 sourcefile~xc_lsda.f90->sourcefile~spline2d.f90 sourcefile~table_io.f90 table_io.f90 sourcefile~xc_lsda.f90->sourcefile~table_io.f90 sourcefile~spline2d.f90->sourcefile~lsda_constants.f90 sourcefile~table_io.f90->sourcefile~lsda_constants.f90 sourcefile~table_io.f90->sourcefile~lsda_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~input_parser.f90~~AfferentGraph sourcefile~input_parser.f90 input_parser.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Module for parsing input parameters from command line and namelist files !! !! Supports two input modes: !! 1. Namelist file: fpm run lsdaks -- --input input.txt !! 2. Command line:  fpm run lsdaks -- --L 10 --Nup 5 --Ndown 5 --U 4.0 !! !! Priority: Command line arguments override namelist values module input_parser use lsda_constants , only : dp , ITER_MAX , SCF_DENSITY_TOL , SCF_ENERGY_TOL , MIX_ALPHA use lsda_types , only : system_params_t use kohn_sham_cycle , only : scf_params_t use boundary_conditions , only : BC_OPEN , BC_PERIODIC , BC_TWISTED use lsda_errors , only : ERROR_SUCCESS , ERROR_INVALID_INPUT , ERROR_FILE_NOT_FOUND implicit none private !> Input parameters type type , public :: input_params_t ! System parameters integer :: L = 10 integer :: Nup = 5 integer :: Ndown = 5 real ( dp ) :: U = 4.0_dp character ( len = 20 ) :: bc_type = 'periodic' real ( dp ) :: phase = 0.0_dp ! Potential parameters character ( len = 20 ) :: potential_type = 'uniform' real ( dp ) :: V0 = 0.0_dp real ( dp ) :: pot_center = 0.0_dp real ( dp ) :: pot_width = 1.0_dp real ( dp ) :: spring_constant = 0.001_dp ! For harmonic potential (k) real ( dp ) :: concentration = 5 0.0_dp ! For random impurities (%) integer :: pot_seed = - 1 ! Random seed (-1 = system time) character ( len = 500 ) :: imp_positions_str = '' ! For impurity_multiple: '10, 25, 40, 55' real ( dp ) :: disorder_strength = 2.0_dp ! For random disorder (W or sigma) character ( len = 20 ) :: distribution = 'gaussian' ! For random: 'uniform' or 'gaussian' integer :: position = 50 ! For barrier_single: center position integer :: width = 5 ! For barrier_single: width real ( dp ) :: barrier_width = 3.0_dp ! For barrier_double: width of each barrier (Lb) real ( dp ) :: well_depth = - 3.0_dp ! For barrier_double: potential in well (Vwell, typically negative) real ( dp ) :: well_width = 2 0.0_dp ! For barrier_double: width of well between barriers (Lwell) integer :: position1 = 35 ! DEPRECATED for barrier_double integer :: width1 = 3 ! DEPRECATED for barrier_double integer :: position2 = 65 ! DEPRECATED for barrier_double integer :: width2 = 3 ! DEPRECATED for barrier_double ! SCF parameters integer :: max_iter = ITER_MAX real ( dp ) :: density_tol = SCF_DENSITY_TOL real ( dp ) :: energy_tol = SCF_ENERGY_TOL real ( dp ) :: mixing_alpha = MIX_ALPHA logical :: verbose = . true . logical :: store_history = . true . logical :: use_adaptive_mixing = . true . ! Use adaptive mixing (C++ behavior) ! Output parameters character ( len = 100 ) :: output_prefix = 'lsda_output' logical :: save_density = . true . logical :: save_eigenvalues = . true . logical :: save_wavefunction = . false . end type input_params_t public :: parse_inputs public :: validate_inputs public :: convert_to_system_params public :: convert_to_scf_params contains !> Parse inputs from command line or namelist file !! !! @param[out] inputs Parsed input parameters !! @param[out] ierr   Error code (0 = success) subroutine parse_inputs ( inputs , ierr ) type ( input_params_t ), intent ( out ) :: inputs integer , intent ( out ) :: ierr character ( len = 256 ) :: arg , input_file integer :: nargs , i logical :: use_input_file ierr = ERROR_SUCCESS use_input_file = . false . ! Initialize with defaults inputs = input_params_t () ! Check command line arguments nargs = command_argument_count () if ( nargs == 0 ) then ! No arguments: try default input file input_file = 'input.txt' inquire ( file = input_file , exist = use_input_file ) if (. not . use_input_file ) then print * , \"WARNING: No input file or arguments provided.\" print * , \"Using default parameters.\" return end if else ! Parse command line i = 1 do while ( i <= nargs ) call get_command_argument ( i , arg ) select case ( trim ( arg )) case ( '--input' , '-i' ) if ( i + 1 > nargs ) then print * , \"ERROR: --input requires a filename\" ierr = ERROR_INVALID_INPUT return end if call get_command_argument ( i + 1 , input_file ) use_input_file = . true . i = i + 2 case ( '--L' ) call parse_integer_arg ( i , nargs , inputs % L , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--Nup' ) call parse_integer_arg ( i , nargs , inputs % Nup , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--Ndown' ) call parse_integer_arg ( i , nargs , inputs % Ndown , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--U' ) call parse_real_arg ( i , nargs , inputs % U , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--bc' ) if ( i + 1 > nargs ) then print * , \"ERROR: --bc requires a value (open/periodic/twisted)\" ierr = ERROR_INVALID_INPUT return end if call get_command_argument ( i + 1 , inputs % bc_type ) i = i + 2 case ( '--phase' ) call parse_real_arg ( i , nargs , inputs % phase , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--potential' ) if ( i + 1 > nargs ) then print * , \"ERROR: --potential requires a type\" ierr = ERROR_INVALID_INPUT return end if call get_command_argument ( i + 1 , inputs % potential_type ) i = i + 2 case ( '--V0' ) call parse_real_arg ( i , nargs , inputs % V0 , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--concentration' ) call parse_real_arg ( i , nargs , inputs % concentration , ierr ) if ( ierr /= ERROR_SUCCESS ) return i = i + 2 case ( '--verbose' ) inputs % verbose = . true . i = i + 1 case ( '--quiet' ) inputs % verbose = . false . i = i + 1 case ( '--help' , '-h' ) call print_help () ierr = - 1 ! Signal to exit gracefully return case default print * , \"WARNING: Unknown argument: \" , trim ( arg ) i = i + 1 end select end do end if ! Read namelist file if specified if ( use_input_file ) then call read_namelist_file ( input_file , inputs , ierr ) if ( ierr /= ERROR_SUCCESS ) return end if end subroutine parse_inputs !> Read parameters from namelist file !! !! @param[in]    filename Input file path !! @param[inout] inputs   Input parameters (updated from file) !! @param[out]   ierr     Error code subroutine read_namelist_file ( filename , inputs , ierr ) character ( len =* ), intent ( in ) :: filename type ( input_params_t ), intent ( inout ) :: inputs integer , intent ( out ) :: ierr integer :: io_unit , io_stat logical :: file_exists ! System namelist variables integer :: L , Nup , Ndown real ( dp ) :: U , phase character ( len = 20 ) :: bc ! Potential namelist variables character ( len = 20 ) :: potential_type real ( dp ) :: V0 , pot_center , pot_width , concentration , disorder_strength real ( dp ) :: barrier_width , well_depth , well_width integer :: pot_seed , position , width , position1 , width1 , position2 , width2 character ( len = 500 ) :: imp_positions_str character ( len = 20 ) :: distribution ! SCF namelist variables integer :: max_iter real ( dp ) :: density_tol , energy_tol , mixing_alpha logical :: verbose , store_history , use_adaptive_mixing ! Output namelist variables character ( len = 100 ) :: output_prefix logical :: save_density , save_eigenvalues , save_wavefunction namelist / system / L , Nup , Ndown , U , bc , phase namelist / potential / potential_type , V0 , pot_center , pot_width , & concentration , pot_seed , imp_positions_str , & disorder_strength , distribution , position , width , & barrier_width , well_depth , well_width , & position1 , width1 , position2 , width2 namelist / scf / max_iter , density_tol , energy_tol , mixing_alpha , & verbose , store_history , use_adaptive_mixing namelist / output / output_prefix , save_density , save_eigenvalues , & save_wavefunction ierr = ERROR_SUCCESS ! Check if file exists inquire ( file = filename , exist = file_exists ) if (. not . file_exists ) then print * , \"ERROR: Input file not found: \" , trim ( filename ) ierr = ERROR_FILE_NOT_FOUND return end if ! Initialize namelist variables with current values L = inputs % L Nup = inputs % Nup Ndown = inputs % Ndown U = inputs % U bc = inputs % bc_type phase = inputs % phase potential_type = inputs % potential_type V0 = inputs % V0 pot_center = inputs % pot_center pot_width = inputs % pot_width concentration = inputs % concentration pot_seed = inputs % pot_seed imp_positions_str = inputs % imp_positions_str disorder_strength = inputs % disorder_strength distribution = inputs % distribution position = inputs % position width = inputs % width barrier_width = inputs % barrier_width well_depth = inputs % well_depth well_width = inputs % well_width position1 = inputs % position1 width1 = inputs % width1 position2 = inputs % position2 width2 = inputs % width2 max_iter = inputs % max_iter density_tol = inputs % density_tol energy_tol = inputs % energy_tol mixing_alpha = inputs % mixing_alpha verbose = inputs % verbose store_history = inputs % store_history use_adaptive_mixing = inputs % use_adaptive_mixing output_prefix = inputs % output_prefix save_density = inputs % save_density save_eigenvalues = inputs % save_eigenvalues save_wavefunction = inputs % save_wavefunction ! Open and read file open ( newunit = io_unit , file = filename , status = 'old' , iostat = io_stat ) if ( io_stat /= 0 ) then print * , \"ERROR: Could not open file: \" , trim ( filename ) ierr = ERROR_FILE_NOT_FOUND return end if ! Read namelists (silently skip missing sections) read ( io_unit , nml = system , iostat = io_stat ) rewind ( io_unit ) read ( io_unit , nml = potential , iostat = io_stat ) rewind ( io_unit ) read ( io_unit , nml = scf , iostat = io_stat ) rewind ( io_unit ) read ( io_unit , nml = output , iostat = io_stat ) close ( io_unit ) ! Update inputs structure inputs % L = L inputs % Nup = Nup inputs % Ndown = Ndown inputs % U = U inputs % bc_type = bc inputs % phase = phase inputs % potential_type = potential_type inputs % V0 = V0 inputs % pot_center = pot_center inputs % pot_width = pot_width inputs % concentration = concentration inputs % pot_seed = pot_seed inputs % imp_positions_str = imp_positions_str inputs % disorder_strength = disorder_strength inputs % distribution = distribution inputs % position = position inputs % width = width inputs % barrier_width = barrier_width inputs % well_depth = well_depth inputs % well_width = well_width inputs % position1 = position1 inputs % width1 = width1 inputs % position2 = position2 inputs % width2 = width2 inputs % max_iter = max_iter inputs % density_tol = density_tol inputs % energy_tol = energy_tol inputs % mixing_alpha = mixing_alpha inputs % verbose = verbose inputs % store_history = store_history inputs % use_adaptive_mixing = use_adaptive_mixing inputs % output_prefix = output_prefix inputs % save_density = save_density inputs % save_eigenvalues = save_eigenvalues inputs % save_wavefunction = save_wavefunction end subroutine read_namelist_file !> Validate input parameters !! !! @param[in]  inputs Input parameters !! @param[out] ierr   Error code (0 = success) subroutine validate_inputs ( inputs , ierr ) type ( input_params_t ), intent ( in ) :: inputs integer , intent ( out ) :: ierr ierr = ERROR_SUCCESS ! Validate system parameters if ( inputs % L <= 0 ) then print * , \"ERROR: L must be positive, got L =\" , inputs % L ierr = ERROR_INVALID_INPUT return end if if ( inputs % Nup < 0 . or . inputs % Ndown < 0 ) then print * , \"ERROR: Nup and Ndown must be non-negative\" ierr = ERROR_INVALID_INPUT return end if if ( inputs % Nup + inputs % Ndown > 2 * inputs % L ) then print * , \"ERROR: N = Nup + Ndown cannot exceed 2L (Pauli exclusion)\" print * , \"  N =\" , inputs % Nup + inputs % Ndown , \", 2L =\" , 2 * inputs % L ierr = ERROR_INVALID_INPUT return end if ! Validate boundary conditions select case ( trim ( inputs % bc_type )) case ( 'open' , 'periodic' , 'twisted' ) ! Valid case default print * , \"ERROR: Invalid boundary condition: \" , trim ( inputs % bc_type ) print * , \"  Valid options: open, periodic, twisted\" ierr = ERROR_INVALID_INPUT return end select ! Validate concentration for impurity potential if ( trim ( inputs % potential_type ) == 'impurity' ) then if ( inputs % concentration <= 0.0_dp . or . & inputs % concentration > 10 0.0_dp ) then print * , \"ERROR: concentration must be in (0, 100], got:\" , & inputs % concentration ierr = ERROR_INVALID_INPUT return end if end if ! Validate SCF parameters if ( inputs % max_iter <= 0 ) then print * , \"ERROR: max_iter must be positive\" ierr = ERROR_INVALID_INPUT return end if if ( inputs % mixing_alpha <= 0.0_dp . or . inputs % mixing_alpha > 1.0_dp ) then print * , \"ERROR: mixing_alpha must be in (0, 1]\" ierr = ERROR_INVALID_INPUT return end if end subroutine validate_inputs !> Convert input_params_t to system_params_t !! !! @param[in]  inputs     Input parameters !! @param[out] sys_params System parameters !! @param[out] ierr       Error code subroutine convert_to_system_params ( inputs , sys_params , ierr ) type ( input_params_t ), intent ( in ) :: inputs type ( system_params_t ), intent ( out ) :: sys_params integer , intent ( out ) :: ierr ierr = ERROR_SUCCESS sys_params % L = inputs % L sys_params % Nup = inputs % Nup sys_params % Ndown = inputs % Ndown sys_params % U = inputs % U sys_params % phase = inputs % phase ! Convert BC string to integer select case ( trim ( inputs % bc_type )) case ( 'open' ) sys_params % bc = BC_OPEN case ( 'periodic' ) sys_params % bc = BC_PERIODIC case ( 'twisted' ) sys_params % bc = BC_TWISTED case default ierr = ERROR_INVALID_INPUT end select end subroutine convert_to_system_params !> Convert input_params_t to scf_params_t !! !! @param[in]  inputs     Input parameters !! @param[out] scf_params SCF parameters subroutine convert_to_scf_params ( inputs , scf_params ) type ( input_params_t ), intent ( in ) :: inputs type ( scf_params_t ), intent ( out ) :: scf_params scf_params % max_iter = inputs % max_iter scf_params % density_tol = inputs % density_tol scf_params % energy_tol = inputs % energy_tol scf_params % mixing_alpha = inputs % mixing_alpha scf_params % verbose = inputs % verbose scf_params % store_history = inputs % store_history scf_params % use_adaptive_mixing = inputs % use_adaptive_mixing end subroutine convert_to_scf_params !> Parse integer argument from command line subroutine parse_integer_arg ( current_idx , nargs , value , ierr ) integer , intent ( in ) :: current_idx , nargs integer , intent ( out ) :: value integer , intent ( out ) :: ierr character ( len = 256 ) :: arg , arg_name integer :: io_stat if ( current_idx + 1 > nargs ) then call get_command_argument ( current_idx , arg_name ) print * , \"ERROR: \" , trim ( arg_name ), \" requires a value\" ierr = ERROR_INVALID_INPUT return end if call get_command_argument ( current_idx + 1 , arg ) read ( arg , * , iostat = io_stat ) value if ( io_stat /= 0 ) then call get_command_argument ( current_idx , arg_name ) print * , \"ERROR: Invalid integer for \" , trim ( arg_name ), \": \" , trim ( arg ) ierr = ERROR_INVALID_INPUT else ierr = ERROR_SUCCESS end if end subroutine parse_integer_arg !> Parse real argument from command line subroutine parse_real_arg ( current_idx , nargs , value , ierr ) integer , intent ( in ) :: current_idx , nargs real ( dp ), intent ( out ) :: value integer , intent ( out ) :: ierr character ( len = 256 ) :: arg , arg_name integer :: io_stat if ( current_idx + 1 > nargs ) then call get_command_argument ( current_idx , arg_name ) print * , \"ERROR: \" , trim ( arg_name ), \" requires a value\" ierr = ERROR_INVALID_INPUT return end if call get_command_argument ( current_idx + 1 , arg ) read ( arg , * , iostat = io_stat ) value if ( io_stat /= 0 ) then call get_command_argument ( current_idx , arg_name ) print * , \"ERROR: Invalid real number for \" , trim ( arg_name ), \": \" , trim ( arg ) ierr = ERROR_INVALID_INPUT else ierr = ERROR_SUCCESS end if end subroutine parse_real_arg !> Print help message subroutine print_help () print '(A)' , \"\" print '(A)' , \"LSDA-Hubbard: 1D Hubbard Model DFT-LSDA Calculator\" print '(A)' , \"==================================================\" print '(A)' , \"\" print '(A)' , \"Usage:\" print '(A)' , \"  fpm run lsdaks -- --input <file>     # Read from namelist file\" print '(A)' , \"  fpm run lsdaks -- [options]          # Command line mode\" print '(A)' , \"\" print '(A)' , \"System Parameters:\" print '(A)' , \"  --L <int>         Number of lattice sites (default: 10)\" print '(A)' , \"  --Nup <int>       Number of spin-up electrons (default: 5)\" print '(A)' , \"  --Ndown <int>     Number of spin-down electrons (default: 5)\" print '(A)' , \"  --U <real>        Hubbard interaction strength (default: 4.0)\" print '(A)' , \"  --bc <type>       Boundary conditions: open/periodic/twisted (default: periodic)\" print '(A)' , \"  --phase <real>    Twist angle for twisted BC (default: 0.0)\" print '(A)' , \"\" print '(A)' , \"Potential:\" print '(A)' , \"  --potential <type>    Type: uniform/harmonic/impurity/... (default: uniform)\" print '(A)' , \"  --V0 <real>           Potential strength (default: 0.0)\" print '(A)' , \"  --concentration <real> Impurity concentration in % (default: 50.0)\" print '(A)' , \"\" print '(A)' , \"Output:\" print '(A)' , \"  --verbose         Print SCF progress (default: on)\" print '(A)' , \"  --quiet           Suppress SCF progress\" print '(A)' , \"\" print '(A)' , \"Other:\" print '(A)' , \"  --help, -h        Show this help message\" print '(A)' , \"\" print '(A)' , \"Examples:\" print '(A)' , \"  fpm run lsdaks -- --L 10 --Nup 5 --Ndown 5 --U 4.0\" print '(A)' , \"  fpm run lsdaks -- --input my_simulation.txt\" print '(A)' , \"\" end subroutine print_help end module input_parser","tags":"","url":"sourcefile/input_parser.f90.html"},{"title":"potential_harmonic.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~potential_harmonic.f90~~EfferentGraph sourcefile~potential_harmonic.f90 potential_harmonic.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~potential_harmonic.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~potential_harmonic.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~potential_harmonic.f90~~AfferentGraph sourcefile~potential_harmonic.f90 potential_harmonic.f90 sourcefile~potential_factory.f90 potential_factory.f90 sourcefile~potential_factory.f90->sourcefile~potential_harmonic.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Module for harmonic trap potential !! !! Implements a parabolic confining potential centered at the middle of the chain. !! Models optical traps in cold atom systems and creates shell structure. module potential_harmonic use lsda_constants , only : dp implicit none private public :: apply_potential_harmonic contains !> Harmonic trap potential: V(i) = k * (i - i_center)² !! !! Creates a parabolic confining potential centered at the middle of the chain. !! The center is at i_center = (L+1)/2, which works for both odd and even L. !! !! Physical properties: !! - Confines particles at the center !! - Creates shell structure (similar to Landau levels) !! - Density is maximum at center, decays at edges !! - Has parity symmetry: V(i) = V(L+1-i) !! !! @param[in]  k    Spring constant (trap strength), k > 0 !! @param[in]  L    Number of lattice sites !! @param[out] V    Potential array V(i) for i = 1..L !! @param[out] ierr Error flag (always ERROR_SUCCESS for this potential) !! !! @note For k → 0, reduces to uniform potential V = 0 !! @note For k >> 1, creates strong confinement (Landau regime) !! @note Matches C++ lsdaks.cc: V = k*(i-i0)&#94;2 (NO 0.5 factor!) subroutine apply_potential_harmonic ( k , L , V , ierr ) use lsda_errors , only : ERROR_SUCCESS real ( dp ), intent ( in ) :: k integer , intent ( in ) :: L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr real ( dp ) :: i_center integer :: i i_center = real ( L + 1 , dp ) / 2.0_dp ! NOTE: NO 0.5 factor! This matches C++ original code exactly. V = [( k * ( real ( i , dp ) - i_center ) ** 2 , i = 1 , L )] ierr = ERROR_SUCCESS end subroutine apply_potential_harmonic end module potential_harmonic","tags":"","url":"sourcefile/potential_harmonic.f90.html"},{"title":"xc_lsda.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~xc_lsda.f90~~EfferentGraph sourcefile~xc_lsda.f90 xc_lsda.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~xc_lsda.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~xc_lsda.f90->sourcefile~lsda_errors.f90 sourcefile~spline2d.f90 spline2d.f90 sourcefile~xc_lsda.f90->sourcefile~spline2d.f90 sourcefile~table_io.f90 table_io.f90 sourcefile~xc_lsda.f90->sourcefile~table_io.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 sourcefile~spline2d.f90->sourcefile~lsda_constants.f90 sourcefile~table_io.f90->sourcefile~lsda_constants.f90 sourcefile~table_io.f90->sourcefile~lsda_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~xc_lsda.f90~~AfferentGraph sourcefile~xc_lsda.f90 xc_lsda.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~xc_lsda.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Module for LSDA exchange-correlation functional evaluation !! !! This module provides a high-level interface for evaluating the XC functional !! of the 1D Hubbard model at arbitrary points (n_up, n_dw) using: !! 1. Pre-computed Bethe Ansatz tables !! 2. 2D bicubic spline interpolation !! 3. Physical symmetries to cover the full domain !! !! Physical symmetries (4 regions): !!   Region I   (m ≥ 0, n ≤ 1): Direct table lookup !!   Region II  (m < 0, n ≤ 1): Spin exchange symmetry !!   Region III (m < 0, n > 1): Particle-hole symmetry !!   Region IV  (m ≥ 0, n > 1): Combined symmetry module xc_lsda use lsda_constants , only : dp , U_SMALL use spline2d , only : spline2d_t , spline2d_init , spline2d_eval , spline2d_destroy use table_io , only : xc_table_t , read_fortran_table , deallocate_table use lsda_errors , only : ERROR_SUCCESS , ERROR_INVALID_INPUT , ERROR_OUT_OF_BOUNDS , ERROR_FILE_READ , ERROR_SPLINE_INITIALIZATION_FAILED implicit none private !> LSDA XC functional type containing splines for exc, vxc_up, vxc_down type , public :: xc_lsda_t real ( dp ) :: U = 0.0_dp !< Hubbard U parameter type ( spline2d_t ) :: spl_exc !< Spline for e_xc(n, m) type ( spline2d_t ) :: spl_vxc_up !< Spline for V_xc&#94;up(n, m) type ( spline2d_t ) :: spl_vxc_down !< Spline for V_xc&#94;dn(n, m) logical :: initialized = . false . !< Initialization flag end type xc_lsda_t public :: xc_lsda_init public :: get_exc public :: get_vxc public :: xc_lsda_destroy private :: determine_region private :: convert_to_nm private :: apply_symmetry_transform contains !> Initialize XC functional from table file !! !! Loads table and constructs 2D splines for exc, vxc_up, vxc_down. !! !! @param[out] xc         XC functional object !! @param[in]  table_file Path to table file (Fortran binary format) !! @param[out] ierr Error code (0 = success) subroutine xc_lsda_init ( xc , table_file , ierr ) type ( xc_lsda_t ), intent ( out ) :: xc character ( len =* ), intent ( in ) :: table_file integer , intent ( out ) :: ierr type ( xc_table_t ) :: table integer :: io_stat integer , allocatable :: n_y_pts (:) integer :: i ierr = ERROR_SUCCESS call read_fortran_table ( table_file , table , io_stat ) if ( io_stat /= 0 ) then print * , \"ERROR: Failed to read table file: \" , trim ( table_file ) ierr = ERROR_FILE_READ return end if xc % U = table % U ! Create n_y_pts array (same for all n_grid points in current implementation) allocate ( n_y_pts ( table % n_points_n )) do i = 1 , table % n_points_n n_y_pts ( i ) = table % n_points_m end do call spline2d_init ( xc % spl_exc , table % n_grid , table % m_grid , & table % exc , n_y_pts ) call spline2d_init ( xc % spl_vxc_up , table % n_grid , table % m_grid , & table % vxc_up , n_y_pts ) call spline2d_init ( xc % spl_vxc_down , table % n_grid , table % m_grid , & table % vxc_down , n_y_pts ) deallocate ( n_y_pts ) if (. not . xc % spl_exc % initialized . or . & . not . xc % spl_vxc_up % initialized . or . & . not . xc % spl_vxc_down % initialized ) then ierr = ERROR_SPLINE_INITIALIZATION_FAILED call deallocate_table ( table ) return end if xc % initialized = . true . call deallocate_table ( table ) end subroutine xc_lsda_init !> Get exchange-correlation energy per particle at (n_up, n_dw) !! !! Uses symmetries to map any (n_up, n_dw) to Region I and interpolates. !! !! @param[in]  xc   Initialized XC functional !! @param[in]  n_up Spin-up density (0 ≤ n_up ≤ 1) !! @param[in]  n_dw Spin-down density (0 ≤ n_dw ≤ 1) !! @param[out] exc  Exchange-correlation energy e_xc !! @param[out] ierr Error code (0 = success) subroutine get_exc ( xc , n_up , n_dw , exc , ierr ) type ( xc_lsda_t ), intent ( in ) :: xc real ( dp ), intent ( in ) :: n_up , n_dw real ( dp ), intent ( out ) :: exc integer , intent ( out ) :: ierr integer :: region real ( dp ) :: n_up_map , n_dw_map , n , m ! Check initialization if (. not . xc % initialized ) then exc = 0.0_dp ierr = ERROR_INVALID_INPUT return end if ! Special case: U = 0 (free Fermi gas) if ( abs ( xc % U ) < U_SMALL ) then exc = 0.0_dp ierr = ERROR_SUCCESS return end if ! Check density bounds ! Note: Particle-hole symmetry allows n_up, n_down > 1.0 ! Maximum total density is n_up + n_down ≤ 2 (Pauli exclusion) ! Use small tolerance to handle floating-point roundoff (e.g., 1.0+1.0 = 2.0000...009) if ( n_up < - 1.0e-12_dp . or . n_dw < - 1.0e-12_dp . or . & ( n_up + n_dw ) > 2.0_dp + 1.0e-10_dp ) then exc = 0.0_dp ierr = ERROR_OUT_OF_BOUNDS return end if ! Special case: both densities zero if ( n_up < 1.0e-12_dp . and . n_dw < 1.0e-12_dp ) then exc = 0.0_dp ierr = ERROR_SUCCESS return end if ! Determine region and apply symmetry region = determine_region ( n_up , n_dw ) call apply_symmetry_transform ( region , n_up , n_dw , n_up_map , n_dw_map ) ! Clip to valid range to handle numerical errors near boundaries ! This is especially important for n ≈ 2.0 where particle-hole transform ! can produce small negative values due to roundoff n_up_map = max ( 0.0_dp , min ( 1.0_dp , n_up_map )) n_dw_map = max ( 0.0_dp , min ( 1.0_dp , n_dw_map )) call convert_to_nm ( n_up_map , n_dw_map , n , m ) ! Evaluate spline exc = spline2d_eval ( xc % spl_exc , n , m ) ierr = ERROR_SUCCESS end subroutine get_exc !> Get exchange-correlation potentials at (n_up, n_dw) !! !! Returns V_xc&#94;up and V_xc&#94;dn using symmetries. !! !! @param[in]  xc      Initialized XC functional !! @param[in]  n_up    Spin-up density (0 ≤ n_up ≤ 1) !! @param[in]  n_dw    Spin-down density (0 ≤ n_dw ≤ 1) !! @param[out] v_xc_up XC potential for spin-up !! @param[out] v_xc_dw XC potential for spin-down !! @param[out] ierr    Error code (0 = success) subroutine get_vxc ( xc , n_up , n_dw , v_xc_up , v_xc_dw , ierr ) type ( xc_lsda_t ), intent ( in ) :: xc real ( dp ), intent ( in ) :: n_up , n_dw real ( dp ), intent ( out ) :: v_xc_up , v_xc_dw integer , intent ( out ) :: ierr integer :: region real ( dp ) :: n_up_map , n_dw_map , n , m real ( dp ) :: v_up_base , v_dw_base ! Check initialization if (. not . xc % initialized ) then v_xc_up = 0.0_dp v_xc_dw = 0.0_dp ierr = ERROR_INVALID_INPUT return end if ! Special case: U = 0 (free Fermi gas) if ( abs ( xc % U ) < U_SMALL ) then v_xc_up = 0.0_dp v_xc_dw = 0.0_dp ierr = ERROR_SUCCESS return end if ! Check density bounds ! Note: Particle-hole symmetry allows n_up, n_down > 1.0 ! Maximum total density is n_up + n_down ≤ 2 (Pauli exclusion) ! Use small tolerance to handle floating-point roundoff (e.g., 1.0+1.0 = 2.0000...009) if ( n_up < - 1.0e-12_dp . or . n_dw < - 1.0e-12_dp . or . & ( n_up + n_dw ) > 2.0_dp + 1.0e-10_dp ) then v_xc_up = 0.0_dp v_xc_dw = 0.0_dp ierr = ERROR_OUT_OF_BOUNDS return end if ! Special case: both densities zero if ( n_up < 1.0e-12_dp . and . n_dw < 1.0e-12_dp ) then v_xc_up = 0.0_dp v_xc_dw = 0.0_dp ierr = ERROR_SUCCESS return end if ! Determine region and apply symmetry region = determine_region ( n_up , n_dw ) call apply_symmetry_transform ( region , n_up , n_dw , n_up_map , n_dw_map ) ! Clip to valid range to handle numerical errors near boundaries n_up_map = max ( 0.0_dp , min ( 1.0_dp , n_up_map )) n_dw_map = max ( 0.0_dp , min ( 1.0_dp , n_dw_map )) call convert_to_nm ( n_up_map , n_dw_map , n , m ) ! Evaluate splines v_up_base = spline2d_eval ( xc % spl_vxc_up , n , m ) v_dw_base = spline2d_eval ( xc % spl_vxc_down , n , m ) ! Apply region-specific transformations select case ( region ) case ( 1 ) ! Region I (m ≥ 0, n ≤ 1): Direct v_xc_up = v_up_base v_xc_dw = v_dw_base case ( 2 ) ! Region II (m < 0, n ≤ 1): Spin exchange v_xc_up = v_dw_base v_xc_dw = v_up_base case ( 3 ) ! Region III (m < 0, n > 1): Particle-hole symmetry v_xc_up = - v_up_base v_xc_dw = - v_dw_base case ( 4 ) ! Region IV (m ≥ 0, n > 1): Combined v_xc_up = - v_dw_base v_xc_dw = - v_up_base end select ierr = ERROR_SUCCESS end subroutine get_vxc !> Destroy XC functional and free memory !! !! @param[inout] xc XC functional object subroutine xc_lsda_destroy ( xc ) type ( xc_lsda_t ), intent ( inout ) :: xc call spline2d_destroy ( xc % spl_exc ) call spline2d_destroy ( xc % spl_vxc_up ) call spline2d_destroy ( xc % spl_vxc_down ) xc % initialized = . false . xc % U = 0.0_dp end subroutine xc_lsda_destroy !> Determine symmetry region for (n_up, n_dw) !! !! Region I:   m ≥ 0 and n ≤ 1 !! Region II:  m < 0 and n ≤ 1 !! Region III: m < 0 and n > 1 !! Region IV:  m ≥ 0 and n > 1 !! !! @param[in] n_up Spin-up density !! @param[in] n_dw Spin-down density !! @return         Region number (1-4) function determine_region ( n_up , n_dw ) result ( region ) real ( dp ), intent ( in ) :: n_up , n_dw integer :: region real ( dp ) :: n , m real ( dp ), parameter :: TOL = 1.0e-12_dp ! Tolerance for boundary cases n = n_up + n_dw m = n_up - n_dw ! Use tolerances to handle floating-point errors at n = 1.0 boundary ! This is critical for half-filling cases where n = n_up + n_down = 1.0 if ( m >= - TOL . and . n <= 1.0_dp + TOL ) then region = 1 else if ( m < - TOL . and . n <= 1.0_dp + TOL ) then region = 2 else if ( m < - TOL . and . n > 1.0_dp + TOL ) then region = 3 else region = 4 ! m ≥ 0 and n > 1 end if end function determine_region !> Convert (n_up, n_dw) to (n, m) coordinates !! !! n = n_up + n_dw (total density) !! m = n_up - n_dw (magnetization) !! !! @param[in]  n_up Spin-up density !! @param[in]  n_dw Spin-down density !! @param[out] n    Total density !! @param[out] m    Magnetization subroutine convert_to_nm ( n_up , n_dw , n , m ) real ( dp ), intent ( in ) :: n_up , n_dw real ( dp ), intent ( out ) :: n , m n = n_up + n_dw m = n_up - n_dw end subroutine convert_to_nm !> Apply symmetry transformation to map any region to Region I !! !! Transformations: !! Region I:   (n_up, n_dw) → (n_up, n_dw) !! Region II:  (n_up, n_dw) → (n_dw, n_up)     [spin exchange] !! Region III: (n_up, n_dw) → (1-n_up, 1-n_dw) [particle-hole] !! Region IV:  (n_up, n_dw) → (1-n_dw, 1-n_up) [combined] !! !! @param[in]  region   Symmetry region (1-4) !! @param[in]  n_up     Original spin-up density !! @param[in]  n_dw     Original spin-down density !! @param[out] n_up_map Mapped spin-up density !! @param[out] n_dw_map Mapped spin-down density subroutine apply_symmetry_transform ( region , n_up , n_dw , n_up_map , n_dw_map ) integer , intent ( in ) :: region real ( dp ), intent ( in ) :: n_up , n_dw real ( dp ), intent ( out ) :: n_up_map , n_dw_map select case ( region ) case ( 1 ) ! Region I: Direct (no transformation) n_up_map = n_up n_dw_map = n_dw case ( 2 ) ! Region II: Spin exchange n_up_map = n_dw n_dw_map = n_up case ( 3 ) ! Region III: Particle-hole symmetry n_up_map = 1.0_dp - n_up n_dw_map = 1.0_dp - n_dw case ( 4 ) ! Region IV: Combined (particle-hole + spin exchange) n_up_map = 1.0_dp - n_dw n_dw_map = 1.0_dp - n_up case default ! Should never happen (region is always 1-4 from determine_region) ! Return identity transformation as fallback n_up_map = n_up n_dw_map = n_dw end select end subroutine apply_symmetry_transform end module xc_lsda","tags":"","url":"sourcefile/xc_lsda.f90.html"},{"title":"lsda_errors.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~lsda_errors.f90~~EfferentGraph sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~lsda_errors.f90~~AfferentGraph sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~adaptive_mixing.f90 adaptive_mixing.f90 sourcefile~adaptive_mixing.f90->sourcefile~lsda_errors.f90 sourcefile~boundary_conditions.f90 boundary_conditions.f90 sourcefile~boundary_conditions.f90->sourcefile~lsda_errors.f90 sourcefile~convergence_monitor.f90 convergence_monitor.f90 sourcefile~convergence_monitor.f90->sourcefile~lsda_errors.f90 sourcefile~degeneracy_handler.f90 degeneracy_handler.f90 sourcefile~degeneracy_handler.f90->sourcefile~lsda_errors.f90 sourcefile~density_calculator.f90 density_calculator.f90 sourcefile~density_calculator.f90->sourcefile~lsda_errors.f90 sourcefile~hamiltonian_builder.f90 hamiltonian_builder.f90 sourcefile~hamiltonian_builder.f90->sourcefile~lsda_errors.f90 sourcefile~hamiltonian_builder.f90->sourcefile~boundary_conditions.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~lsda_errors.f90 sourcefile~input_parser.f90->sourcefile~boundary_conditions.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_errors.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~adaptive_mixing.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~boundary_conditions.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~convergence_monitor.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~density_calculator.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~hamiltonian_builder.f90 sourcefile~lapack_wrapper.f90 lapack_wrapper.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lapack_wrapper.f90 sourcefile~mixing_schemes.f90 mixing_schemes.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~mixing_schemes.f90 sourcefile~xc_lsda.f90 xc_lsda.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~xc_lsda.f90 sourcefile~lapack_wrapper.f90->sourcefile~lsda_errors.f90 sourcefile~mixing_schemes.f90->sourcefile~lsda_errors.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~lsda_errors.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~potential_barrier.f90 potential_barrier.f90 sourcefile~potential_barrier.f90->sourcefile~lsda_errors.f90 sourcefile~potential_factory.f90 potential_factory.f90 sourcefile~potential_factory.f90->sourcefile~lsda_errors.f90 sourcefile~potential_factory.f90->sourcefile~potential_barrier.f90 sourcefile~potential_harmonic.f90 potential_harmonic.f90 sourcefile~potential_factory.f90->sourcefile~potential_harmonic.f90 sourcefile~potential_impurity.f90 potential_impurity.f90 sourcefile~potential_factory.f90->sourcefile~potential_impurity.f90 sourcefile~potential_quasiperiodic.f90 potential_quasiperiodic.f90 sourcefile~potential_factory.f90->sourcefile~potential_quasiperiodic.f90 sourcefile~potential_random.f90 potential_random.f90 sourcefile~potential_factory.f90->sourcefile~potential_random.f90 sourcefile~potential_uniform.f90 potential_uniform.f90 sourcefile~potential_factory.f90->sourcefile~potential_uniform.f90 sourcefile~potential_harmonic.f90->sourcefile~lsda_errors.f90 sourcefile~potential_impurity.f90->sourcefile~lsda_errors.f90 sourcefile~potential_quasiperiodic.f90->sourcefile~lsda_errors.f90 sourcefile~potential_random.f90->sourcefile~lsda_errors.f90 sourcefile~potential_uniform.f90->sourcefile~lsda_errors.f90 sourcefile~table_io.f90 table_io.f90 sourcefile~table_io.f90->sourcefile~lsda_errors.f90 sourcefile~xc_lsda.f90->sourcefile~lsda_errors.f90 sourcefile~xc_lsda.f90->sourcefile~table_io.f90 sourcefile~bethe_tables.f90 bethe_tables.f90 sourcefile~bethe_tables.f90->sourcefile~table_io.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Module for centralized error handling !! !! Provides consistent error codes, messages, and handling across the project. !! All modules should use these error codes for uniformity. !! !! Error code ranges: !! - 0: Success !! - 1-99: Input validation errors !! - 100-199: Numerical/computational errors !! - 200-299: I/O errors !! - 300-399: Memory allocation errors module lsda_errors use lsda_constants , only : dp implicit none private ! Public error handling routines public :: error_handler public :: check_bounds public :: check_positive public :: check_range public :: get_error_message ! Public error codes public :: ERROR_SUCCESS public :: ERROR_INVALID_INPUT public :: ERROR_OUT_OF_BOUNDS public :: ERROR_SIZE_MISMATCH public :: ERROR_INVALID_CONCENTRATION public :: ERROR_NEGATIVE_VALUE public :: ERROR_INVALID_RANGE public :: ERROR_NOT_A_NUMBER public :: ERROR_UNPHYSICAL_DENSITY public :: ERROR_SPLINE_INITIALIZATION_FAILED public :: ERROR_CONVERGENCE_FAILED public :: ERROR_SINGULAR_MATRIX public :: ERROR_LAPACK_FAILED public :: ERROR_LAPACK_INVALID_ARG public :: ERROR_LINEAR_DEPENDENCE public :: ERROR_FILE_NOT_FOUND public :: ERROR_FILE_READ public :: ERROR_FILE_WRITE public :: ERROR_ALLOCATION_FAILED public :: ERROR_DEALLOCATION_FAILED ! Error codes - General integer , parameter :: ERROR_SUCCESS = 0 integer , parameter :: ERROR_INVALID_INPUT = 1 integer , parameter :: ERROR_OUT_OF_BOUNDS = 2 integer , parameter :: ERROR_SIZE_MISMATCH = 3 integer , parameter :: ERROR_INVALID_CONCENTRATION = 4 integer , parameter :: ERROR_NEGATIVE_VALUE = 5 integer , parameter :: ERROR_INVALID_RANGE = 6 integer , parameter :: ERROR_NOT_A_NUMBER = 7 integer , parameter :: ERROR_UNPHYSICAL_DENSITY = 8 integer , parameter :: ERROR_SPLINE_INITIALIZATION_FAILED = 9 ! Error codes - Numerical (100-199) integer , parameter :: ERROR_CONVERGENCE_FAILED = 100 integer , parameter :: ERROR_SINGULAR_MATRIX = 101 integer , parameter :: ERROR_LAPACK_FAILED = 102 integer , parameter :: ERROR_LAPACK_INVALID_ARG = 103 integer , parameter :: ERROR_LINEAR_DEPENDENCE = 104 ! Error codes - I/O (200-299) integer , parameter :: ERROR_FILE_NOT_FOUND = 200 integer , parameter :: ERROR_FILE_READ = 201 integer , parameter :: ERROR_FILE_WRITE = 202 ! Error codes - Memory (300-399) integer , parameter :: ERROR_ALLOCATION_FAILED = 300 integer , parameter :: ERROR_DEALLOCATION_FAILED = 301 contains !> Get human-readable error message for a given error code !! !! @param[in] ierr  Error code !! @return    msg   Error message string function get_error_message ( ierr ) result ( msg ) integer , intent ( in ) :: ierr character ( len = 256 ) :: msg select case ( ierr ) ! Success case ( ERROR_SUCCESS ) msg = \"Success\" ! Input validation errors (1-99) case ( ERROR_INVALID_INPUT ) msg = \"Invalid input parameter\" case ( ERROR_OUT_OF_BOUNDS ) msg = \"Value out of valid bounds\" case ( ERROR_SIZE_MISMATCH ) msg = \"Array size mismatch\" case ( ERROR_INVALID_CONCENTRATION ) msg = \"Invalid concentration (must be 0 < c <= 100)\" case ( ERROR_NEGATIVE_VALUE ) msg = \"Value must be non-negative\" case ( ERROR_INVALID_RANGE ) msg = \"Value outside valid range\" case ( ERROR_NOT_A_NUMBER ) msg = \"Array contains NaN or Inf values\" case ( ERROR_UNPHYSICAL_DENSITY ) msg = \"Unphysical density values detected\" case ( ERROR_SPLINE_INITIALIZATION_FAILED ) msg = \"Spline initialization failed\" ! Numerical errors (100-199) case ( ERROR_CONVERGENCE_FAILED ) msg = \"Numerical convergence failed\" case ( ERROR_SINGULAR_MATRIX ) msg = \"Matrix is singular or ill-conditioned\" case ( ERROR_LAPACK_FAILED ) msg = \"LAPACK routine failed\" case ( ERROR_LAPACK_INVALID_ARG ) msg = \"Invalid argument passed to LAPACK routine\" case ( ERROR_LINEAR_DEPENDENCE ) msg = \"Linear dependence detected in vector set\" ! I/O errors (200-299) case ( ERROR_FILE_NOT_FOUND ) msg = \"File not found\" case ( ERROR_FILE_READ ) msg = \"Error reading file\" case ( ERROR_FILE_WRITE ) msg = \"Error writing file\" ! Memory errors (300-399) case ( ERROR_ALLOCATION_FAILED ) msg = \"Memory allocation failed\" case ( ERROR_DEALLOCATION_FAILED ) msg = \"Memory deallocation failed\" case default write ( msg , '(A,I0)' ) \"Unknown error code: \" , ierr end select end function get_error_message !> Generic error handler that prints error messages !! !! @param[in] ierr          Error code !! @param[in] routine_name  Name of the routine where error occurred !! @param[in] extra_info    Optional additional information (default: \"\") !! @param[in] fatal         If .true., stop execution (default: .false.) subroutine error_handler ( ierr , routine_name , extra_info , fatal ) integer , intent ( in ) :: ierr character ( len =* ), intent ( in ) :: routine_name character ( len =* ), intent ( in ), optional :: extra_info logical , intent ( in ), optional :: fatal character ( len = 256 ) :: msg logical :: is_fatal ! Check if fatal (default is .false.) is_fatal = . false . if ( present ( fatal )) is_fatal = fatal ! If success, do nothing if ( ierr == ERROR_SUCCESS ) return ! Get error message msg = get_error_message ( ierr ) ! Print error write ( * , '(A)' ) \"============================================\" write ( * , '(A,I0)' ) \"ERROR CODE: \" , ierr write ( * , '(A,A)' ) \"ROUTINE:    \" , trim ( routine_name ) write ( * , '(A,A)' ) \"MESSAGE:    \" , trim ( msg ) if ( present ( extra_info )) then if ( len_trim ( extra_info ) > 0 ) then write ( * , '(A,A)' ) \"DETAILS:    \" , trim ( extra_info ) end if end if write ( * , '(A)' ) \"============================================\" ! Stop if fatal if ( is_fatal ) then write ( * , '(A)' ) \"FATAL ERROR - Stopping execution\" stop 1 end if end subroutine error_handler !> Check if a value is within bounds [min_val, max_val] !! !! @param[in]  val      Value to check !! @param[in]  min_val  Minimum allowed value !! @param[in]  max_val  Maximum allowed value !! @param[out] ierr     ERROR_SUCCESS or ERROR_OUT_OF_BOUNDS subroutine check_bounds ( val , min_val , max_val , ierr ) integer , intent ( in ) :: val , min_val , max_val integer , intent ( out ) :: ierr if ( val < min_val . or . val > max_val ) then ierr = ERROR_OUT_OF_BOUNDS else ierr = ERROR_SUCCESS end if end subroutine check_bounds !> Check if a value is positive (> 0) or non-negative (>= 0) !! !! @param[in]  val           Value to check !! @param[in]  allow_zero    If .true., accepts 0; if .false., requires > 0 !! @param[out] ierr          ERROR_SUCCESS or ERROR_NEGATIVE_VALUE subroutine check_positive ( val , allow_zero , ierr ) real ( dp ), intent ( in ) :: val logical , intent ( in ) :: allow_zero integer , intent ( out ) :: ierr if ( allow_zero ) then ! Check val >= 0 if ( val < 0.0_dp ) then ierr = ERROR_NEGATIVE_VALUE else ierr = ERROR_SUCCESS end if else ! Check val > 0 if ( val <= 0.0_dp ) then ierr = ERROR_NEGATIVE_VALUE else ierr = ERROR_SUCCESS end if end if end subroutine check_positive !> Check if a value is within a real range [min_val, max_val] !! !! @param[in]  val      Value to check !! @param[in]  min_val  Minimum allowed value !! @param[in]  max_val  Maximum allowed value !! @param[out] ierr     ERROR_SUCCESS or ERROR_INVALID_RANGE subroutine check_range ( val , min_val , max_val , ierr ) real ( dp ), intent ( in ) :: val , min_val , max_val integer , intent ( out ) :: ierr if ( val < min_val . or . val > max_val ) then ierr = ERROR_INVALID_RANGE else ierr = ERROR_SUCCESS end if end subroutine check_range end module lsda_errors","tags":"","url":"sourcefile/lsda_errors.f90.html"},{"title":"hamiltonian_builder.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~hamiltonian_builder.f90~~EfferentGraph sourcefile~hamiltonian_builder.f90 hamiltonian_builder.f90 sourcefile~boundary_conditions.f90 boundary_conditions.f90 sourcefile~hamiltonian_builder.f90->sourcefile~boundary_conditions.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~hamiltonian_builder.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~hamiltonian_builder.f90->sourcefile~lsda_errors.f90 sourcefile~boundary_conditions.f90->sourcefile~lsda_constants.f90 sourcefile~boundary_conditions.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~hamiltonian_builder.f90~~AfferentGraph sourcefile~hamiltonian_builder.f90 hamiltonian_builder.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~hamiltonian_builder.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module hamiltonian_builder use lsda_constants , only : dp use lsda_errors , only : ERROR_INVALID_INPUT , & ERROR_SIZE_MISMATCH , ERROR_NOT_A_NUMBER use , intrinsic :: ieee_arithmetic , only : ieee_is_finite use boundary_conditions , only : apply_boundary_conditions , & apply_boundary_conditions_complex implicit none private public :: validate_hamiltonian_inputs public :: build_hamiltonian public :: build_hamiltonian_complex public :: build_hamiltonian_free public :: compute_effective_potential contains !> @brief Validate Hamiltonian construction inputs !! !! Checks that system size and potential arrays are valid: !! - L > 0 !! - Array sizes match L !! - No NaN or Inf values in potentials !! !! @param[in] L Number of lattice sites !! @param[in] V_ext External potential array !! @param[in] V_xc Exchange-correlation potential array !! @param[out] ierr Error code (0=success) subroutine validate_hamiltonian_inputs ( L , V_ext , V_xc , ierr ) ! No hopping parameter as input - assuming t = 1 integer , intent ( in ) :: L real ( dp ), intent ( in ) :: V_ext (:) real ( dp ), intent ( in ) :: V_xc (:) integer , intent ( out ) :: ierr ierr = 0 if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( V_ext ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( V_xc ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if (. not . ALL ( ieee_is_finite ( V_ext ))) then ierr = ERROR_NOT_A_NUMBER return end if if (. not . ALL ( ieee_is_finite ( V_xc ))) then ierr = ERROR_NOT_A_NUMBER return end if end subroutine validate_hamiltonian_inputs !> @brief Build tight-binding Hamiltonian with external and XC potentials (real) !! !! Constructs the Kohn-Sham Hamiltonian matrix: !! H(i,j) = (V_ext(i) + V_xc(i)) δ_ij - t δ_{i,j±1} !! !! Assumes hopping parameter t = 1 (energy units). !! !! @param[in] L Number of lattice sites !! @param[in] V_ext External potential (length L) !! @param[in] V_xc Exchange-correlation potential (length L) !! @param[in] bc_type Boundary condition type !! @param[in] theta Optional twist angle (for validation only; TBC not supported) !! @param[out] H Hamiltonian matrix (L×L, real) !! @param[out] ierr Error code (0=success) !! !! @note For twisted BC, use build_hamiltonian_complex instead subroutine build_hamiltonian ( L , V_ext , V_xc , bc_type , theta , H , ierr ) integer , intent ( in ) :: L real ( dp ), intent ( in ) :: V_ext (:), V_xc (:) integer , intent ( in ) :: bc_type real ( dp ), intent ( in ), optional :: theta real ( dp ), intent ( out ) :: H (:,:) integer , intent ( out ) :: ierr integer :: i call validate_hamiltonian_inputs ( L , V_ext , V_xc , ierr ) if ( ierr /= 0 ) return if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if H = 0.0_dp do i = 1 , L H ( i , i ) = V_ext ( i ) + V_xc ( i ) end do do i = 1 , L - 1 H ( i , i + 1 ) = - 1.0_dp ! Assuming hopping parameter t = 1 H ( i + 1 , i ) = - 1.0_dp ! Assuming hopping parameter t = 1 end do call apply_boundary_conditions ( H , L , bc_type , theta , ierr ) end subroutine build_hamiltonian !> @brief Build tight-binding Hamiltonian with external and XC potentials (complex) !! !! Complex version supporting all boundary conditions including twisted BC. !! !! @param[in] L Number of lattice sites !! @param[in] V_ext External potential (length L) !! @param[in] V_xc Exchange-correlation potential (length L) !! @param[in] bc_type Boundary condition type !! @param[in] theta Optional twist angle (required for BC_TWISTED) !! @param[out] H Hamiltonian matrix (L×L, complex) !! @param[out] ierr Error code (0=success) subroutine build_hamiltonian_complex ( L , V_ext , V_xc , bc_type , theta , H , ierr ) integer , intent ( in ) :: L real ( dp ), intent ( in ) :: V_ext (:), V_xc (:) integer , intent ( in ) :: bc_type real ( dp ), intent ( in ) :: theta complex ( dp ), intent ( out ) :: H (:,:) integer , intent ( out ) :: ierr integer :: i call validate_hamiltonian_inputs ( L , V_ext , V_xc , ierr ) if ( ierr /= 0 ) return if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if H = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) do i = 1 , L H ( i , i ) = cmplx ( V_ext ( i ) + V_xc ( i ), 0.0_dp , kind = dp ) end do do i = 1 , L - 1 H ( i , i + 1 ) = cmplx ( - 1.0_dp , 0.0_dp , kind = dp ) ! Assuming hopping parameter t = 1 H ( i + 1 , i ) = cmplx ( - 1.0_dp , 0.0_dp , kind = dp ) ! Assuming hopping parameter t = 1 end do call apply_boundary_conditions_complex ( H , L , bc_type , theta , ierr ) end subroutine build_hamiltonian_complex !> @brief Build free-particle Hamiltonian (U=0, V=0) !! !! Constructs tight-binding Hamiltonian with no potentials. !! Useful for testing and validation against analytical results. !! !! @param[in] L Number of lattice sites !! @param[in] bc_type Boundary condition type !! @param[in] theta Optional twist angle !! @param[out] H Hamiltonian matrix (L×L, real) !! @param[out] ierr Error code (0=success) subroutine build_hamiltonian_free ( L , bc_type , theta , H , ierr ) integer , intent ( in ) :: L integer , intent ( in ) :: bc_type real ( dp ), intent ( in ), optional :: theta real ( dp ), intent ( out ) :: H (:,:) integer , intent ( out ) :: ierr integer :: i ierr = 0 if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if H = 0.0_dp do i = 1 , L - 1 H ( i , i + 1 ) = - 1.0_dp ! Assuming hopping parameter t = 1 H ( i + 1 , i ) = - 1.0_dp ! Assuming hopping parameter t = 1 end do call apply_boundary_conditions ( H , L , bc_type , theta , ierr ) end subroutine build_hamiltonian_free !> @brief Compute effective potential V_eff = V_ext + V_xc !! !! Simple helper function to combine external and XC potentials. !! !! @param[in] V_ext External potential !! @param[in] V_xc Exchange-correlation potential !! @param[out] V_eff Effective potential !! @param[out] ierr Error code (0=success) subroutine compute_effective_potential ( V_ext , V_xc , V_eff , ierr ) real ( dp ), intent ( in ) :: V_ext (:) real ( dp ), intent ( in ) :: V_xc (:) real ( dp ), intent ( out ) :: V_eff (:) integer , intent ( out ) :: ierr integer :: L ierr = 0 L = size ( V_ext ) if ( size ( V_xc ) /= L . or . size ( V_eff ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if V_eff = V_ext + V_xc end subroutine compute_effective_potential end module hamiltonian_builder","tags":"","url":"sourcefile/hamiltonian_builder.f90.html"},{"title":"mixing_schemes.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~mixing_schemes.f90~~EfferentGraph sourcefile~mixing_schemes.f90 mixing_schemes.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~mixing_schemes.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~mixing_schemes.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~mixing_schemes.f90~~AfferentGraph sourcefile~mixing_schemes.f90 mixing_schemes.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~mixing_schemes.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module mixing_schemes use lsda_constants , only : dp use lsda_errors , only : ERROR_SUCCESS , ERROR_INVALID_INPUT , & ERROR_SIZE_MISMATCH implicit none private public :: linear_mixing ! public :: anderson_mixing ! public :: broyden_mixing contains !> @brief Linear density mixing for SCF convergence !! !! Implements: n_mixed = (1-α)·n_old + α·n_new !! !! Linear mixing damps oscillations in SCF cycles by combining !! input and output densities. !! !! Convention: α represents the weight of NEW density !! - α small (e.g., 0.05): conservative, keeps 95% old (like C++ Mix=0.95) !! - α large (e.g., 0.5): aggressive, 50/50 mix !! !! Default: α = 0.05 (equivalent to original C++ code with Mix=0.95) !! !! @param[in] n_new Output density from diagonalization (length L) !! @param[in] n_old Input density used to build Hamiltonian (length L) !! @param[in] alpha Mixing parameter (0 < α ≤ 1), weight of new density !! @param[out] n_mixed Mixed density for next iteration (length L) !! @param[in] L System size !! @param[out] ierr Error code (0 = success) subroutine linear_mixing ( n_new , n_old , alpha , n_mixed , L , ierr ) integer , intent ( in ) :: L real ( dp ), intent ( in ) :: n_new (:), n_old (:) real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( out ) :: n_mixed (:) integer , intent ( out ) :: ierr integer :: i if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( n_new ) /= L . or . size ( n_old ) /= L . or . size ( n_mixed ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( alpha <= 0.0_dp . or . alpha > 1.0_dp ) then ierr = ERROR_INVALID_INPUT return end if ierr = ERROR_SUCCESS n_mixed = ( 1.0_dp - alpha ) * n_old + alpha * n_new end subroutine linear_mixing end module mixing_schemes","tags":"","url":"sourcefile/mixing_schemes.f90.html"},{"title":"degeneracy_handler.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~degeneracy_handler.f90~~EfferentGraph sourcefile~degeneracy_handler.f90 degeneracy_handler.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~degeneracy_handler.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~degeneracy_handler.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module degeneracy_handler use lsda_constants , only : dp use lsda_errors , only : ERROR_SUCCESS , ERROR_INVALID_INPUT , & ERROR_SIZE_MISMATCH , ERROR_LAPACK_FAILED , & ERROR_LINEAR_DEPENDENCE implicit none private real ( dp ), parameter :: DEG_TOL = 1.0e-8_dp interface subroutine DGEQRF ( M , N , A , LDA , TAU , WORK , LWORK , INFO ) import :: dp integer , intent ( in ) :: M , N , LDA , LWORK real ( dp ), intent ( inout ) :: A ( LDA , * ) real ( dp ), intent ( out ) :: TAU ( * ) real ( dp ), intent ( inout ) :: WORK ( * ) integer , intent ( out ) :: INFO end subroutine DGEQRF subroutine DORGQR ( M , N , K , A , LDA , TAU , WORK , LWORK , INFO ) import :: dp integer , intent ( in ) :: M , N , K , LDA , LWORK real ( dp ), intent ( inout ) :: A ( LDA , * ) real ( dp ), intent ( in ) :: TAU ( * ) real ( dp ), intent ( inout ) :: WORK ( * ) integer , intent ( out ) :: INFO end subroutine DORGQR subroutine DGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , & LDB , BETA , C , LDC ) import :: dp character ( len = 1 ), intent ( in ) :: TRANSA , TRANSB integer , intent ( in ) :: M , N , K , LDA , LDB , LDC real ( dp ), intent ( in ) :: ALPHA , BETA real ( dp ), intent ( in ) :: A ( LDA , * ), B ( LDB , * ) real ( dp ), intent ( inout ) :: C ( LDC , * ) end subroutine DGEMM end interface public :: find_degenerate_subspaces public :: orthonormalize_degenerate_subspace public :: orthonormalize_degenerate_subspace_complex public :: compute_degeneracy_count public :: verify_orthonormality contains !> @brief Find all degenerate subspaces in eigenvalue spectrum !! !! Scans eigenvalues (assumed sorted) and identifies groups where !! |λ_i - λ_j| < tol. Returns indices of degenerate subspaces. !! !! @param[in] eigvals Eigenvalues (sorted in ascending order) !! @param[in] L Number of eigenvalues !! @param[out] subspaces Indices of degenerate eigenvalues (n_subspaces × max_deg) !! @param[out] subspace_sizes Size of each degenerate subspace !! @param[out] n_subspaces Number of degenerate subspaces found !! @param[out] ierr Error code subroutine find_degenerate_subspaces ( eigvals , L , subspaces , subspaces_sizes , & n_subspaces , ierr ) real ( dp ), intent ( in ) :: eigvals (:) integer , intent ( in ) :: L integer , allocatable , intent ( out ) :: subspaces (:,:) integer , allocatable , intent ( out ) :: subspaces_sizes (:) integer , intent ( out ) :: ierr integer , intent ( out ) :: n_subspaces integer :: i , j , deg_count , idx , max_deg ierr = ERROR_SUCCESS if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( eigvals ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if i = 1 n_subspaces = 0 max_deg = 1 do while ( i <= L ) deg_count = 1 do j = i + 1 , L if ( abs ( eigvals ( j ) - eigvals ( i )) < DEG_TOL ) then deg_count = deg_count + 1 else exit end if end do if ( deg_count > 1 ) then n_subspaces = n_subspaces + 1 max_deg = max ( max_deg , deg_count ) end if i = i + deg_count end do ! If no degeneracies found, return empty arrays if ( n_subspaces == 0 ) then allocate ( subspaces ( 0 , 0 )) allocate ( subspaces_sizes ( 0 )) return end if allocate ( subspaces ( n_subspaces , max_deg )) allocate ( subspaces_sizes ( n_subspaces )) subspaces = 0 idx = 0 i = 1 do while ( i <= L ) deg_count = 1 do j = i + 1 , L if ( abs ( eigvals ( j ) - eigvals ( i )) < DEG_TOL ) then deg_count = deg_count + 1 else exit end if end do if ( deg_count > 1 ) then idx = idx + 1 subspaces_sizes ( idx ) = deg_count do j = 1 , deg_count subspaces ( idx , j ) = i + j - 1 end do end if i = i + deg_count end do end subroutine find_degenerate_subspaces !> @brief Re-orthonormalize degenerate subspace using LAPACK QR !! !! Uses QR decomposition to obtain orthonormal basis for a degenerate !! subspace. More numerically stable than Gram-Schmidt. !! !! @param[inout] eigvecs Eigenvector matrix (columns are eigenvectors) !! @param[in] L Dimension of eigenvectors !! @param[in] indices Indices of degenerate eigenvectors to orthonormalize !! @param[in] n_deg Number of degenerate eigenvectors !! @param[out] ierr Error code subroutine orthonormalize_degenerate_subspace ( eigvecs , L , indexes , n_deg , ierr ) real ( dp ), intent ( inout ) :: eigvecs (:,:) integer , intent ( in ) :: L , indexes (:), n_deg integer , intent ( out ) :: ierr real ( dp ), allocatable :: A (:,:), tau (:), work (:) integer :: lwork , info , i if ( n_deg <= 1 ) then ierr = ERROR_SUCCESS ! Nothing to do for a single vector return end if if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( indexes ) < n_deg ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( eigvecs , 1 ) /= L . or . size ( eigvecs , 2 ) < L ) then ierr = ERROR_SIZE_MISMATCH return end if do i = 1 , n_deg if ( indexes ( i ) < 1 . or . indexes ( i ) > L ) then ierr = ERROR_INVALID_INPUT return end if end do allocate ( A ( L , n_deg )) do i = 1 , n_deg A (:, i ) = eigvecs (:, indexes ( i )) end do allocate ( tau ( n_deg )) lwork = - 1 allocate ( work ( 1 )) call DGEQRF ( L , n_deg , A , L , tau , work , lwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_FAILED deallocate ( A , tau , work ) return end if lwork = int ( work ( 1 )) deallocate ( work ) allocate ( work ( lwork )) call DGEQRF ( L , n_deg , A , L , tau , work , lwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_FAILED deallocate ( A , tau , work ) return end if ! Workspace query for DORGQR deallocate ( work ) allocate ( work ( 1 )) lwork = - 1 call DORGQR ( L , n_deg , n_deg , A , L , tau , work , lwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_FAILED deallocate ( A , tau , work ) return end if lwork = int ( work ( 1 )) deallocate ( work ) allocate ( work ( lwork )) call DORGQR ( L , n_deg , n_deg , A , L , tau , work , lwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_FAILED deallocate ( A , tau , work ) return end if do i = 1 , n_deg eigvecs (:, indexes ( i )) = A (:, i ) end do deallocate ( A , tau , work ) end subroutine orthonormalize_degenerate_subspace !> @brief Re-orthonormalize complex degenerate subspace using Gram-Schmidt !! !! Modified Gram-Schmidt for complex vectors. Less stable than QR !! but simpler for complex case. !! !! @param[inout] eigvecs Complex eigenvector matrix !! @param[in] L Dimension of eigenvectors !! @param[in] indexes Indices of degenerate eigenvectors !! @param[in] n_deg Number of degenerate eigenvectors !! @param[out] ierr Error code subroutine orthonormalize_degenerate_subspace_complex ( eigvecs , L , indexes , n_deg , ierr ) complex ( dp ), intent ( inout ) :: eigvecs (:,:) integer , intent ( in ) :: L , indexes (:), n_deg integer , intent ( out ) :: ierr integer :: j , k , idx_j , idx_k complex ( dp ) :: proj real ( dp ) :: norm ierr = ERROR_SUCCESS if ( n_deg <= 1 ) then ierr = ERROR_SUCCESS ! Nothing to do for a single vector return end if if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( indexes ) < n_deg ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( eigvecs , 1 ) /= L . or . size ( eigvecs , 2 ) < L ) then ierr = ERROR_SIZE_MISMATCH return end if do k = 1 , n_deg if ( indexes ( k ) < 1 . or . indexes ( k ) > L ) then ierr = ERROR_INVALID_INPUT return end if end do ! Modified Gram-Schmidt orthonormalization do k = 1 , n_deg idx_k = indexes ( k ) do j = 1 , k - 1 idx_j = indexes ( j ) proj = DOT_PRODUCT ( eigvecs (:, idx_j ), eigvecs (:, idx_k )) eigvecs (:, idx_k ) = eigvecs (:, idx_k ) - proj * eigvecs (:, idx_j ) end do norm = SQRT ( real ( DOT_PRODUCT ( eigvecs (:, idx_k ), eigvecs (:, idx_k )), kind = dp )) if ( norm < 1.0e-14_dp ) then ierr = ERROR_LINEAR_DEPENDENCE return end if eigvecs (:, idx_k ) = eigvecs (:, idx_k ) / norm end do end subroutine orthonormalize_degenerate_subspace_complex !> @brief Count number of eigenvalues degenerate with given index !! !! Searches forward and backward from given index to count how many !! eigenvalues are within tolerance. !! !! @param[in] eigvals Eigenvalues (sorted) !! @param[in] L Number of eigenvalues !! @param[in] index Index of reference eigenvalue !! @return Number of degenerate eigenvalues (including reference) function compute_degeneracy_count ( eigvals , L , index ) result ( deg_count ) real ( dp ), intent ( in ) :: eigvals (:) integer , intent ( in ) :: L , index real ( dp ) :: eval integer :: deg_count , i if ( index < 1 . or . index > L . or . L <= 0 ) then deg_count = 0 return end if eval = eigvals ( index ) deg_count = 1 do i = index - 1 , 1 , - 1 if ( abs ( eigvals ( i ) - eval ) < DEG_TOL ) then deg_count = deg_count + 1 else exit end if end do do i = index + 1 , L if ( abs ( eigvals ( i ) - eval ) < DEG_TOL ) then deg_count = deg_count + 1 else exit end if end do end function compute_degeneracy_count !> @brief Verify eigenvectors are orthonormal !! !! Computes overlap matrix S = V&#94;T * V using BLAS and checks !! deviation from identity matrix. !! !! @param[in] eigvecs Eigenvector matrix (L × L) !! @param[in] L Dimension !! @param[out] is_orthonormal True if ||S - I||_∞ < tol !! @param[out] max_deviation Maximum deviation from orthonormality !! @param[out] ierr Error code subroutine verify_orthonormality ( eigvecs , L , is_orthonormal , & max_deviation , ierr ) real ( dp ), intent ( in ) :: eigvecs (:,:) integer , intent ( in ) :: L logical , intent ( out ) :: is_orthonormal real ( dp ), intent ( out ) :: max_deviation integer , intent ( out ) :: ierr real ( dp ), allocatable :: S (:,:) real ( dp ) :: dev integer :: i , j ierr = ERROR_SUCCESS if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( eigvecs , 1 ) /= L . or . size ( eigvecs , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if allocate ( S ( L , L )) call DGEMM ( 'T' , & ! Transpose first matrix 'N' , & ! Don't transpose second L , L , L , & ! Dimensions: m, n, k 1.0_dp , & ! alpha eigvecs , L , & ! A matrix eigvecs , L , & ! B matrix 0.0_dp , & ! beta S , L ) ! C = result max_deviation = 0.0_dp do i = 1 , L do j = 1 , L if ( i == j ) then dev = abs ( S ( i , j ) - 1.0_dp ) else dev = abs ( S ( i , j )) end if max_deviation = max ( max_deviation , dev ) end do end do is_orthonormal = ( max_deviation < 1.0e-8_dp ) deallocate ( S ) end subroutine verify_orthonormality end module degeneracy_handler","tags":"","url":"sourcefile/degeneracy_handler.f90.html"},{"title":"convergence_monitor.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~convergence_monitor.f90~~EfferentGraph sourcefile~convergence_monitor.f90 convergence_monitor.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~convergence_monitor.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~convergence_monitor.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~convergence_monitor.f90~~AfferentGraph sourcefile~convergence_monitor.f90 convergence_monitor.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~convergence_monitor.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module convergence_monitor use lsda_constants , only : dp use lsda_errors , only : ERROR_SUCCESS , ERROR_INVALID_INPUT , & ERROR_SIZE_MISMATCH implicit none private type :: convergence_history_t integer :: max_iter integer :: current_iter real ( dp ), allocatable :: density_norms (:) real ( dp ), allocatable :: energies (:) end type convergence_history_t enum , bind ( c ) enumerator :: L1 = 1 enumerator :: L2 = 2 enumerator :: Linf = 3 end enum public :: L1 , L2 , Linf public :: compute_density_difference public :: compute_density_norm public :: check_scf_convergence public :: update_convergence_history public :: convergence_history_t public :: init_convergence_history public :: cleanup_convergence_history contains !> @brief Compute difference between new and old densities !! !! Calculates Δn(i) = n_new(i) - n_old(i) !! !! @param[in] n_new New density (length L) !! @param[in] n_old Old density (length L) !! @param[in] L System size !! @param[out] diff Density difference (length L) !! @param[out] ierr Error code (0 = success) subroutine compute_density_difference ( n_new , n_old , L , diff , ierr ) real ( dp ), intent ( in ) :: n_new (:), n_old (:) integer , intent ( in ) :: L real ( dp ), intent ( out ) :: diff (:) integer , intent ( out ) :: ierr if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( n_new ) /= L . or . size ( n_old ) /= L . or . size ( diff ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if ierr = ERROR_SUCCESS diff = n_new - n_old end subroutine compute_density_difference !> @brief Compute norm of density difference !! !! Supports L1, L2, and L∞ norms: !! - L1:   ||Δn||₁ = Σᵢ |Δn(i)| !! - L2:   ||Δn||₂ = √(Σᵢ |Δn(i)|²) !! - L∞:   ||Δn||∞ = maxᵢ |Δn(i)| !! !! @param[in] delta_n Density difference (length L) !! @param[in] L System size !! @param[in] norm_type Type of norm (L1, L2, or Linf) !! @param[out] norm_value Computed norm !! @param[out] ierr Error code (0 = success) subroutine compute_density_norm ( delta_n , L , norm_type , norm_value , ierr ) real ( dp ), intent ( in ) :: delta_n (:) integer , intent ( in ) :: L integer , intent ( in ) :: norm_type real ( dp ), intent ( out ) :: norm_value integer , intent ( out ) :: ierr if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( delta_n ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if ierr = ERROR_SUCCESS select case ( norm_type ) case ( L1 ) norm_value = sum ( abs ( delta_n )) case ( L2 ) norm_value = sqrt ( sum ( delta_n ** 2 )) case ( Linf ) norm_value = maxval ( abs ( delta_n )) case default ierr = ERROR_INVALID_INPUT norm_value = - 1.0_dp end select end subroutine compute_density_norm !> @brief Check if SCF iteration has converged !! !! Convergence criterion: ||Δn||₂ < tol !! !! @param[in] delta_n Density difference (length L) !! @param[in] L System size !! @param[in] tol Convergence tolerance (default: 1.0e-6) !! @param[out] is_converged True if converged !! @param[out] ierr Error code (0 = success) subroutine check_scf_convergence ( delta_n , L , tol , is_converged , ierr ) real ( dp ), intent ( in ) :: delta_n (:) integer , intent ( in ) :: L real ( dp ), intent ( in ), optional :: tol logical , intent ( out ) :: is_converged integer , intent ( out ) :: ierr real ( dp ) :: norm_value real ( dp ) :: tolerance integer :: norm_type norm_type = L2 if ( present ( tol )) then tolerance = tol else tolerance = 1.0e-6_dp end if call compute_density_norm ( delta_n , L , norm_type , norm_value , ierr ) if ( ierr /= ERROR_SUCCESS ) then is_converged = . false . return end if ierr = ERROR_SUCCESS is_converged = ( norm_value < tolerance ) end subroutine check_scf_convergence !> @brief Update convergence history with current iteration data !! !! @param[in] iteration Current iteration number !! @param[in] norm Density norm at this iteration !! @param[in] energy Total energy at this iteration !! @param[inout] history Convergence history object !! @param[out] ierr Error code (0 = success) subroutine update_convergence_history ( iteration , norm , energy , history , ierr ) integer , intent ( in ) :: iteration real ( dp ), intent ( in ) :: norm real ( dp ), intent ( in ) :: energy type ( convergence_history_t ), intent ( inout ) :: history integer , intent ( out ) :: ierr if ( iteration < 1 . or . iteration > history % max_iter ) then ierr = ERROR_INVALID_INPUT return end if if (. not . allocated ( history % density_norms ) . or . & . not . allocated ( history % energies )) then ierr = ERROR_INVALID_INPUT return end if history % density_norms ( iteration ) = norm history % energies ( iteration ) = energy history % current_iter = iteration ierr = ERROR_SUCCESS end subroutine update_convergence_history !> @brief Initialize convergence history storage !! !! @param[out] history Convergence history object !! @param[in] max_iter Maximum number of iterations !! @param[out] ierr Error code (0 = success) subroutine init_convergence_history ( history , max_iter , ierr ) type ( convergence_history_t ), intent ( out ) :: history integer , intent ( in ) :: max_iter integer , intent ( out ) :: ierr if ( max_iter <= 0 ) then ierr = ERROR_INVALID_INPUT return end if history % max_iter = max_iter history % current_iter = 0 allocate ( history % density_norms ( max_iter )) allocate ( history % energies ( max_iter )) history % density_norms = 0.0_dp history % energies = 0.0_dp ierr = ERROR_SUCCESS end subroutine init_convergence_history !> @brief Deallocate convergence history !! !! @param[inout] history Convergence history object !! @param[out] ierr Error code (0 = success) subroutine cleanup_convergence_history ( history , ierr ) type ( convergence_history_t ), intent ( inout ) :: history integer , intent ( out ) :: ierr if ( allocated ( history % density_norms )) deallocate ( history % density_norms ) if ( allocated ( history % energies )) deallocate ( history % energies ) history % max_iter = 0 history % current_iter = 0 ierr = ERROR_SUCCESS end subroutine cleanup_convergence_history end module convergence_monitor","tags":"","url":"sourcefile/convergence_monitor.f90.html"},{"title":"potential_factory.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~potential_factory.f90~~EfferentGraph sourcefile~potential_factory.f90 potential_factory.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~potential_factory.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~potential_factory.f90->sourcefile~lsda_errors.f90 sourcefile~potential_barrier.f90 potential_barrier.f90 sourcefile~potential_factory.f90->sourcefile~potential_barrier.f90 sourcefile~potential_harmonic.f90 potential_harmonic.f90 sourcefile~potential_factory.f90->sourcefile~potential_harmonic.f90 sourcefile~potential_impurity.f90 potential_impurity.f90 sourcefile~potential_factory.f90->sourcefile~potential_impurity.f90 sourcefile~potential_quasiperiodic.f90 potential_quasiperiodic.f90 sourcefile~potential_factory.f90->sourcefile~potential_quasiperiodic.f90 sourcefile~potential_random.f90 potential_random.f90 sourcefile~potential_factory.f90->sourcefile~potential_random.f90 sourcefile~potential_uniform.f90 potential_uniform.f90 sourcefile~potential_factory.f90->sourcefile~potential_uniform.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 sourcefile~potential_barrier.f90->sourcefile~lsda_constants.f90 sourcefile~potential_barrier.f90->sourcefile~lsda_errors.f90 sourcefile~potential_harmonic.f90->sourcefile~lsda_constants.f90 sourcefile~potential_harmonic.f90->sourcefile~lsda_errors.f90 sourcefile~potential_impurity.f90->sourcefile~lsda_constants.f90 sourcefile~potential_impurity.f90->sourcefile~lsda_errors.f90 sourcefile~potential_quasiperiodic.f90->sourcefile~lsda_constants.f90 sourcefile~potential_quasiperiodic.f90->sourcefile~lsda_errors.f90 sourcefile~potential_random.f90->sourcefile~lsda_constants.f90 sourcefile~potential_random.f90->sourcefile~lsda_errors.f90 sourcefile~potential_uniform.f90->sourcefile~lsda_constants.f90 sourcefile~potential_uniform.f90->sourcefile~lsda_errors.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Module for potential factory pattern !! !! Provides a unified interface to create any type of potential dynamically. !! This simplifies potential creation in simulation codes by allowing !! string-based selection of potential types. !! !! Supported potentials: !! - \"uniform\": Constant potential !! - \"harmonic\": Harmonic trap !! - \"impurity_single\": Single point impurity !! - \"impurity_multiple\": Multiple impurities !! - \"impurity_random\": Random impurities with concentration !! - \"random_uniform\": Random disorder (uniform distribution) !! - \"random_gaussian\": Random disorder (Gaussian distribution) !! - \"barrier_single\": Single rectangular barrier !! - \"barrier_double\": Double barrier (quantum well) !! - \"quasiperiodic\": Aubry-André-Harper quasiperiodic potential !! !! Usage: !!   call create_potential(\"harmonic\", params, L, seed, V, ierr) module potential_factory use lsda_constants , only : dp use lsda_errors , only : ERROR_SUCCESS , ERROR_INVALID_INPUT use potential_uniform , only : apply_potential_uniform use potential_harmonic , only : apply_potential_harmonic use potential_impurity , only : potential_impurity_single , & potential_impurity_multiple , & potential_impurity_random use potential_random , only : potential_random_uniform , & potential_random_gaussian use potential_barrier , only : potential_barrier_single , & potential_barrier_double use potential_quasiperiodic , only : apply_potential_quasiperiodic implicit none private public :: create_potential public :: get_potential_info contains !> Factory function to create any potential type !! !! Creates a potential based on a string identifier and parameter array. !! This provides a unified interface for potential creation. !! !! Parameter array format (params): !! - \"uniform\": params(1) = V0 !! - \"harmonic\": params(1) = k !! - \"impurity_single\": params(1) = V_imp, params(2) = i_imp (as real) !! - \"random_uniform\": params(1) = W !! - \"random_gaussian\": params(1) = sigma !! - \"barrier_single\": params(1) = V_bar, params(2) = i_start, params(3) = i_end !! - \"barrier_double\": params(1) = V_bar, params(2) = L_bar, params(3) = V_well, params(4) = L_well !! - \"quasiperiodic\": params(1) = lambda, params(2) = beta, params(3) = phi !! !! @param[in]  potential_type  String identifying potential type !! @param[in]  params          Parameter array (size depends on potential type) !! @param[in]  L               Number of lattice sites !! @param[in]  seed            Random seed (for random potentials, use -1 for system time) !! @param[out] V               Potential array V(i) for i = 1..L !! @param[out] ierr            Error flag !! !! @note For multiple impurities, use potential_impurity_multiple directly !! @note For random impurities, use potential_impurity_random directly subroutine create_potential ( potential_type , params , L , seed , V , ierr ) character ( len =* ), intent ( in ) :: potential_type real ( dp ), intent ( in ) :: params (:) integer , intent ( in ) :: L , seed real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr ! Initialize V = 0.0_dp ierr = ERROR_SUCCESS ! Select potential type select case ( trim ( adjustl ( potential_type ))) case ( \"uniform\" ) ! Uniform potential: params(1) = V0 if ( size ( params ) < 1 ) then ierr = ERROR_INVALID_INPUT return end if call apply_potential_uniform ( params ( 1 ), L , V , ierr ) case ( \"harmonic\" ) ! Harmonic trap: params(1) = k if ( size ( params ) < 1 ) then ierr = ERROR_INVALID_INPUT return end if call apply_potential_harmonic ( params ( 1 ), L , V , ierr ) case ( \"impurity_single\" ) ! Single impurity: params(1) = V_imp, params(2) = i_imp if ( size ( params ) < 2 ) then ierr = ERROR_INVALID_INPUT return end if call potential_impurity_single ( params ( 1 ), int ( params ( 2 )), L , V , ierr ) case ( \"random_uniform\" ) ! Random uniform: params(1) = W if ( size ( params ) < 1 ) then ierr = ERROR_INVALID_INPUT return end if call potential_random_uniform ( params ( 1 ), L , seed , V , ierr ) case ( \"random_gaussian\" ) ! Random Gaussian: params(1) = sigma if ( size ( params ) < 1 ) then ierr = ERROR_INVALID_INPUT return end if call potential_random_gaussian ( params ( 1 ), L , seed , V , ierr ) case ( \"barrier_single\" ) ! Single barrier: params(1) = V_bar, params(2) = i_start, params(3) = i_end if ( size ( params ) < 3 ) then ierr = ERROR_INVALID_INPUT return end if call potential_barrier_single ( params ( 1 ), int ( params ( 2 )), int ( params ( 3 )), L , V , ierr ) case ( \"barrier_double\" ) ! Double barrier: params(1) = V_bar, params(2) = L_bar, params(3) = V_well, params(4) = L_well ! Matches C++ double_barrier(Na, Vb, Lb, Vwell, Lwell, v_ext) if ( size ( params ) < 4 ) then ierr = ERROR_INVALID_INPUT return end if call potential_barrier_double ( params ( 1 ), params ( 2 ), params ( 3 ), params ( 4 ), L , V , ierr ) case ( \"quasiperiodic\" ) ! Quasiperiodic: params(1) = lambda, params(2) = beta, params(3) = phi if ( size ( params ) < 3 ) then ierr = ERROR_INVALID_INPUT return end if call apply_potential_quasiperiodic ( params ( 1 ), params ( 2 ), params ( 3 ), L , V , ierr ) case default ierr = ERROR_INVALID_INPUT end select end subroutine create_potential !> Get information about a potential type !! !! Returns a descriptive string explaining a potential type and its parameters. !! !! @param[in]  potential_type  String identifying potential type !! @return     info            Descriptive information string function get_potential_info ( potential_type ) result ( info ) character ( len =* ), intent ( in ) :: potential_type character ( len = 512 ) :: info select case ( trim ( adjustl ( potential_type ))) case ( \"uniform\" ) info = \"Uniform potential: V(i) = V0. Parameters: [V0]\" case ( \"harmonic\" ) info = \"Harmonic trap: V(i) = k*(i-center)&#94;2. Parameters: [k]\" case ( \"impurity_single\" ) info = \"Single impurity: V(i) = V_imp at i_imp. Parameters: [V_imp, i_imp]\" case ( \"impurity_multiple\" ) info = \"Multiple impurities: Use potential_impurity_multiple directly\" case ( \"impurity_random\" ) info = \"Random impurities: Use potential_impurity_random directly\" case ( \"random_uniform\" ) info = \"Random uniform disorder: V(i) ~ Uniform[-W, +W]. Parameters: [W]\" case ( \"random_gaussian\" ) info = \"Random Gaussian: V(i) ~ N(0, sigma&#94;2). Parameters: [sigma]\" case ( \"barrier_single\" ) info = \"Single barrier: V(i) = V_bar in [i_start, i_end]. Parameters: [V_bar, i_start, i_end]\" case ( \"barrier_double\" ) info = \"Double barrier: Two barriers with well. Parameters: [V_bar, L_bar, V_well, L_well]\" case ( \"quasiperiodic\" ) info = \"Quasiperiodic AAH: V(i) = lambda*cos(2*pi*beta*i + phi). Parameters: [lambda, beta, phi]\" case default info = \"Unknown potential type\" end select end function get_potential_info end module potential_factory","tags":"","url":"sourcefile/potential_factory.f90.html"},{"title":"potential_impurity.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~potential_impurity.f90~~EfferentGraph sourcefile~potential_impurity.f90 potential_impurity.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~potential_impurity.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~potential_impurity.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~potential_impurity.f90~~AfferentGraph sourcefile~potential_impurity.f90 potential_impurity.f90 sourcefile~potential_factory.f90 potential_factory.f90 sourcefile~potential_factory.f90->sourcefile~potential_impurity.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Module for point impurity potentials !! !! Implements various types of point impurities: !! - Single impurity at a fixed position !! - Multiple impurities with individual amplitudes !! - Random impurities with fixed concentration !! !! Physical interpretation: !! - V_imp > 0: Repulsive impurity (barrier) !! - V_imp < 0: Attractive impurity (potential well, can create bound states) module potential_impurity use lsda_constants , only : dp use lsda_errors , only : ERROR_SUCCESS , ERROR_OUT_OF_BOUNDS , & ERROR_SIZE_MISMATCH , ERROR_INVALID_CONCENTRATION implicit none private public :: potential_impurity_single public :: potential_impurity_multiple public :: potential_impurity_random contains !> Single point impurity: V(i) = V_imp if i = i_imp, else 0 !! !! Creates a point impurity at a specific lattice site. !! !! @param[in]  V_imp    Impurity amplitude !! @param[in]  i_imp    Impurity position (1-indexed, must be in [1, L]) !! @param[in]  L        Number of lattice sites !! @param[out] V        Potential array V(i) for i = 1..L !! @param[out] ierr     Error flag (ERROR_SUCCESS or ERROR_OUT_OF_BOUNDS) subroutine potential_impurity_single ( V_imp , i_imp , L , V , ierr ) real ( dp ), intent ( in ) :: V_imp integer , intent ( in ) :: i_imp , L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr ! Initialize V = 0.0_dp ierr = ERROR_SUCCESS ! Bounds check if ( i_imp < 1 . or . i_imp > L ) then ierr = ERROR_OUT_OF_BOUNDS return end if ! Set impurity V ( i_imp ) = V_imp end subroutine potential_impurity_single !> Multiple point impurities with individual amplitudes !! !! Creates multiple impurities, each with its own amplitude. !! If two impurities are at the same position, their amplitudes are added. !! !! @param[in]  V_imp_array   Array of impurity amplitudes (size N_imp) !! @param[in]  imp_positions Array of impurity positions (size N_imp, 1-indexed) !! @param[in]  L             Number of lattice sites !! @param[out] V             Potential array V(i) for i = 1..L !! @param[out] ierr          Error flag (ERROR_SUCCESS, ERROR_SIZE_MISMATCH, or ERROR_OUT_OF_BOUNDS) subroutine potential_impurity_multiple ( V_imp_array , imp_positions , L , V , ierr ) real ( dp ), intent ( in ) :: V_imp_array (:) integer , intent ( in ) :: imp_positions (:), L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr integer :: k , N_imp , pos ! Initialize V = 0.0_dp ierr = ERROR_SUCCESS ! Check array sizes match N_imp = size ( imp_positions ) if ( size ( V_imp_array ) /= N_imp ) then ierr = ERROR_SIZE_MISMATCH return end if ! Add each impurity do k = 1 , N_imp pos = imp_positions ( k ) ! Bounds check if ( pos < 1 . or . pos > L ) then ierr = ERROR_OUT_OF_BOUNDS return end if ! Add impurity (use += to handle overlapping impurities) V ( pos ) = V ( pos ) + V_imp_array ( k ) end do end subroutine potential_impurity_multiple !> Random impurities with fixed concentration !! !! Creates randomly distributed impurities with fixed amplitude. !! The number of impurities is determined by: N_imp = round(concentration * L / 100) !! !! Example: L = 100, concentration = 10 -> N_imp = 10 impurities (10%) !! !! @param[in]  V_imp         Impurity amplitude (same for all impurities) !! @param[in]  concentration Percentage of sites with impurities (0 < c <= 100) !! @param[in]  L             Number of lattice sites !! @param[in]  seed          Random seed for reproducibility (optional, use system time if < 0) !! @param[out] V             Potential array V(i) for i = 1..L !! @param[out] imp_positions Positions where impurities were placed (allocated inside) !! @param[out] ierr          Error flag (ERROR_SUCCESS or ERROR_INVALID_CONCENTRATION) subroutine potential_impurity_random ( V_imp , concentration , L , seed , V , imp_positions , ierr ) real ( dp ), intent ( in ) :: V_imp , concentration integer , intent ( in ) :: L , seed real ( dp ), dimension ( L ), intent ( out ) :: V integer , allocatable , intent ( out ) :: imp_positions (:) integer , intent ( out ) :: ierr integer :: N_imp , k , pos , attempt integer , allocatable :: seed_array (:) integer :: seed_size logical :: position_taken ( L ) real ( dp ) :: rand_val V = 0.0_dp ierr = ERROR_SUCCESS position_taken = . false . if ( concentration <= 0.0_dp . or . concentration > 10 0.0_dp ) then ierr = ERROR_INVALID_CONCENTRATION return end if N_imp = nint ( concentration * real ( L , dp ) / 10 0.0_dp ) if ( N_imp == 0 ) N_imp = 1 if ( N_imp > L ) N_imp = L allocate ( imp_positions ( N_imp )) if ( seed >= 0 ) then call random_seed ( size = seed_size ) allocate ( seed_array ( seed_size )) seed_array = seed call random_seed ( put = seed_array ) deallocate ( seed_array ) else call random_seed () end if ! Place impurities randomly (without replacement) do k = 1 , N_imp attempt = 0 do call random_number ( rand_val ) pos = 1 + int ( rand_val * L ) ! Make sure position is valid and not already taken if ( pos >= 1 . and . pos <= L . and . . not . position_taken ( pos )) then position_taken ( pos ) = . true . imp_positions ( k ) = pos V ( pos ) = V_imp exit end if ! Safety check: avoid infinite loop attempt = attempt + 1 if ( attempt > 1000 * L ) then ierr = ERROR_OUT_OF_BOUNDS return end if end do end do call sort_array ( imp_positions ) end subroutine potential_impurity_random !> Simple insertion sort for small arrays subroutine sort_array ( arr ) integer , intent ( inout ) :: arr (:) integer :: i , j , temp , n n = size ( arr ) do i = 2 , n temp = arr ( i ) j = i - 1 do while ( j >= 1 ) if ( arr ( j ) <= temp ) exit arr ( j + 1 ) = arr ( j ) j = j - 1 end do arr ( j + 1 ) = temp end do end subroutine sort_array end module potential_impurity","tags":"","url":"sourcefile/potential_impurity.f90.html"},{"title":"lsda_types.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~lsda_types.f90~~EfferentGraph sourcefile~lsda_types.f90 lsda_types.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~lsda_types.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~lsda_types.f90~~AfferentGraph sourcefile~lsda_types.f90 lsda_types.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~lsda_types.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_types.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~lsda_types.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Derived types for LSDA-Hubbard calculations !! !! This module defines the core data structures used throughout the LSDA code. !! These types encapsulate system parameters and state variables for DFT-LSDA !! calculations on the 1D Hubbard model. module lsda_types use lsda_constants , only : dp implicit none public :: system_params_t !> System parameters for LSDA-Hubbard calculations !! !! This type stores all the physical and numerical parameters that define !! a calculation for the 1D Hubbard model with an external potential. !! !! **Physical parameters:** !! - Number of sites, electrons (spin-up/down) !! - Hubbard interaction strength U !! - External potential type !! !! **Numerical parameters:** !! - Boundary conditions (open, periodic, twisted) !! - Convergence tolerance !! - Symmetry flags !! !! @note All parameters must be set before calling the KS cycle. !! @note For twisted BC (bc=2), the phase parameter must be provided. !! type :: system_params_t integer :: L !< Number of lattice sites integer :: Nup !< Number of spin-up electrons (N↑) integer :: Ndown !< Number of spin-down electrons (N↓) integer :: bc !< Boundary conditions: 0=open, 1=periodic, 2=twisted real ( dp ) :: U !< Hubbard interaction strength (in units of hopping t=1) real ( dp ) :: phase !< Twist angle for twisted BC (in units of π), only used if bc=2 end type system_params_t end module lsda_types","tags":"","url":"sourcefile/lsda_types.f90.html"},{"title":"bethe_tables.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~bethe_tables.f90~~EfferentGraph sourcefile~bethe_tables.f90 bethe_tables.f90 sourcefile~bethe_equations.f90 bethe_equations.f90 sourcefile~bethe_tables.f90->sourcefile~bethe_equations.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~bethe_tables.f90->sourcefile~lsda_constants.f90 sourcefile~nonlinear_solvers.f90 nonlinear_solvers.f90 sourcefile~bethe_tables.f90->sourcefile~nonlinear_solvers.f90 sourcefile~table_io.f90 table_io.f90 sourcefile~bethe_tables.f90->sourcefile~table_io.f90 sourcefile~bethe_equations.f90->sourcefile~lsda_constants.f90 sourcefile~nonlinear_solvers.f90->sourcefile~bethe_equations.f90 sourcefile~nonlinear_solvers.f90->sourcefile~lsda_constants.f90 sourcefile~table_io.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~table_io.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Module for generating exchange-correlation functional tables !! !! This module provides functionality to generate XC tables by: !! 1. Computing E_xc = E_BA - E_0 for grid points (n, m, U) !! 2. Computing V_xc via numerical derivatives !! 3. Using continuation method for efficient U sweeps !! 4. OpenMP parallelization for grid point calculations module bethe_tables use lsda_constants , only : dp , TWOPI , U_SMALL use bethe_equations , only : initialize_quantum_numbers , compute_energy , compute_residual use nonlinear_solvers , only : solve_newton use table_io , only : xc_table_t , write_fortran_table use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan , ieee_is_nan implicit none private type , public :: grid_params_t real ( dp ) :: n_min = 0.1_dp !< Minimum density real ( dp ) :: n_max = 2.0_dp !< Maximum density integer :: n_points = 50 !< Number of density points integer :: m_points = 51 !< Number of magnetization points (per n) integer :: L = 100 !< System size real ( dp ) :: delta_n = 1.0e-4_dp !< Finite difference increment end type grid_params_t type , public :: xc_potentials_t real ( dp ) :: v_xc_up , v_xc_down end type xc_potentials_t public :: compute_E0 public :: compute_E_xc public :: compute_V_xc_numerical public :: generate_xc_table public :: generate_table_grid contains !> Compute non-interacting energy (U=0, free Fermi gas) !! !! E_0 = -2 * sum_j cos(k_j) for both spins !! with k_j = 2π/L * I_j, I_j = j - (N+1)/2 !! !! @param[in] n_up  Spin-up density !! @param[in] n_dw  Spin-down density !! @param[in] L     System size !! @return          Non-interacting energy E_0 function compute_E0 ( n_up , n_dw , L ) result ( E0 ) real ( dp ), intent ( in ) :: n_up , n_dw integer , intent ( in ) :: L real ( dp ) :: E0 , I_j , k_j integer :: Nup , Ndw , j Nup = NINT ( n_up * real ( L , dp )) Ndw = NINT ( n_dw * real ( L , dp )) E0 = 0.0_dp do j = 1 , Nup I_j = real ( j , dp ) - 0.5_dp * real ( Nup + 1 , dp ) k_j = TWOPI * I_j / real ( L , dp ) E0 = E0 - 2.0_dp * cos ( k_j ) end do do j = 1 , Ndw I_j = real ( j , dp ) - 0.5_dp * real ( Ndw + 1 , dp ) k_j = TWOPI * I_j / real ( L , dp ) E0 = E0 - 2.0_dp * cos ( k_j ) end do end function compute_E0 !> Compute exchange-correlation energy: E_xc = E_BA - E_0 !! !! Solves Bethe Ansatz equations to get E_BA, then subtracts E_0. !! Returns energy per site for extensivity. !! !! @param[in] n_up  Spin-up density !! @param[in] n_dw  Spin-down density !! @param[in] U     Hubbard interaction !! @param[in] L     System size !! @return          XC energy per site e_xc = E_xc/L function compute_E_xc ( n_up , n_dn , U , L ) result ( E_xc ) real ( dp ), intent ( in ) :: n_up , n_dn , U integer , intent ( in ) :: L real ( dp ) :: E_xc integer :: Nup , Ndn , M real ( dp ) :: E0 , E_BA real ( dp ), allocatable :: x (:), k (:), F (:) real ( dp ), allocatable :: quantum_I (:), quantum_J (:) logical :: converged if ( abs ( U ) < U_SMALL ) then E_xc = 0.0_dp return end if Nup = nint ( n_up * real ( L , dp )) Ndn = nint ( n_dn * real ( L , dp )) M = Ndn allocate ( x ( Nup + M )) ! Combined array for solver (k + Lambda) allocate ( k ( Nup )) allocate ( F ( Nup + M )) allocate ( quantum_I ( Nup ), quantum_J ( M )) call initialize_quantum_numbers ( Nup , M , quantum_I , quantum_J ) x ( 1 : Nup ) = TWOPI * quantum_I / real ( L , dp ) if ( M > 0 ) then x ( Nup + 1 : Nup + M ) = 0.0_dp end if call solve_newton ( x , quantum_I , quantum_J , L , U , converged ) if (. not . converged ) then F = compute_residual ( x ( 1 : Nup ), x ( Nup + 1 : Nup + M ), quantum_I , quantum_J , L , U ) if ( norm2 ( F ) > 1.0e-8_dp ) then E_xc = ieee_value ( E_xc , ieee_quiet_nan ) deallocate ( x , k , quantum_I , quantum_J , F ) return end if deallocate ( F ) end if k = x ( 1 : Nup ) E_BA = compute_energy ( k ) E0 = compute_E0 ( n_up , n_dn , L ) E_xc = ( E_BA - E0 ) / real ( L , dp ) deallocate ( x , k , quantum_I , quantum_J ) end function compute_E_xc !> Compute XC potentials via numerical derivatives (central finite differences) !! !! V_xc_up = ∂E_xc/∂n_up, V_xc_dw = ∂E_xc/∂n_dw !! Uses 2nd-order central differences with δn ~ 1e-4 !! !! @param[in] n_up    Spin-up density !! @param[in] n_dw    Spin-down density !! @param[in] U       Hubbard interaction !! @param[in] L       System size !! @param[in] delta_n Finite difference increment !! @return            XC potentials (v_xc_up, v_xc_down) function compute_V_xc_numerical ( n_up , n_dw , U , L ) result ( v_xc ) real ( dp ), intent ( in ) :: n_up , n_dw integer , intent ( in ) :: L real ( dp ), intent ( in ) :: U type ( xc_potentials_t ) :: v_xc real ( dp ) :: delta_n real ( dp ) :: E_xc_up_plus , E_xc_up_minus real ( dp ) :: E_xc_dw_plus , E_xc_dw_minus delta_n = 1.0e-4_dp ! Derivative with respect to n_up E_xc_up_plus = compute_E_xc ( n_up + delta_n , n_dw , U , L ) E_xc_up_minus = compute_E_xc ( n_up - delta_n , n_dw , U , L ) if ( ieee_is_nan ( E_xc_up_plus ) . or . ieee_is_nan ( E_xc_up_minus )) then v_xc % v_xc_up = ieee_value ( 0.0_dp , ieee_quiet_nan ) else v_xc % v_xc_up = ( E_xc_up_plus - E_xc_up_minus ) / ( 2.0_dp * delta_n ) end if ! Derivative with respect to n_dw E_xc_dw_plus = compute_E_xc ( n_up , n_dw + delta_n , U , L ) E_xc_dw_minus = compute_E_xc ( n_up , n_dw - delta_n , U , L ) if ( ieee_is_nan ( E_xc_dw_plus ) . or . ieee_is_nan ( E_xc_dw_minus )) then v_xc % v_xc_down = ieee_value ( 0.0_dp , ieee_quiet_nan ) else v_xc % v_xc_down = ( E_xc_dw_plus - E_xc_dw_minus ) / ( 2.0_dp * delta_n ) end if end function compute_V_xc_numerical !> Generate complete XC table for a single U value !! !! Creates table with grid points (n_i, m_j) where: !!   n ∈ [n_min, n_max], m ∈ [-n, n] !! and computes exc, vxc_up, vxc_down at each point. !! !! @param[in]  U      Hubbard interaction parameter !! @param[in]  params Grid parameters (densities, points, system size) !! @param[out] table  Generated XC table !! @param[out] status Success (0) or error code subroutine generate_xc_table ( U , params , table , status ) real ( dp ), intent ( in ) :: U type ( grid_params_t ), intent ( in ) :: params type ( xc_table_t ), intent ( out ) :: table integer , intent ( out ) :: status integer :: i , j real ( dp ) :: n , m , n_up , n_dw , delta_n , delta_m type ( xc_potentials_t ) :: v_xc integer :: actual_m_points status = 0 table % U = U table % n_points_n = params % n_points table % n_points_m = params % m_points allocate ( table % n_grid ( params % n_points )) allocate ( table % m_grid ( params % m_points , params % n_points )) allocate ( table % exc ( params % m_points , params % n_points )) allocate ( table % vxc_up ( params % m_points , params % n_points )) allocate ( table % vxc_down ( params % m_points , params % n_points )) ! Initialize with NaN (for debugging) table % exc = ieee_value ( 0.0_dp , ieee_quiet_nan ) table % vxc_up = ieee_value ( 0.0_dp , ieee_quiet_nan ) table % vxc_down = ieee_value ( 0.0_dp , ieee_quiet_nan ) delta_n = ( params % n_max - params % n_min ) / real ( params % n_points - 1 , dp ) !$OMP PARALLEL DO PRIVATE(i, j, n, m, n_up, n_dw, delta_m, v_xc, actual_m_points) & !$OMP SHARED(table, params, U, delta_n) SCHEDULE(dynamic) do i = 1 , params % n_points n = params % n_min + real ( i - 1 , dp ) * delta_n table % n_grid ( i ) = n actual_m_points = params % m_points if ( actual_m_points > 1 ) then delta_m = ( 2.0_dp * n ) / real ( actual_m_points - 1 , dp ) else delta_m = 0.0_dp end if do j = 1 , actual_m_points m = - n + real ( j - 1 , dp ) * delta_m table % m_grid ( j , i ) = m n_up = 0.5_dp * ( n + m ) n_dw = 0.5_dp * ( n - m ) if ( n_up < 0.0_dp . or . n_up > 1.0_dp . or . & n_dw < 0.0_dp . or . n_dw > 1.0_dp ) then cycle end if table % exc ( j , i ) = compute_E_xc ( n_up , n_dw , U , params % L ) v_xc = compute_V_xc_numerical ( n_up , n_dw , U , params % L ) table % vxc_up ( j , i ) = v_xc % v_xc_up table % vxc_down ( j , i ) = v_xc % v_xc_down end do end do !$OMP END PARALLEL DO end subroutine generate_xc_table !> Generate multiple XC tables using continuation method in U !! !! Efficiently generates tables for multiple U values by: !! 1. Computing first table from scratch !! 2. Using continuation method for subsequent U values !! 3. Saving each table to binary format !! !! @param[in]  U_values   Array of Hubbard U values !! @param[in]  params     Grid parameters !! @param[in]  output_dir Directory to save table files !! @param[out] status     Success (0) or error code subroutine generate_table_grid ( U_values , params , output_dir , status ) real ( dp ), intent ( in ) :: U_values (:) type ( grid_params_t ), intent ( in ) :: params character ( len =* ), intent ( in ) :: output_dir integer , intent ( out ) :: status integer :: k , n_U , io_stat real ( dp ) :: U_current type ( xc_table_t ) :: table character ( len = 256 ) :: filename character ( len = 32 ) :: U_str status = 0 n_U = size ( U_values ) print '(A)' , \"=========================================\" print '(A)' , \"  XC Table Grid Generation\" print '(A)' , \"=========================================\" print '(A,I0,A)' , \"Generating \" , n_U , \" tables with continuation method\" print '(A,F6.2,A,F6.2)' , \"U range: \" , U_values ( 1 ), \" to \" , U_values ( n_U ) print '(A,I0,A,I0)' , \"Grid size: \" , params % n_points , \" x \" , params % m_points print '(A)' , \"\" do k = 1 , n_U U_current = U_values ( k ) print '(A,I0,A,I0,A,F6.2)' , \"Processing U(\" , k , \"/\" , n_U , \") = \" , U_current call generate_xc_table ( U_current , params , table , status ) if ( status /= 0 ) then print '(A,F6.2)' , \"  ERROR: Failed to generate table for U = \" , U_current return end if write ( U_str , '(F6.2)' ) U_current U_str = adjustl ( U_str ) filename = trim ( output_dir ) // \"/lsda_hub_u\" // trim ( U_str ) // \".dat\" call write_fortran_table ( filename , table , io_stat ) if ( io_stat /= 0 ) then print '(A)' , \"  ERROR: Failed to write table file\" status = - 1 return end if print '(A,A)' , \"  Saved: \" , trim ( filename ) ! Deallocate table arrays for next iteration if ( allocated ( table % n_grid )) deallocate ( table % n_grid ) if ( allocated ( table % m_grid )) deallocate ( table % m_grid ) if ( allocated ( table % exc )) deallocate ( table % exc ) if ( allocated ( table % vxc_up )) deallocate ( table % vxc_up ) if ( allocated ( table % vxc_down )) deallocate ( table % vxc_down ) end do print '(A)' , \"\" print '(A)' , \"=========================================\" print '(A,I0,A)' , \"Successfully generated \" , n_U , \" XC tables!\" print '(A)' , \"=========================================\" end subroutine generate_table_grid end module bethe_tables","tags":"","url":"sourcefile/bethe_tables.f90.html"},{"title":"potential_barrier.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~potential_barrier.f90~~EfferentGraph sourcefile~potential_barrier.f90 potential_barrier.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~potential_barrier.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~potential_barrier.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~potential_barrier.f90~~AfferentGraph sourcefile~potential_barrier.f90 potential_barrier.f90 sourcefile~potential_factory.f90 potential_factory.f90 sourcefile~potential_factory.f90->sourcefile~potential_barrier.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Module for barrier potentials !! !! Implements rectangular barrier potentials: !! - Single barrier: One rectangular barrier !! - Double barrier: Two barriers creating a quantum well !! !! Physical interpretation: !! - V_bar > 0: Potential barrier (particle reflection) !! - V_bar < 0: Potential well (particle attraction) !! - Models quantum tunneling, resonant transmission !! - Double barrier: Fabry-Pérot resonances, quasi-bound states !! !! Reference: Quantum mechanics textbooks (Griffiths, Cohen-Tannoudji) module potential_barrier use lsda_constants , only : dp use lsda_errors , only : ERROR_SUCCESS , ERROR_OUT_OF_BOUNDS implicit none private public :: potential_barrier_single public :: potential_barrier_double contains !> Single rectangular barrier: V(i) = V_bar for i_start ≤ i ≤ i_end, else 0 !! !! Creates a rectangular barrier in a specified region. !! !! Physical properties: !! - V_bar > 0: Barrier (reflection, tunneling through barrier) !! - V_bar < 0: Well (attraction, bound states possible) !! - Width w = i_end - i_start + 1 determines tunneling probability !! - For V_bar >> E: Exponential decay of wavefunction in barrier !! !! Applications: !! - Quantum tunneling experiments !! - Scanning tunneling microscopy (STM) !! - Tunnel diodes !! !! @param[in]  V_bar    Barrier height (can be positive or negative) !! @param[in]  i_start  Starting position of barrier (1-indexed) !! @param[in]  i_end    Ending position of barrier (1-indexed) !! @param[in]  L        Number of lattice sites !! @param[out] V        Potential array V(i) for i = 1..L !! @param[out] ierr     Error flag (ERROR_SUCCESS or ERROR_OUT_OF_BOUNDS) !! !! @note Width: w = i_end - i_start + 1 !! @note For w → 0: No barrier (delta-like) !! @note For w → ∞: Infinite barrier (no tunneling) subroutine potential_barrier_single ( V_bar , i_start , i_end , L , V , ierr ) real ( dp ), intent ( in ) :: V_bar integer , intent ( in ) :: i_start , i_end , L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr V = 0.0_dp ierr = ERROR_SUCCESS if ( i_start < 1 . or . i_start > L ) then ierr = ERROR_OUT_OF_BOUNDS return end if if ( i_end < 1 . or . i_end > L ) then ierr = ERROR_OUT_OF_BOUNDS return end if if ( i_end < i_start ) then ierr = ERROR_OUT_OF_BOUNDS return end if V ( i_start : i_end ) = V_bar end subroutine potential_barrier_single !> Double rectangular barrier: Two barriers creating a quantum well !! !! Creates two barriers separated by a quantum well, exactly matching C++ implementation. !! This geometry exhibits Fabry-Pérot-like resonances. !! !! C++ signature: double_barrier(int Na, double Vb, double Lb, double Vwell, double Lwell, double **v_ext) !! !! Geometry (centered at x0): !!   x_2         x_1        x0        x1         x2 !!    |----Lb----|---Lwell/2---|---Lwell/2---|----Lb----| !!   [  Barreira  ][ Poço (Vwell) ][  Barreira  ] !! !! Physical properties: !! - Creates quasi-bound states in the well between barriers !! - Resonant tunneling at specific energies !! - Transmission peaks when E matches well energy levels !! - Well region typically has V_well < 0 (attractive potential) !! !! Applications: !! - Resonant tunneling diodes (RTD) !! - Quantum cascade lasers !! - Electron wave interferometry !! !! @param[in]  V_bar     Barrier height (positive for barrier) !! @param[in]  L_bar     Barrier width (each barrier has this width) !! @param[in]  V_well    Well potential (typically negative for attractive well) !! @param[in]  L_well    Well width (distance between inner edges of barriers) !! @param[in]  L         Number of lattice sites !! @param[out] V         Potential array V(i) for i = 1..L !! @param[out] ierr      Error flag (ERROR_SUCCESS or ERROR_OUT_OF_BOUNDS) !! !! @note Matches C++ double_barrier implementation exactly (lsda_potential.cc lines 166-194) !! @note SMALL = 1.0e-10 tolerance for region boundaries !! @note For L_well small: Strong coupling, large splitting !! @note For L_well large: Weak coupling, sharp resonances subroutine potential_barrier_double ( V_bar , L_bar , V_well , L_well , L , V , ierr ) real ( dp ), intent ( in ) :: V_bar , L_bar , V_well , L_well integer , intent ( in ) :: L real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr real ( dp ) :: x0 , x1 , x2 , x_1 , x_2 integer :: i real ( dp ), parameter :: SMALL = 1.0e-10_dp ierr = ERROR_SUCCESS V = 0.0_dp ! Calculate center position (matches C++ logic) ! C++: x0 = (Na%2 ? (double(Na/2)) + 1.0 : (double(Na/2)) + 0.5) if ( mod ( L , 2 ) == 1 ) then ! Odd L: center at (L/2) + 1 = (L+1)/2 x0 = real ( L / 2 , dp ) + 1.0_dp else ! Even L: center at (L/2) + 0.5 x0 = real ( L / 2 , dp ) + 0.5_dp end if ! Calculate region boundaries (matches C++ lines 171-175) x1 = x0 + L_well / 2.0_dp ! Right edge of well x2 = x1 + L_bar ! Right edge of right barrier x_1 = x0 - L_well / 2.0_dp ! Left edge of well x_2 = x_1 - L_bar ! Left edge of left barrier ! Apply potential to each site (matches C++ lines 179-191) do i = 1 , L if ( x_2 - SMALL < real ( i , dp ) . and . real ( i , dp ) < x_1 + SMALL ) then ! Left barrier region V ( i ) = V_bar else if ( x1 - SMALL < real ( i , dp ) . and . real ( i , dp ) < x2 + SMALL ) then ! Right barrier region V ( i ) = V_bar else if ( x_1 + SMALL <= real ( i , dp ) . and . real ( i , dp ) <= x1 - SMALL ) then ! Well region (between barriers) V ( i ) = V_well else ! Outside regions V ( i ) = 0.0_dp end if end do end subroutine potential_barrier_double end module potential_barrier","tags":"","url":"sourcefile/potential_barrier.f90.html"},{"title":"lsda_constants.f90 – LSDA-Hubbard-Fortran","text":"Files dependent on this one sourcefile~~lsda_constants.f90~~AfferentGraph sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~adaptive_mixing.f90 adaptive_mixing.f90 sourcefile~adaptive_mixing.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~adaptive_mixing.f90->sourcefile~lsda_errors.f90 sourcefile~bethe_equations.f90 bethe_equations.f90 sourcefile~bethe_equations.f90->sourcefile~lsda_constants.f90 sourcefile~bethe_tables.f90 bethe_tables.f90 sourcefile~bethe_tables.f90->sourcefile~lsda_constants.f90 sourcefile~bethe_tables.f90->sourcefile~bethe_equations.f90 sourcefile~nonlinear_solvers.f90 nonlinear_solvers.f90 sourcefile~bethe_tables.f90->sourcefile~nonlinear_solvers.f90 sourcefile~table_io.f90 table_io.f90 sourcefile~bethe_tables.f90->sourcefile~table_io.f90 sourcefile~boundary_conditions.f90 boundary_conditions.f90 sourcefile~boundary_conditions.f90->sourcefile~lsda_constants.f90 sourcefile~boundary_conditions.f90->sourcefile~lsda_errors.f90 sourcefile~continuation.f90 continuation.f90 sourcefile~continuation.f90->sourcefile~lsda_constants.f90 sourcefile~continuation.f90->sourcefile~bethe_equations.f90 sourcefile~continuation.f90->sourcefile~nonlinear_solvers.f90 sourcefile~convergence_monitor.f90 convergence_monitor.f90 sourcefile~convergence_monitor.f90->sourcefile~lsda_constants.f90 sourcefile~convergence_monitor.f90->sourcefile~lsda_errors.f90 sourcefile~degeneracy_handler.f90 degeneracy_handler.f90 sourcefile~degeneracy_handler.f90->sourcefile~lsda_constants.f90 sourcefile~degeneracy_handler.f90->sourcefile~lsda_errors.f90 sourcefile~density_calculator.f90 density_calculator.f90 sourcefile~density_calculator.f90->sourcefile~lsda_constants.f90 sourcefile~density_calculator.f90->sourcefile~lsda_errors.f90 sourcefile~hamiltonian_builder.f90 hamiltonian_builder.f90 sourcefile~hamiltonian_builder.f90->sourcefile~lsda_constants.f90 sourcefile~hamiltonian_builder.f90->sourcefile~boundary_conditions.f90 sourcefile~hamiltonian_builder.f90->sourcefile~lsda_errors.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~lsda_constants.f90 sourcefile~input_parser.f90->sourcefile~boundary_conditions.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~input_parser.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_types.f90 lsda_types.f90 sourcefile~input_parser.f90->sourcefile~lsda_types.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_constants.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~adaptive_mixing.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~boundary_conditions.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~convergence_monitor.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~density_calculator.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~hamiltonian_builder.f90 sourcefile~lapack_wrapper.f90 lapack_wrapper.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lapack_wrapper.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_errors.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lsda_types.f90 sourcefile~mixing_schemes.f90 mixing_schemes.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~mixing_schemes.f90 sourcefile~xc_lsda.f90 xc_lsda.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~xc_lsda.f90 sourcefile~lapack_wrapper.f90->sourcefile~lsda_constants.f90 sourcefile~lapack_wrapper.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_types.f90->sourcefile~lsda_constants.f90 sourcefile~mixing_schemes.f90->sourcefile~lsda_constants.f90 sourcefile~mixing_schemes.f90->sourcefile~lsda_errors.f90 sourcefile~nonlinear_solvers.f90->sourcefile~lsda_constants.f90 sourcefile~nonlinear_solvers.f90->sourcefile~bethe_equations.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~lsda_constants.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90->sourcefile~lsda_errors.f90 sourcefile~output_writer.f90->sourcefile~lsda_types.f90 sourcefile~potential_barrier.f90 potential_barrier.f90 sourcefile~potential_barrier.f90->sourcefile~lsda_constants.f90 sourcefile~potential_barrier.f90->sourcefile~lsda_errors.f90 sourcefile~potential_factory.f90 potential_factory.f90 sourcefile~potential_factory.f90->sourcefile~lsda_constants.f90 sourcefile~potential_factory.f90->sourcefile~lsda_errors.f90 sourcefile~potential_factory.f90->sourcefile~potential_barrier.f90 sourcefile~potential_harmonic.f90 potential_harmonic.f90 sourcefile~potential_factory.f90->sourcefile~potential_harmonic.f90 sourcefile~potential_impurity.f90 potential_impurity.f90 sourcefile~potential_factory.f90->sourcefile~potential_impurity.f90 sourcefile~potential_quasiperiodic.f90 potential_quasiperiodic.f90 sourcefile~potential_factory.f90->sourcefile~potential_quasiperiodic.f90 sourcefile~potential_random.f90 potential_random.f90 sourcefile~potential_factory.f90->sourcefile~potential_random.f90 sourcefile~potential_uniform.f90 potential_uniform.f90 sourcefile~potential_factory.f90->sourcefile~potential_uniform.f90 sourcefile~potential_harmonic.f90->sourcefile~lsda_constants.f90 sourcefile~potential_harmonic.f90->sourcefile~lsda_errors.f90 sourcefile~potential_impurity.f90->sourcefile~lsda_constants.f90 sourcefile~potential_impurity.f90->sourcefile~lsda_errors.f90 sourcefile~potential_quasiperiodic.f90->sourcefile~lsda_constants.f90 sourcefile~potential_quasiperiodic.f90->sourcefile~lsda_errors.f90 sourcefile~potential_random.f90->sourcefile~lsda_constants.f90 sourcefile~potential_random.f90->sourcefile~lsda_errors.f90 sourcefile~potential_uniform.f90->sourcefile~lsda_constants.f90 sourcefile~potential_uniform.f90->sourcefile~lsda_errors.f90 sourcefile~spline2d.f90 spline2d.f90 sourcefile~spline2d.f90->sourcefile~lsda_constants.f90 sourcefile~table_io.f90->sourcefile~lsda_constants.f90 sourcefile~table_io.f90->sourcefile~lsda_errors.f90 sourcefile~xc_lsda.f90->sourcefile~lsda_constants.f90 sourcefile~xc_lsda.f90->sourcefile~lsda_errors.f90 sourcefile~xc_lsda.f90->sourcefile~spline2d.f90 sourcefile~xc_lsda.f90->sourcefile~table_io.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Physical and numerical constants for LSDA-Hubbard calculations module lsda_constants use , intrinsic :: iso_fortran_env , only : real64 , int32 implicit none integer , parameter :: dp = real64 ! Double precision (64 bits, ~16 digits) integer , parameter :: sp = int32 ! Single precision (32 bits, ~8 digits) real ( dp ), parameter :: PI = 4.0_dp * atan ( 1.0_dp ) ! π = 3.14159... real ( dp ), parameter :: TWOPI = 2.0_dp * PI ! 2π = 6.28318... real ( dp ), parameter :: U_SMALL = 1.0e-9_dp ! Check if U ≈ 0 real ( dp ), parameter :: TOL_DEFAULT = 1.0e-16_dp ! Convergence tol integer , parameter :: ITER_MAX = 10000 ! Max iterations SCF ! Mixing parameters (convention from original C++ code): ! C++ uses: V_new = Mix * V_old + (1-Mix) * V_calc (Mix = 0.95, keeps 95% old) ! Fortran uses: n_new = alpha * n_calc + (1-alpha) * n_old (alpha = weight of new) ! Therefore: alpha = 1 - Mix_cpp to maintain equivalence real ( dp ), parameter :: INITIAL_MIX = 0.95_dp ! C++ mixing factor (keeps 95% old) real ( dp ), parameter :: MIX_ALPHA = 1.0_dp - INITIAL_MIX ! Fortran mixing (5% new, 95% old) real ( dp ), parameter :: NEWTON_TOL = 1.0e-10_dp ! Newton convergence tol integer , parameter :: NEWTON_MAX_ITER = 50 ! Max Newton iterations real ( dp ), parameter :: SCF_ENERGY_TOL = 1.0e-8_dp ! SCF energy convergence tol real ( dp ), parameter :: SCF_DENSITY_TOL = 1.0e-6_dp ! SCF density convergence tol end module lsda_constants","tags":"","url":"sourcefile/lsda_constants.f90.html"},{"title":"lapack_wrapper.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~lapack_wrapper.f90~~EfferentGraph sourcefile~lapack_wrapper.f90 lapack_wrapper.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~lapack_wrapper.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~lapack_wrapper.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~lapack_wrapper.f90~~AfferentGraph sourcefile~lapack_wrapper.f90 lapack_wrapper.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~lapack_wrapper.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module lapack_wrapper use lsda_constants , only : dp use lsda_errors , only : ERROR_INVALID_INPUT , ERROR_LAPACK_FAILED , & ERROR_SIZE_MISMATCH , ERROR_LAPACK_INVALID_ARG , & ERROR_CONVERGENCE_FAILED , ERROR_SUCCESS implicit none private public :: validate_diagonalization_inputs public :: diagonalize_symmetric_real public :: diagonalize_symmetric_real_values_only public :: diagonalize_hermitian_complex public :: diagonalize_hermitian_complex_values_only interface subroutine DSYEVD ( jobz , uplo , n , a , lda , w , & work , lwork , iwork , liwork , info ) import :: dp character ( len = 1 ), intent ( in ) :: jobz character ( len = 1 ), intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda real ( dp ), intent ( inout ) :: a ( lda , * ) real ( dp ), intent ( out ) :: w ( * ) real ( dp ), intent ( out ) :: work ( * ) integer , intent ( in ) :: lwork integer , intent ( out ) :: iwork ( * ) integer , intent ( in ) :: liwork integer , intent ( out ) :: info end subroutine DSYEVD subroutine ZHEEVD ( jobz , uplo , n , a , lda , w , & work , lwork , rwork , lrwork , & iwork , liwork , info ) import :: dp character ( len = 1 ), intent ( in ) :: jobz character ( len = 1 ), intent ( in ) :: uplo integer , intent ( in ) :: n integer , intent ( in ) :: lda complex ( dp ), intent ( inout ) :: a ( lda , * ) real ( dp ), intent ( out ) :: w ( * ) complex ( dp ), intent ( out ) :: work ( * ) integer , intent ( in ) :: lwork real ( dp ), intent ( out ) :: rwork ( * ) integer , intent ( in ) :: lrwork integer , intent ( out ) :: iwork ( * ) integer , intent ( in ) :: liwork integer , intent ( out ) :: info end subroutine ZHEEVD end interface contains subroutine validate_diagonalization_inputs ( L , H , eigvals , eigvecs , compute_vectors , ierr ) integer , intent ( in ) :: L real ( dp ), intent ( in ) :: H (:,:), eigvals (:) real ( dp ), intent ( in ), optional :: eigvecs (:,:) logical , intent ( in ) :: compute_vectors integer , intent ( out ) :: ierr ierr = 0 if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( eigvals ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( compute_vectors ) then if (. not . present ( eigvecs )) then ierr = ERROR_INVALID_INPUT return end if if ( size ( eigvecs , 1 ) /= L . or . size ( eigvecs , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if end if end subroutine validate_diagonalization_inputs !> @brief Diagonalize real symmetric matrix (eigenvalues + eigenvectors) !! !! Solves H*v = lambda*v for symmetric H using LAPACK DSYEVD. !! Returns eigenvalues in ascending order and eigenvectors as columns. !! !! @param[in] H Real symmetric matrix (L x L) !! @param[in] L Dimension of matrix !! @param[out] eigvals Eigenvalues in ascending order (length L) !! @param[out] eigvecs Eigenvectors as columns (L x L) !! @param[out] ierr Error code (0 = success) subroutine diagonalize_symmetric_real ( H , L , eigvals , eigvecs , ierr ) real ( dp ), intent ( in ) :: H (:,:) integer , intent ( in ) :: L real ( dp ), intent ( out ) :: eigvals (:) real ( dp ), intent ( out ) :: eigvecs (:,:) integer , intent ( out ) :: ierr real ( dp ), allocatable :: H_work (:,:) real ( dp ), allocatable :: work (:) integer , allocatable :: iwork (:) integer :: lwork , liwork , info call validate_diagonalization_inputs ( L , H , eigvals , eigvecs , . true ., ierr ) if ( ierr /= ERROR_SUCCESS ) return allocate ( H_work ( L , L )) H_work = H lwork = - 1 liwork = - 1 allocate ( work ( 1 ), iwork ( 1 )) call DSYEVD ( 'V' , 'U' , L , H_work , L , eigvals , work , & lwork , iwork , liwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_INVALID_ARG deallocate ( H_work , work , iwork ) return end if lwork = int ( work ( 1 )) liwork = iwork ( 1 ) deallocate ( work , iwork ) allocate ( work ( lwork ), iwork ( liwork )) ! Actual diagonalization call DSYEVD ( 'V' , 'U' , L , H_work , L , eigvals , work , & lwork , iwork , liwork , info ) if ( info < 0 ) then ierr = ERROR_LAPACK_INVALID_ARG else if ( info > 0 ) then ierr = ERROR_CONVERGENCE_FAILED else ierr = ERROR_SUCCESS eigvecs = H_work end if deallocate ( H_work , work , iwork ) end subroutine diagonalize_symmetric_real !> @brief Diagonalize real symmetric matrix (eigenvalues only) !! !! Faster version that only computes eigenvalues, not eigenvectors. !! !! @param[in] H Real symmetric matrix (L x L) !! @param[in] L Dimension of matrix !! @param[out] eigvals Eigenvalues in ascending order (length L) !! @param[out] ierr Error code (0 = success) subroutine diagonalize_symmetric_real_values_only ( H , L , eigvals , ierr ) real ( dp ), intent ( in ) :: H (:,:) integer , intent ( in ) :: L real ( dp ), intent ( out ) :: eigvals (:) integer , intent ( out ) :: ierr real ( dp ), allocatable :: H_work (:,:) real ( dp ), allocatable :: work (:) integer , allocatable :: iwork (:) integer :: lwork , liwork , info call validate_diagonalization_inputs ( L , H , eigvals , compute_vectors = . false ., ierr = ierr ) if ( ierr /= ERROR_SUCCESS ) return allocate ( H_work ( L , L )) H_work = H lwork = - 1 liwork = - 1 allocate ( work ( 1 ), iwork ( 1 )) call DSYEVD ( 'N' , 'U' , L , H_work , L , eigvals , work , & lwork , iwork , liwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_INVALID_ARG deallocate ( H_work , work , iwork ) return end if lwork = int ( work ( 1 )) liwork = iwork ( 1 ) deallocate ( work , iwork ) allocate ( work ( lwork ), iwork ( liwork )) ! Actual diagonalization call DSYEVD ( 'N' , 'U' , L , H_work , L , eigvals , work , & lwork , iwork , liwork , info ) if ( info < 0 ) then ierr = ERROR_LAPACK_INVALID_ARG else if ( info > 0 ) then ierr = ERROR_CONVERGENCE_FAILED else ierr = ERROR_SUCCESS end if deallocate ( H_work , work , iwork ) end subroutine diagonalize_symmetric_real_values_only !> @brief Diagonalize complex Hermitian matrix (eigenvalues + eigenvectors) !! !! Solves H*v = lambda*v for Hermitian H using LAPACK ZHEEVD. !! Eigenvalues are real even though H is complex. !! !! @param[in] H Complex Hermitian matrix (L x L) !! @param[in] L Dimension of matrix !! @param[out] eigvals Real eigenvalues in ascending order (length L) !! @param[out] eigvecs Complex eigenvectors as columns (L x L) !! @param[out] ierr Error code (0 = success) subroutine diagonalize_hermitian_complex ( H , L , eigvals , eigvecs , ierr ) complex ( dp ), intent ( in ) :: H (:,:) integer , intent ( in ) :: L real ( dp ), intent ( out ) :: eigvals (:) complex ( dp ), intent ( out ) :: eigvecs (:,:) integer , intent ( out ) :: ierr complex ( dp ), allocatable :: H_work (:,:) complex ( dp ), allocatable :: work (:) real ( dp ), allocatable :: rwork (:) integer , allocatable :: iwork (:) integer :: lwork , lrwork , liwork , info ! Validate inputs ierr = ERROR_SUCCESS if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( eigvals ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( eigvecs , 1 ) /= L . or . size ( eigvecs , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if allocate ( H_work ( L , L )) H_work = H lwork = - 1 lrwork = - 1 liwork = - 1 allocate ( work ( 1 ), rwork ( 1 ), iwork ( 1 )) call ZHEEVD ( 'V' , 'U' , L , H_work , L , eigvals , work , & lwork , rwork , lrwork , iwork , liwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_INVALID_ARG deallocate ( H_work , work , rwork , iwork ) return end if lwork = int ( real ( work ( 1 ), kind = dp )) lrwork = int ( rwork ( 1 )) liwork = iwork ( 1 ) deallocate ( work , rwork , iwork ) allocate ( work ( lwork ), iwork ( liwork ), rwork ( lrwork )) ! Actual diagonalization call ZHEEVD ( 'V' , 'U' , L , H_work , L , eigvals , work , & lwork , rwork , lrwork , iwork , liwork , info ) if ( info < 0 ) then ierr = ERROR_LAPACK_INVALID_ARG else if ( info > 0 ) then ierr = ERROR_CONVERGENCE_FAILED else ierr = ERROR_SUCCESS eigvecs = H_work end if deallocate ( H_work , work , rwork , iwork ) end subroutine diagonalize_hermitian_complex subroutine diagonalize_hermitian_complex_values_only ( H , L , eigvals , ierr ) complex ( dp ), intent ( in ) :: H (:,:) integer , intent ( in ) :: L real ( dp ), intent ( out ) :: eigvals (:) integer , intent ( out ) :: ierr complex ( dp ), allocatable :: H_work (:,:) complex ( dp ), allocatable :: work (:) real ( dp ), allocatable :: rwork (:) integer , allocatable :: iwork (:) integer :: lwork , lrwork , liwork , info ! Validate inputs ierr = ERROR_SUCCESS if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( eigvals ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if allocate ( H_work ( L , L )) H_work = H lwork = - 1 lrwork = - 1 liwork = - 1 allocate ( work ( 1 ), rwork ( 1 ), iwork ( 1 )) call ZHEEVD ( 'N' , 'U' , L , H_work , L , eigvals , work , & lwork , rwork , lrwork , iwork , liwork , info ) if ( info /= 0 ) then ierr = ERROR_LAPACK_INVALID_ARG deallocate ( H_work , work , rwork , iwork ) return end if lwork = int ( real ( work ( 1 ), kind = dp )) lrwork = int ( rwork ( 1 )) liwork = iwork ( 1 ) deallocate ( work , rwork , iwork ) allocate ( work ( lwork ), iwork ( liwork ), rwork ( lrwork )) ! Actual diagonalization call ZHEEVD ( 'N' , 'U' , L , H_work , L , eigvals , work , & lwork , rwork , lrwork , iwork , liwork , info ) if ( info < 0 ) then ierr = ERROR_LAPACK_INVALID_ARG else if ( info > 0 ) then ierr = ERROR_CONVERGENCE_FAILED else ierr = ERROR_SUCCESS end if deallocate ( H_work , work , rwork , iwork ) end subroutine diagonalize_hermitian_complex_values_only end module lapack_wrapper","tags":"","url":"sourcefile/lapack_wrapper.f90.html"},{"title":"table_io.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~table_io.f90~~EfferentGraph sourcefile~table_io.f90 table_io.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~table_io.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~table_io.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~table_io.f90~~AfferentGraph sourcefile~table_io.f90 table_io.f90 sourcefile~bethe_tables.f90 bethe_tables.f90 sourcefile~bethe_tables.f90->sourcefile~table_io.f90 sourcefile~xc_lsda.f90 xc_lsda.f90 sourcefile~xc_lsda.f90->sourcefile~table_io.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~xc_lsda.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Input/output routines for XC functional tables module table_io use , intrinsic :: iso_fortran_env , only : real64 , int32 , error_unit use lsda_constants , only : dp use lsda_errors , only : ERROR_SUCCESS , ERROR_FILE_NOT_FOUND , & ERROR_FILE_READ , ERROR_FILE_WRITE , & ERROR_INVALID_INPUT implicit none private public :: xc_table_t public :: read_cpp_table , write_fortran_table , read_fortran_table public :: deallocate_table , print_table_info public :: extract_U_from_filename integer , parameter :: MAX_LINE_LEN = 256 type :: xc_table_t real ( dp ) :: U integer :: n_points_n integer :: n_points_m real ( dp ), allocatable :: n_grid (:) real ( dp ), allocatable :: m_grid (:,:) real ( dp ), allocatable :: exc (:,:) real ( dp ), allocatable :: vxc_up (:,:) real ( dp ), allocatable :: vxc_down (:,:) end type xc_table_t contains subroutine read_cpp_table ( filename , table , ierr ) character ( len =* ), intent ( in ) :: filename type ( xc_table_t ), intent ( out ) :: table integer , intent ( out ) :: ierr integer :: unit , io_stat character ( len = MAX_LINE_LEN ) :: line integer :: n_blocks , n_mag_points integer :: i_block , i_mag real ( dp ) :: n_val , m_val , exc_val , vxc_up_val , vxc_down_val call extract_U_from_filename ( filename , table % U , ierr ) if ( ierr /= ERROR_SUCCESS ) return call count_blocks_and_points ( filename , n_blocks , n_mag_points , ierr ) if ( ierr /= ERROR_SUCCESS ) return table % n_points_n = n_blocks table % n_points_m = n_mag_points allocate ( table % n_grid ( n_blocks )) allocate ( table % m_grid ( n_mag_points , n_blocks )) allocate ( table % exc ( n_mag_points , n_blocks )) allocate ( table % vxc_up ( n_mag_points , n_blocks )) allocate ( table % vxc_down ( n_mag_points , n_blocks )) open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then ierr = ERROR_FILE_NOT_FOUND return end if i_block = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then ierr = ERROR_FILE_READ close ( unit ) exit end if if ( line ( 1 : 2 ) == 'n:' ) then i_block = i_block + 1 read ( line ( 3 :), * , iostat = io_stat ) n_val if ( io_stat /= 0 ) then ierr = ERROR_FILE_READ close ( unit ) return end if table % n_grid ( i_block ) = n_val read ( unit , '(A)' , iostat = io_stat ) line ! Skip header if ( io_stat /= 0 ) then ierr = ERROR_FILE_READ close ( unit ) return end if do i_mag = 1 , n_mag_points read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 . or . line ( 1 : 2 ) == 'n:' ) then if ( i_mag > 1 ) then table % m_grid ( i_mag : n_mag_points , i_block ) = & table % m_grid ( i_mag - 1 , i_block ) table % exc ( i_mag : n_mag_points , i_block ) = & table % exc ( i_mag - 1 , i_block ) table % vxc_up ( i_mag : n_mag_points , i_block ) = & table % vxc_up ( i_mag - 1 , i_block ) table % vxc_down ( i_mag : n_mag_points , i_block ) = & table % vxc_down ( i_mag - 1 , i_block ) end if if ( line ( 1 : 2 ) == 'n:' ) backspace ( unit ) exit end if read ( line , * , iostat = io_stat ) m_val , exc_val , vxc_up_val , vxc_down_val if ( io_stat /= 0 ) then ierr = ERROR_FILE_READ close ( unit ) return end if table % m_grid ( i_mag , i_block ) = m_val table % exc ( i_mag , i_block ) = exc_val table % vxc_up ( i_mag , i_block ) = vxc_up_val table % vxc_down ( i_mag , i_block ) = vxc_down_val end do end if end do close ( unit ) ierr = ERROR_SUCCESS end subroutine read_cpp_table subroutine count_blocks_and_points ( filename , n_blocks , n_mag_points , ierr ) character ( len =* ), intent ( in ) :: filename integer , intent ( out ) :: n_blocks , n_mag_points , ierr integer :: unit , io_stat character ( len = MAX_LINE_LEN ) :: line integer :: points_in_block , max_points logical :: in_data_section open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then ierr = ERROR_FILE_NOT_FOUND return end if n_blocks = 0 max_points = 0 points_in_block = 0 in_data_section = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then ierr = ERROR_FILE_READ close ( unit ) exit end if if ( line ( 1 : 2 ) == 'n:' ) then if ( n_blocks > 0 ) then max_points = max ( max_points , points_in_block ) end if n_blocks = n_blocks + 1 points_in_block = 0 in_data_section = . false . else if ( line ( 1 : 4 ) == '#mag' ) then in_data_section = . true . else if ( in_data_section . and . len_trim ( line ) > 0 ) then points_in_block = points_in_block + 1 end if end do if ( points_in_block > 0 ) then max_points = max ( max_points , points_in_block ) end if n_mag_points = max_points close ( unit ) if ( n_blocks == 0 . or . n_mag_points == 0 ) then ierr = ERROR_INVALID_INPUT return end if ierr = ERROR_SUCCESS end subroutine count_blocks_and_points subroutine extract_U_from_filename ( filename , U , ierr ) character ( len =* ), intent ( in ) :: filename real ( dp ), intent ( out ) :: U integer , intent ( out ) :: ierr integer :: pos_u , pos_end , i , io_stat character ( len = 32 ) :: u_string logical :: found_dot pos_u = index ( filename , '_u' ) if ( pos_u == 0 ) then ierr = ERROR_INVALID_INPUT return end if u_string = filename ( pos_u + 2 :) pos_end = 0 found_dot = . false . do i = 1 , len_trim ( u_string ) if ( u_string ( i : i ) == '.' ) then if ( found_dot ) then pos_end = i - 1 exit else found_dot = . true . end if else if (. not . (( u_string ( i : i ) >= '0' . and . u_string ( i : i ) <= '9' ) . or . & u_string ( i : i ) == '-' . or . u_string ( i : i ) == '+' . or . & u_string ( i : i ) == 'e' . or . u_string ( i : i ) == 'E' )) then pos_end = i - 1 exit end if end do if ( pos_end == 0 ) pos_end = len_trim ( u_string ) read ( u_string ( 1 : pos_end ), * , iostat = io_stat ) U if ( io_stat /= 0 ) then ierr = ERROR_FILE_READ return end if ierr = ERROR_SUCCESS end subroutine extract_U_from_filename subroutine write_fortran_table ( filename , table , ierr ) character ( len =* ), intent ( in ) :: filename type ( xc_table_t ), intent ( in ) :: table integer , intent ( out ) :: ierr integer :: unit , io_stat if (. not . allocated ( table % n_grid )) then ierr = ERROR_INVALID_INPUT return end if open ( newunit = unit , file = filename , status = 'replace' , action = 'write' , & form = 'unformatted' , access = 'stream' , iostat = io_stat ) if ( io_stat /= 0 ) then ierr = ERROR_FILE_WRITE return end if write ( unit , iostat = io_stat ) table % U if ( io_stat /= 0 ) goto 100 write ( unit , iostat = io_stat ) table % n_points_n , table % n_points_m if ( io_stat /= 0 ) goto 100 write ( unit , iostat = io_stat ) table % n_grid if ( io_stat /= 0 ) goto 100 write ( unit , iostat = io_stat ) table % m_grid if ( io_stat /= 0 ) goto 100 write ( unit , iostat = io_stat ) table % exc if ( io_stat /= 0 ) goto 100 write ( unit , iostat = io_stat ) table % vxc_up if ( io_stat /= 0 ) goto 100 write ( unit , iostat = io_stat ) table % vxc_down if ( io_stat /= 0 ) goto 100 close ( unit ) ierr = ERROR_SUCCESS return 100 ierr = ERROR_FILE_WRITE close ( unit ) end subroutine write_fortran_table subroutine read_fortran_table ( filename , table , ierr ) character ( len =* ), intent ( in ) :: filename type ( xc_table_t ), intent ( out ) :: table integer , intent ( out ) :: ierr integer :: unit , io_stat call deallocate_table ( table ) open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & form = 'unformatted' , access = 'stream' , iostat = io_stat ) if ( io_stat /= 0 ) then ierr = ERROR_FILE_NOT_FOUND return end if read ( unit , iostat = io_stat ) table % U if ( io_stat /= 0 ) goto 200 read ( unit , iostat = io_stat ) table % n_points_n , table % n_points_m if ( io_stat /= 0 ) goto 200 if ( table % n_points_n <= 0 . or . table % n_points_m <= 0 ) then ierr = ERROR_INVALID_INPUT close ( unit ) return end if allocate ( table % n_grid ( table % n_points_n )) allocate ( table % m_grid ( table % n_points_m , table % n_points_n )) allocate ( table % exc ( table % n_points_m , table % n_points_n )) allocate ( table % vxc_up ( table % n_points_m , table % n_points_n )) allocate ( table % vxc_down ( table % n_points_m , table % n_points_n )) read ( unit , iostat = io_stat ) table % n_grid if ( io_stat /= 0 ) goto 200 read ( unit , iostat = io_stat ) table % m_grid if ( io_stat /= 0 ) goto 200 read ( unit , iostat = io_stat ) table % exc if ( io_stat /= 0 ) goto 200 read ( unit , iostat = io_stat ) table % vxc_up if ( io_stat /= 0 ) goto 200 read ( unit , iostat = io_stat ) table % vxc_down if ( io_stat /= 0 ) goto 200 close ( unit ) ierr = ERROR_SUCCESS return 200 ierr = ERROR_FILE_READ close ( unit ) call deallocate_table ( table ) end subroutine read_fortran_table subroutine deallocate_table ( table ) type ( xc_table_t ), intent ( inout ) :: table if ( allocated ( table % n_grid )) deallocate ( table % n_grid ) if ( allocated ( table % m_grid )) deallocate ( table % m_grid ) if ( allocated ( table % exc )) deallocate ( table % exc ) if ( allocated ( table % vxc_up )) deallocate ( table % vxc_up ) if ( allocated ( table % vxc_down )) deallocate ( table % vxc_down ) end subroutine deallocate_table subroutine print_table_info ( table , unit ) type ( xc_table_t ), intent ( in ) :: table integer , intent ( in ), optional :: unit integer :: out_unit real ( dp ) :: n_min , n_max , m_min , m_max , exc_min , exc_max , vxc_min , vxc_max out_unit = 6 if ( present ( unit )) out_unit = unit if (. not . allocated ( table % n_grid )) then write ( out_unit , '(A)' ) \"XC Table: [UNALLOCATED]\" return end if n_min = minval ( table % n_grid ) n_max = maxval ( table % n_grid ) m_min = minval ( table % m_grid ) m_max = maxval ( table % m_grid ) exc_min = minval ( table % exc ) exc_max = maxval ( table % exc ) vxc_min = min ( minval ( table % vxc_up ), minval ( table % vxc_down )) vxc_max = max ( maxval ( table % vxc_up ), maxval ( table % vxc_down )) write ( out_unit , '(A)' ) \"=========================================\" write ( out_unit , '(A)' ) \"XC Table Summary\" write ( out_unit , '(A)' ) \"=========================================\" write ( out_unit , '(A,F8.4)' ) \"  Hubbard U:           \" , table % U write ( out_unit , '(A,I6)' ) \"  Density points:      \" , table % n_points_n write ( out_unit , '(A,I6)' ) \"  Magnetization points:\" , table % n_points_m write ( out_unit , '(A)' ) \"-----------------------------------------\" write ( out_unit , '(A,F10.6,A,F10.6)' ) \"  Density range:       \" , n_min , \" to \" , n_max write ( out_unit , '(A,ES12.5,A,ES12.5)' ) \"  Magnetization range: \" , m_min , \" to \" , m_max write ( out_unit , '(A)' ) \"-----------------------------------------\" write ( out_unit , '(A,ES12.5,A,ES12.5)' ) \"  E_xc range:          \" , exc_min , \" to \" , exc_max write ( out_unit , '(A,ES12.5,A,ES12.5)' ) \"  V_xc range:          \" , vxc_min , \" to \" , vxc_max write ( out_unit , '(A)' ) \"=========================================\" end subroutine print_table_info end module table_io","tags":"","url":"sourcefile/table_io.f90.html"},{"title":"potential_random.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~potential_random.f90~~EfferentGraph sourcefile~potential_random.f90 potential_random.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~potential_random.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~potential_random.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~potential_random.f90~~AfferentGraph sourcefile~potential_random.f90 potential_random.f90 sourcefile~potential_factory.f90 potential_factory.f90 sourcefile~potential_factory.f90->sourcefile~potential_random.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Module for random (disorder) potentials !! !! Implements disordered potentials modeling Anderson localization. !! Two distributions are available: !! - Uniform distribution: V(i) ~ U[-W/2, W/2] !! - Gaussian distribution: V(i) ~ N(0, σ²) !! !! Physical interpretation: !! - Models disorder in condensed matter systems !! - For large W or σ: Anderson localization (exponential decay of wavefunctions) !! - For small W or σ: Extended states (weak disorder) !! - Average: ⟨V(i)⟩ = 0 (typically) !! !! Reference: P.W. Anderson, \"Absence of Diffusion in Certain Random Lattices\" (1958) module potential_random use lsda_constants , only : dp , PI use lsda_errors , only : ERROR_SUCCESS , ERROR_NEGATIVE_VALUE implicit none private public :: potential_random_uniform public :: potential_random_gaussian contains !> Random potential with uniform distribution: V(i) ~ U[-W, W] !! !! Creates a disordered potential with uniform distribution. !! Each site has an independent random value drawn from [-W, W]. !! Matches C++ random1 implementation: V*(2*rand - 1). !! !! Physical properties: !! - Mean: ⟨V(i)⟩ = 0 !! - Variance: σ² = W²/3 !! - Models box disorder (flat probability distribution) !! !! @param[in]  W      Disorder strength (half-width of distribution), W > 0 !! @param[in]  L      Number of lattice sites !! @param[in]  seed   Random seed for reproducibility (use system time if < 0) !! @param[out] V      Potential array V(i) for i = 1..L !! @param[out] ierr   Error flag (ERROR_SUCCESS or ERROR_NEGATIVE_VALUE) !! !! @note For W → 0: No disorder (all sites have V ≈ 0) !! @note For W >> t (hopping): Strong disorder, Anderson localization !! @note Range is [-W, +W] with total width = 2W (matches C++ random1) subroutine potential_random_uniform ( W , L , seed , V , ierr ) real ( dp ), intent ( in ) :: W integer , intent ( in ) :: L , seed real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr integer :: i , seed_size integer , allocatable :: seed_array (:) real ( dp ) :: rand_val ierr = ERROR_SUCCESS if ( W < 0.0_dp ) then ierr = ERROR_NEGATIVE_VALUE V = 0.0_dp return end if ! Special case: W = 0 means no disorder if ( W == 0.0_dp ) then V = 0.0_dp return end if if ( seed >= 0 ) then call random_seed ( size = seed_size ) allocate ( seed_array ( seed_size )) seed_array = seed call random_seed ( put = seed_array ) deallocate ( seed_array ) else call random_seed () end if do i = 1 , L call random_number ( rand_val ) ! C++ formula: V*(2.0*rand - 1.0) gives [-V, +V] ! Matches C++ random1 implementation exactly V ( i ) = W * ( 2.0_dp * rand_val - 1.0_dp ) ! Maps [0,1] → [-W, +W] end do end subroutine potential_random_uniform !> Random potential with Gaussian distribution: V(i) ~ N(0, σ²) !! !! Creates a disordered potential with Gaussian (normal) distribution. !! Each site has an independent random value drawn from N(0, σ²). !! !! Physical properties: !! - Mean: ⟨V(i)⟩ = 0 !! - Standard deviation: σ !! - Models thermal/quantum fluctuations !! - More realistic than uniform disorder for many physical systems !! !! @param[in]  sigma  Standard deviation of disorder, σ > 0 !! @param[in]  L      Number of lattice sites !! @param[in]  seed   Random seed for reproducibility (use system time if < 0) !! @param[out] V      Potential array V(i) for i = 1..L !! @param[out] ierr   Error flag (ERROR_SUCCESS or ERROR_NEGATIVE_VALUE) !! !! @note Uses Box-Muller transform to generate Gaussian random numbers !! @note For σ → 0: No disorder (all sites have V ≈ 0) !! @note For σ >> t (hopping): Strong disorder, Anderson localization subroutine potential_random_gaussian ( sigma , L , seed , V , ierr ) real ( dp ), intent ( in ) :: sigma integer , intent ( in ) :: L , seed real ( dp ), dimension ( L ), intent ( out ) :: V integer , intent ( out ) :: ierr integer :: i , seed_size integer , allocatable :: seed_array (:) real ( dp ) :: u1 , u2 , z1 , z2 ierr = ERROR_SUCCESS if ( sigma < 0.0_dp ) then ierr = ERROR_NEGATIVE_VALUE V = 0.0_dp return end if ! Special case: sigma = 0 means no disorder if ( sigma == 0.0_dp ) then V = 0.0_dp return end if if ( seed >= 0 ) then call random_seed ( size = seed_size ) allocate ( seed_array ( seed_size )) seed_array = seed call random_seed ( put = seed_array ) deallocate ( seed_array ) else call random_seed () end if ! Generate Gaussian random values using Box-Muller transform do i = 1 , L , 2 call random_number ( u1 ) call random_number ( u2 ) ! Box-Muller transform z1 = sqrt ( - 2.0_dp * log ( u1 )) * cos ( 2.0_dp * PI * u2 ) z2 = sqrt ( - 2.0_dp * log ( u1 )) * sin ( 2.0_dp * PI * u2 ) V ( i ) = sigma * z1 if ( i + 1 <= L ) then V ( i + 1 ) = sigma * z2 end if end do end subroutine potential_random_gaussian end module potential_random","tags":"","url":"sourcefile/potential_random.f90.html"},{"title":"boundary_conditions.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~boundary_conditions.f90~~EfferentGraph sourcefile~boundary_conditions.f90 boundary_conditions.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~boundary_conditions.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~boundary_conditions.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~boundary_conditions.f90~~AfferentGraph sourcefile~boundary_conditions.f90 boundary_conditions.f90 sourcefile~hamiltonian_builder.f90 hamiltonian_builder.f90 sourcefile~hamiltonian_builder.f90->sourcefile~boundary_conditions.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~boundary_conditions.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~boundary_conditions.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~hamiltonian_builder.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> @brief Boundary conditions module for 1D tight-binding Hamiltonian !! !! This module implements different boundary conditions for the 1D Hubbard model: !! - Open Boundary Conditions (OBC): Confined chain with no hopping at edges !! - Periodic Boundary Conditions (PBC): Ring topology with momentum conservation !! - Twisted Boundary Conditions (TBC): Generalized PBC with phase twist (magnetic flux) !! !! The tight-binding Hamiltonian in matrix form is: !!  H_{ij} = -t \\delta_{i,j\\pm 1} + V_i \\delta_{ij}  !! !! Boundary conditions modify the edge terms (i=1, i=L): !! - OBC: H(1,L) = H(L,1) = 0 (no connection) !! - PBC: H(1,L) = H(L,1) = -t (periodic ring) !! - TBC: H(1,L) = -t e&#94;{iθ}, H(L,1) = -t e&#94;{-iθ} (twisted ring) !! !! Physical applications: !! - OBC: Edge states, surface physics, finite-size effects !! - PBC: Bulk properties, momentum conservation, Bethe Ansatz calculations !! - TBC: Persistent currents, Aharonov-Bohm effect, flux threading !! !! @note All functions assume hopping parameter t = 1 (energy units) !! @note TBC requires complex Hamiltonian matrix !! module boundary_conditions use lsda_constants , only : dp , PI , TWOPI use lsda_errors , only : ERROR_INVALID_INPUT , ERROR_OUT_OF_BOUNDS , ERROR_SIZE_MISMATCH implicit none private enum , bind ( c ) enumerator :: BC_OPEN = 1 enumerator :: BC_PERIODIC = 2 enumerator :: BC_TWISTED = 3 end enum public :: BC_OPEN , BC_PERIODIC , BC_TWISTED public :: apply_boundary_conditions public :: apply_boundary_conditions_complex public :: validate_bc_parameters public :: get_free_particle_eigenvalues contains !> @brief Validate boundary condition parameters !! !! Checks if BC type and associated parameters are physically valid: !! - BC type must be BC_OPEN, BC_PERIODIC, or BC_TWISTED !! - System size L must be > 1 !! - For TBC, theta must be present and in range [0, 2π) !! !! @param[in] bc_type Boundary condition type (BC_OPEN/BC_PERIODIC/BC_TWISTED) !! @param[in] theta Optional twist angle in radians (required for BC_TWISTED) !! @param[in] L Number of lattice sites !! @param[out] ierr Error code (0=success) !! !! @note Twist angle θ ∈ [0, 2π) corresponds to magnetic flux Φ/Φ₀ = θ/(2π) subroutine validate_bc_parameters ( bc_type , theta , L , ierr ) integer , intent ( in ) :: bc_type real ( dp ), intent ( in ), optional :: theta integer , intent ( in ) :: L integer , intent ( out ) :: ierr integer , parameter :: allowed ( 3 ) = [ BC_OPEN , BC_PERIODIC , BC_TWISTED ] ierr = 0 if ( L <= 1 ) then ierr = ERROR_INVALID_INPUT return end if if (. not . any ( bc_type == allowed )) then ierr = ERROR_INVALID_INPUT return end if if ( bc_type == BC_OPEN ) then return end if if ( bc_type == BC_TWISTED ) then if (. not . present ( theta )) then ierr = ERROR_INVALID_INPUT return end if if ( theta < 0.0_dp . or . theta >= TWOPI ) then ierr = ERROR_OUT_OF_BOUNDS return end if end if end subroutine validate_bc_parameters !> @brief Apply boundary conditions to real Hamiltonian matrix !! !! Modifies edge elements of tight-binding Hamiltonian matrix H(L×L) !! according to specified boundary conditions. Assumes hopping t = 1. !! !! Modifications: !! - BC_OPEN: No modification (H already tridiagonal) !! - BC_PERIODIC: Sets H(1,L) = H(L,1) = -1 !! - BC_TWISTED: Not supported for real H (returns error) !! !! @param[inout] H Hamiltonian matrix (L×L, real) !! @param[in] L Number of lattice sites !! @param[in] bc_type Boundary condition type !! @param[in] theta Optional twist angle (ignored for OBC/PBC) !! @param[out] ierr Error code (0=success) !! !! @note For TBC, use apply_boundary_conditions_complex instead !! @note Matrix H must be allocated with dimensions (L,L) before calling subroutine apply_boundary_conditions ( H , L , bc_type , theta , ierr ) real ( dp ), intent ( inout ) :: H (:,:) integer , intent ( in ) :: L integer , intent ( in ) :: bc_type real ( dp ), intent ( in ), optional :: theta integer , intent ( out ) :: ierr ierr = 0 call validate_bc_parameters ( bc_type , theta , L , ierr ) if ( ierr /= 0 ) return if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if select case ( bc_type ) case ( BC_OPEN ) return case ( BC_PERIODIC ) H ( 1 , L ) = - 1.0_dp ! Assuming hopping parameter t = 1 H ( L , 1 ) = - 1.0_dp ! Assuming hopping parameter t = 1 case ( BC_TWISTED ) ierr = ERROR_INVALID_INPUT return case default ierr = ERROR_INVALID_INPUT end select end subroutine apply_boundary_conditions !> @brief Apply boundary conditions to complex Hamiltonian matrix !! !! Modifies edge elements of tight-binding Hamiltonian matrix H(L×L) !! for all boundary condition types, including twisted BC. !! Assumes hopping t = 1. !! !! Modifications: !! - BC_OPEN: No modification !! - BC_PERIODIC: Sets H(1,L) = H(L,1) = -1 !! - BC_TWISTED: Sets H(1,L) = -e&#94;{iθ}, H(L,1) = -e&#94;{-iθ} !! !! @param[inout] H Hamiltonian matrix (L×L, complex) !! @param[in] L Number of lattice sites !! @param[in] bc_type Boundary condition type !! @param[in] theta Optional twist angle in radians (required for BC_TWISTED) !! @param[out] ierr Error code (0=success) !! !! @note Twist angle θ represents Aharonov-Bohm phase from magnetic flux !! @note For θ=0, TBC reduces to PBC !! @note For θ=π, antiperiodic BC (useful for odd electron numbers) subroutine apply_boundary_conditions_complex ( H , L , bc_type , theta , ierr ) complex ( dp ), intent ( inout ) :: H (:,:) integer , intent ( in ) :: L integer , intent ( in ) :: bc_type real ( dp ), intent ( in ), optional :: theta complex ( dp ), allocatable :: H_complex (:,:) integer , intent ( out ) :: ierr real ( dp ) :: theta_val complex ( dp ), parameter :: IMAG_UNIT = ( 0.0_dp , 1.0_dp ) ierr = 0 call validate_bc_parameters ( bc_type , theta , L , ierr ) if ( ierr /= 0 ) return if ( size ( H , 1 ) /= L . or . size ( H , 2 ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if select case ( bc_type ) case ( BC_OPEN ) return case ( BC_PERIODIC ) H ( 1 , L ) = cmplx ( - 1.0_dp , 0.0_dp , kind = dp ) ! Assuming hopping parameter t = 1 H ( L , 1 ) = cmplx ( - 1.0_dp , 0.0_dp , kind = dp ) ! Assuming hopping parameter t = 1 case ( BC_TWISTED ) theta_val = theta H ( 1 , L ) = - 1.0_dp * exp ( IMAG_UNIT * theta_val ) H ( L , 1 ) = - 1.0_dp * exp ( - IMAG_UNIT * theta_val ) case default ierr = ERROR_INVALID_INPUT end select end subroutine apply_boundary_conditions_complex !> @brief Calculate analytical eigenvalues for free particles (U=0, V=0) !! !! Returns exact eigenvalues for non-interacting tight-binding model !! with specified boundary conditions. Assumes hopping t = 1. !! !! Eigenvalue formulas: !! - OBC: E_n = -2cos(nπ/(L+1)), n = 1,...,L !! - PBC: E_k = -2cos(2πk/L), k = 0,...,L-1 !! - TBC: E_k(θ) = -2cos((2πk + θ)/L), k = 0,...,L-1 !! !! @param[in] L Number of lattice sites !! @param[in] bc_type Boundary condition type !! @param[in] theta Optional twist angle (required for BC_TWISTED) !! @param[out] eigenvalues Array of L eigenvalues (ordered) !! @param[out] ierr Error code (0=success) !! !! @note Useful for validating numerical diagonalization !! @note For PBC/TBC, momentum k is a good quantum number !! @note For OBC, eigenvalues correspond to standing wave solutions subroutine get_free_particle_eigenvalues ( L , bc_type , theta , eigenvalues , ierr ) integer , intent ( in ) :: L integer , intent ( in ) :: bc_type real ( dp ), intent ( in ), optional :: theta real ( dp ), intent ( out ) :: eigenvalues (:) integer , intent ( out ) :: ierr integer :: n , k real ( dp ) :: theta_val ierr = 0 call validate_bc_parameters ( bc_type , theta , L , ierr ) if ( ierr /= 0 ) return if ( size ( eigenvalues ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if select case ( bc_type ) case ( BC_OPEN ) do n = 1 , L eigenvalues ( n ) = - 2.0_dp * cos ( n * PI / real ( L + 1 , dp )) ! Assuming hopping parameter t = 1 end do case ( BC_PERIODIC ) do k = 0 , L - 1 eigenvalues ( k + 1 ) = - 2.0_dp * cos ( TWOPI * k / real ( L , dp )) ! Assuming hopping parameter t = 1 end do case ( BC_TWISTED ) theta_val = theta do k = 0 , L - 1 eigenvalues ( k + 1 ) = - 2.0_dp * cos (( TWOPI * k + theta_val ) / real ( L , dp )) ! Assuming hopping parameter t = 1 end do case default ierr = ERROR_INVALID_INPUT return end select end subroutine get_free_particle_eigenvalues end module boundary_conditions","tags":"","url":"sourcefile/boundary_conditions.f90.html"},{"title":"adaptive_mixing.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~adaptive_mixing.f90~~EfferentGraph sourcefile~adaptive_mixing.f90 adaptive_mixing.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~adaptive_mixing.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~adaptive_mixing.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~adaptive_mixing.f90~~AfferentGraph sourcefile~adaptive_mixing.f90 adaptive_mixing.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~adaptive_mixing.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Adaptive mixing scheme for SCF convergence !! !! Implements the adaptive mixing algorithm from the original C++ code. !! The mixing parameter dynamically adjusts based on SCF convergence behavior: !! !! - If energy oscillates within a band for CountSCmax iterations → UpMix (more conservative) !! - If energy keeps increasing/decreasing for too long → DwMix (more aggressive) !! !! This replicates the logic from lsda_stop.cc (Convergencia class). module adaptive_mixing use lsda_constants , only : dp , INITIAL_MIX , ITER_MAX use lsda_errors , only : ERROR_SUCCESS implicit none private !> Adaptive mixing control parameters type , public :: adaptive_mix_t integer :: iter = 0 !< Current iteration integer :: count_sc = 0 !< Count within energy band integer :: count_bot = 0 !< Count when hitting bottom integer :: count_top = 0 !< Count when hitting top integer :: count_sc_max = 10 !< Max iterations in band before UpMix real ( dp ) :: mix = INITIAL_MIX !< Current mixing parameter (C++ convention) real ( dp ) :: energy_top = 0.0_dp !< Upper energy bound real ( dp ) :: energy_bot = 0.0_dp !< Lower energy bound real ( dp ) :: energy_new = 0.0_dp !< Current energy real ( dp ) :: energy_old = 0.0_dp !< Previous energy real ( dp ) :: tol = 1.0e-8_dp !< Convergence tolerance logical :: converged = . false . !< Convergence flag end type adaptive_mix_t public :: adaptive_mix_init public :: adaptive_mix_update public :: adaptive_mix_get_alpha public :: adaptive_mix_reset contains !> Initialize adaptive mixing !! !! @param[out] mix_ctrl Adaptive mixing control structure !! @param[in]  tol      Convergence tolerance (optional, default 1e-8) subroutine adaptive_mix_init ( mix_ctrl , tol ) type ( adaptive_mix_t ), intent ( out ) :: mix_ctrl real ( dp ), intent ( in ), optional :: tol mix_ctrl % iter = 0 mix_ctrl % count_sc = 0 mix_ctrl % count_bot = 0 mix_ctrl % count_top = 0 mix_ctrl % count_sc_max = 10 mix_ctrl % mix = INITIAL_MIX mix_ctrl % energy_top = 0.0_dp mix_ctrl % energy_bot = 0.0_dp mix_ctrl % energy_new = 0.0_dp mix_ctrl % energy_old = 0.0_dp mix_ctrl % converged = . false . if ( present ( tol )) then mix_ctrl % tol = tol else mix_ctrl % tol = 1.0e-8_dp end if end subroutine adaptive_mix_init !> Update adaptive mixing based on new energy !! !! This implements the C++ Convergencia::Update() logic. !! !! @param[inout] mix_ctrl Adaptive mixing control structure !! @param[in]    energy   New SCF energy subroutine adaptive_mix_update ( mix_ctrl , energy ) type ( adaptive_mix_t ), intent ( inout ) :: mix_ctrl real ( dp ), intent ( in ) :: energy real ( dp ) :: error , band_error ! Increment iteration mix_ctrl % iter = mix_ctrl % iter + 1 ! Update energies mix_ctrl % energy_old = mix_ctrl % energy_new mix_ctrl % energy_new = energy ! First iteration: initialize bounds if ( mix_ctrl % iter == 1 ) then mix_ctrl % energy_top = energy mix_ctrl % energy_bot = energy mix_ctrl % energy_old = energy mix_ctrl % converged = . false . return end if ! Calculate relative error if ( abs ( mix_ctrl % energy_new ) > 1.0e-15_dp ) then error = abs (( mix_ctrl % energy_new - mix_ctrl % energy_old ) / mix_ctrl % energy_new ) else error = abs ( mix_ctrl % energy_new - mix_ctrl % energy_old ) end if ! Calculate band error if ( abs ( mix_ctrl % energy_bot ) > 1.0e-15_dp ) then band_error = abs (( mix_ctrl % energy_top - mix_ctrl % energy_bot ) / mix_ctrl % energy_bot ) else band_error = abs ( mix_ctrl % energy_top - mix_ctrl % energy_bot ) end if ! Check if energy is within current band [Bot, Top] if ( mix_ctrl % energy_bot <= mix_ctrl % energy_new . and . & mix_ctrl % energy_new <= mix_ctrl % energy_top ) then ! Energy within band mix_ctrl % count_sc = mix_ctrl % count_sc + 1 mix_ctrl % count_top = 0 mix_ctrl % count_bot = 0 ! Check convergence if ( mix_ctrl % count_sc >= mix_ctrl % count_sc_max . and . & error < mix_ctrl % tol . and . band_error < mix_ctrl % tol ) then mix_ctrl % converged = . true . return end if ! Energy in band but not converged → UpMix (more conservative) if ( mix_ctrl % count_sc >= mix_ctrl % count_sc_max . and . & ( error >= mix_ctrl % tol . or . band_error >= mix_ctrl % tol )) then call up_mix ( mix_ctrl ) call reset_counts ( mix_ctrl ) end if else if ( mix_ctrl % energy_new > mix_ctrl % energy_top ) then ! Energy increased above top mix_ctrl % energy_top = mix_ctrl % energy_new mix_ctrl % count_top = mix_ctrl % count_top + 1 mix_ctrl % count_bot = 0 mix_ctrl % count_sc = 0 else if ( mix_ctrl % energy_new < mix_ctrl % energy_bot ) then ! Energy decreased below bottom mix_ctrl % energy_bot = mix_ctrl % energy_new mix_ctrl % count_bot = mix_ctrl % count_bot + 1 mix_ctrl % count_top = 0 mix_ctrl % count_sc = 0 end if ! If energy only increases or decreases for too long → DwMix (more aggressive) ! IMPORTANT: C++ checks Mix > 0.35 to prevent Mix from becoming too small if (( mix_ctrl % count_bot > mix_ctrl % count_sc_max * 5 . or . & mix_ctrl % count_top > mix_ctrl % count_sc_max * 5 ) . and . & mix_ctrl % mix > 0.35_dp ) then call dw_mix ( mix_ctrl ) ! Clamp Mix to prevent it from going too negative ! (C++ doesn't clamp explicitly, but the check above prevents problems) if ( mix_ctrl % mix < 0.0_dp ) then mix_ctrl % mix = 0.0_dp end if call reset_counts ( mix_ctrl ) end if ! Max iterations reached if ( mix_ctrl % iter >= ITER_MAX ) then mix_ctrl % converged = . false . end if end subroutine adaptive_mix_update !> Get alpha (Fortran convention) from mix (C++ convention) !! !! Fortran: n_new = (1-α)*n_old + α*n_calc  (α = weight of NEW) !! C++:     v_new = Mix*v_old + (1-Mix)*v_calc  (Mix = weight of OLD) !! !! Therefore: α = 1 - Mix !! !! IMPORTANT: Clamps alpha to (0, 1] to prevent linear_mixing errors !! !! @param[in] mix_ctrl Adaptive mixing control structure !! @return alpha Fortran mixing parameter (clamped to valid range) function adaptive_mix_get_alpha ( mix_ctrl ) result ( alpha ) type ( adaptive_mix_t ), intent ( in ) :: mix_ctrl real ( dp ) :: alpha alpha = 1.0_dp - mix_ctrl % mix ! Clamp to valid range (0, 1] to prevent linear_mixing from failing if ( alpha <= 0.0_dp ) then alpha = 1.0e-10_dp ! Very small but positive else if ( alpha > 1.0_dp ) then alpha = 1.0_dp end if end function adaptive_mix_get_alpha !> Reset adaptive mixing counters (keep Mix value) !! !! @param[inout] mix_ctrl Adaptive mixing control structure subroutine adaptive_mix_reset ( mix_ctrl ) type ( adaptive_mix_t ), intent ( inout ) :: mix_ctrl call reset_counts ( mix_ctrl ) ! Reset energy bounds to current energy mix_ctrl % energy_top = mix_ctrl % energy_new mix_ctrl % energy_bot = mix_ctrl % energy_new mix_ctrl % energy_old = mix_ctrl % energy_new end subroutine adaptive_mix_reset !> Increase mixing parameter (more conservative) !! !! C++ implementation: NewMix = Mix + (1.0 - Mix)/1.5 !! Capped at 0.999999999 !! !! @param[inout] mix_ctrl Adaptive mixing control structure subroutine up_mix ( mix_ctrl ) type ( adaptive_mix_t ), intent ( inout ) :: mix_ctrl real ( dp ) :: new_mix new_mix = mix_ctrl % mix + ( 1.0_dp - mix_ctrl % mix ) / 1.5_dp if ( new_mix < 0.999999999_dp ) then mix_ctrl % mix = new_mix end if end subroutine up_mix !> Decrease mixing parameter (more aggressive) !! !! C++ implementation: Mix = Mix - (1.0 - Mix)*1.9 !! NO CLAMP - Let it go negative and wrap to 0 if needed !! !! @param[inout] mix_ctrl Adaptive mixing control structure subroutine dw_mix ( mix_ctrl ) type ( adaptive_mix_t ), intent ( inout ) :: mix_ctrl mix_ctrl % mix = mix_ctrl % mix - ( 1.0_dp - mix_ctrl % mix ) * 1.9_dp end subroutine dw_mix !> Reset counters only (internal helper) !! !! @param[inout] mix_ctrl Adaptive mixing control structure subroutine reset_counts ( mix_ctrl ) type ( adaptive_mix_t ), intent ( inout ) :: mix_ctrl mix_ctrl % count_sc = 0 mix_ctrl % count_bot = 0 mix_ctrl % count_top = 0 end subroutine reset_counts end module adaptive_mixing","tags":"","url":"sourcefile/adaptive_mixing.f90.html"},{"title":"density_calculator.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~density_calculator.f90~~EfferentGraph sourcefile~density_calculator.f90 density_calculator.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~density_calculator.f90->sourcefile~lsda_constants.f90 sourcefile~lsda_errors.f90 lsda_errors.f90 sourcefile~density_calculator.f90->sourcefile~lsda_errors.f90 sourcefile~lsda_errors.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~density_calculator.f90~~AfferentGraph sourcefile~density_calculator.f90 density_calculator.f90 sourcefile~kohn_sham_cycle.f90 kohn_sham_cycle.f90 sourcefile~kohn_sham_cycle.f90->sourcefile~density_calculator.f90 sourcefile~input_parser.f90 input_parser.f90 sourcefile~input_parser.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90 output_writer.f90 sourcefile~output_writer.f90->sourcefile~kohn_sham_cycle.f90 sourcefile~output_writer.f90->sourcefile~input_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module density_calculator use lsda_constants , only : dp use lsda_errors , only : ERROR_SUCCESS , ERROR_INVALID_INPUT , & ERROR_SIZE_MISMATCH , ERROR_UNPHYSICAL_DENSITY implicit none private real ( dp ), parameter :: TOL = 1.0e-10_dp public :: compute_density_spin public :: compute_total_density public :: verify_particle_number public :: check_density_bounds interface compute_density_spin module procedure compute_density_spin_real module procedure compute_density_spin_complex end interface compute_density_spin contains !> @brief Compute density from real eigenvectors (Open/Periodic BC) !! !! Calculates n_σ(i) = Σ_j |ψ_j(i)|² for occupied states at T=0. !! !! @param[in] eigvecs Real eigenvector matrix (L × L), columns are eigenvectors !! @param[in] L System size !! @param[in] n_elec Number of occupied electrons (for this spin) !! @param[out] density Electron density at each site (length L) !! @param[out] ierr Error code (0 = success) subroutine compute_density_spin_real ( eigvecs , L , n_elec , density , ierr ) real ( dp ), intent ( in ) :: eigvecs (:, :) integer , intent ( in ) :: L , n_elec real ( dp ), intent ( out ) :: density (:) integer , intent ( out ) :: ierr integer :: i if ( L <= 0 . or . n_elec <= 0 . or . n_elec > L ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( eigvecs , 1 ) /= L . or . size ( eigvecs , 2 ) < n_elec ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( density ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if ierr = ERROR_SUCCESS do i = 1 , L density ( i ) = sum ( eigvecs ( i , 1 : n_elec ) ** 2 ) end do end subroutine !> @brief Compute density from complex eigenvectors (Twisted BC) !! !! Calculates n_σ(i) = Σ_j |ψ_j(i)|² for occupied states at T=0. !! !! @param[in] eigvecs Complex eigenvector matrix (L × L), columns are eigenvectors !! @param[in] L System size !! @param[in] n_elec Number of occupied electrons (for this spin) !! @param[out] density Real electron density at each site (length L) !! @param[out] ierr Error code (0 = success) subroutine compute_density_spin_complex ( eigvecs , L , n_elec , density , ierr ) complex ( dp ), intent ( in ) :: eigvecs (:, :) integer , intent ( in ) :: L , n_elec real ( dp ), intent ( out ) :: density (:) integer , intent ( out ) :: ierr integer :: i if ( L <= 0 . or . n_elec <= 0 . or . n_elec > L ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( eigvecs , 1 ) /= L . or . size ( eigvecs , 2 ) < n_elec ) then ierr = ERROR_SIZE_MISMATCH return end if if ( size ( density ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if ierr = ERROR_SUCCESS do i = 1 , L density ( i ) = sum ( real ( eigvecs ( i , 1 : n_elec ) * conjg ( eigvecs ( i , 1 : n_elec )), kind = dp )) end do end subroutine !> @brief Compute total density from spin-resolved densities !! !! Calculates n(i) = n_↑(i) + n_↓(i) at each site. !! !! @param[in] density_up Spin-up density (length L) !! @param[in] density_dw Spin-down density (length L) !! @param[out] density_total Total density n(i) (length L) !! @param[out] ierr Error code (0 = success) subroutine compute_total_density ( density_up , density_dw , density_total , ierr ) real ( dp ), intent ( in ) :: density_up (:), density_dw (:) real ( dp ), intent ( out ) :: density_total (:) integer , intent ( out ) :: ierr real ( dp ) :: n_total if ( size ( density_up ) /= size ( density_dw ) . or . & size ( density_up ) /= size ( density_total )) then ierr = ERROR_SIZE_MISMATCH return end if ierr = ERROR_SUCCESS density_total = density_up + density_dw end subroutine !> @brief Verify particle number conservation !! !! Checks if Σᵢ n_σ(i) = N_σ within tolerance TOL = 1e-10. !! !! @param[in] density Electron density (spin-up, spin-down, or total) !! @param[in] L System size !! @param[in] n_expected Expected number of particles !! @param[out] is_conserved True if |Σn - N| < TOL !! @param[out] ierr Error code (0 = success) subroutine verify_particle_number ( density , L , n_expected , is_conserved , ierr ) real ( dp ), intent ( in ) :: density (:) integer , intent ( in ) :: L , n_expected logical , intent ( out ) :: is_conserved integer , intent ( out ) :: ierr real ( dp ) :: n_computed if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( density ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if ierr = ERROR_SUCCESS n_computed = sum ( density ) is_conserved = ( abs ( n_computed - real ( n_expected , kind = dp )) < TOL ) end subroutine !> @brief Check if densities satisfy physical bounds !! !! Verifies: 0 ≤ n_σ(i) and 0 ≤ n(i) = n_up(i) + n_dw(i) ≤ 2 !! !! @param[in] density_up Spin-up density (length L) !! @param[in] density_dw Spin-down density (length L) !! @param[in] L System size !! @param[out] all_valid True if all densities are physical !! @param[out] ierr Error code (0 = success) subroutine check_density_bounds ( density_up , density_dw , L , all_valid , ierr ) real ( dp ), intent ( in ) :: density_up (:), density_dw (:) integer , intent ( in ) :: L logical , intent ( out ) :: all_valid integer , intent ( out ) :: ierr real ( dp ) :: n_total integer :: j if ( L <= 0 ) then ierr = ERROR_INVALID_INPUT return end if if ( size ( density_up ) /= L . or . size ( density_dw ) /= L ) then ierr = ERROR_SIZE_MISMATCH return end if ierr = ERROR_SUCCESS all_valid = . true . do j = 1 , L if ( density_up ( j ) < - TOL . or . density_dw ( j ) < - TOL ) then all_valid = . false . ierr = ERROR_UNPHYSICAL_DENSITY return end if n_total = density_up ( j ) + density_dw ( j ) if ( n_total > 2.0_dp + TOL ) then all_valid = . false . ierr = ERROR_UNPHYSICAL_DENSITY return end if end do end subroutine end module density_calculator","tags":"","url":"sourcefile/density_calculator.f90.html"},{"title":"continuation.f90 – LSDA-Hubbard-Fortran","text":"This file depends on sourcefile~~continuation.f90~~EfferentGraph sourcefile~continuation.f90 continuation.f90 sourcefile~bethe_equations.f90 bethe_equations.f90 sourcefile~continuation.f90->sourcefile~bethe_equations.f90 sourcefile~lsda_constants.f90 lsda_constants.f90 sourcefile~continuation.f90->sourcefile~lsda_constants.f90 sourcefile~nonlinear_solvers.f90 nonlinear_solvers.f90 sourcefile~continuation.f90->sourcefile~nonlinear_solvers.f90 sourcefile~bethe_equations.f90->sourcefile~lsda_constants.f90 sourcefile~nonlinear_solvers.f90->sourcefile~bethe_equations.f90 sourcefile~nonlinear_solvers.f90->sourcefile~lsda_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !> Continuation methods for solving Bethe Ansatz equations across parameter ranges !! !! This module implements predictor-corrector continuation methods to efficiently !! solve the Lieb-Wu equations for multiple values of the Hubbard interaction U. !! !! Key features: !! - Forward sweep (U_min → U_max) with linear extrapolation !! - Backward sweep (U_max → U_min) for refinement !! - Bidirectional sweep (average of forward + backward) !! - Typical speedup: 5-10x compared to independent solutions !! !! Algorithm: !! 1. Solve for first U value (from scratch) !! 2. For subsequent U: predict solution using previous points !! 3. Refine prediction with Newton-Raphson (converges in 1-3 iterations) !! !! @note Assumes solutions vary smoothly with U (no bifurcations) !! @see bethe_equations, nonlinear_solvers module continuation use lsda_constants , only : dp , TWOPI , U_SMALL use bethe_equations , only : compute_energy use nonlinear_solvers , only : solve_newton implicit none private public :: estimate_dxdU public :: sweep_U_forward public :: sweep_U_backward public :: sweep_U_bidirectional contains !> Estimates dx/dU using finite differences !! !! Approximates the derivative of the solution with respect to U !! using two consecutive points: !! !!  \\frac{dx}{dU} \\approx \\frac{x_{\\text{current}} - x_{\\text{old}}}{\\Delta U}  !! !! This is used in the predictor step of continuation methods to !! extrapolate the solution to the next U value. !! !! @param[in] x_old      Solution at U_{i-1} !! @param[in] x_current  Solution at U_i !! @param[in] dU         Step size: U_i - U_{i-1} !! @return    dxdU       Estimated derivative dx/dU !! !! @note This is a first-order approximation (linear extrapolation) !! @note For better accuracy, could use higher-order schemes (quadratic, cubic) !! !! @see sweep_U_forward, sweep_U_backward function estimate_dxdU ( x_old , x_current , dU ) result ( dxdU ) real ( dp ), intent ( in ) :: x_old (:), x_current (:), dU real ( dp ) :: dxdU ( size ( x_current )) dxdU = ( x_current - x_old ) / dU end function estimate_dxdU !> Forward sweep in U with predictor-corrector method !! !! Solves Bethe Ansatz equations for a sequence of U values from U_min to U_max, !! using previous solutions to accelerate convergence. !! !! Algorithm: !! - Point 1 (U_min): Solve from scratch (Fermi gas initial guess) !! - Point 2: Predictor = previous solution (no extrapolation yet) !! - Points 3+: Predictor = linear extrapolation using 2 previous points !!              x_guess = 2·x_{i-1} - x_{i-2} !! - Corrector: Refine with Newton-Raphson (typically 1-3 iterations) !! !! @param[in]  I                Charge quantum numbers (N↑) !! @param[in]  J                Spin quantum numbers (M = N↓) !! @param[in]  L                Number of lattice sites !! @param[in]  U_values         U values [U_min, U_min+dU, ..., U_max] (n_points) !! @param[out] solutions        Solutions x(U) - matrix (N↑+M, n_points) !! @param[out] energies         Ground state energies E(U) (n_points) !! @param[out] converged_flags  Convergence flags (n_points) !! !! @note Arrays must be pre-allocated by caller !! @note Prints warning if Newton fails to converge at any point !! @note Typical speedup vs independent solutions: 5-10x !! !! Example usage: !! @code !!   U_values = [0.0, 0.5, 1.0, ..., 10.0]  ! 21 points !!   allocate(solutions(Nup+M, 21), energies(21), flags(21)) !!   call sweep_U_forward(I, J, L, U_values, solutions, energies, flags) !! @endcode !! !! @see sweep_U_backward, sweep_U_bidirectional, solve_newton subroutine sweep_U_forward ( I , J , L , U_values , solutions , energies , converged_flags ) real ( dp ), intent ( in ) :: U_values (:), I (:), J (:) integer , intent ( in ) :: L real ( dp ), intent ( out ) :: solutions (:, :), energies (:) logical , intent ( out ) :: converged_flags (:) real ( dp ), allocatable :: x (:), x_guess (:), dxdU (:), k (:) real ( dp ) :: U , dU , dU_old integer :: Nup , M , site , n_points logical :: converged Nup = size ( I ) M = size ( J ) n_points = size ( U_values ) allocate ( x ( Nup + M )) allocate ( x_guess ( Nup + M )) allocate ( dxdU ( Nup + M )) allocate ( k ( Nup )) ! For first site: site = 1 U = U_values ( 1 ) if ( U < U_SMALL ) then ! Analytical solution for U = 0 x_guess ( 1 : Nup ) = ( TWOPI * I ) / real ( L , dp ) x_guess ( Nup + 1 : Nup + M ) = 0.0_dp x = x_guess converged = . true . else ! Initial guess: Fermi gas x_guess ( 1 : Nup ) = ( TWOPI * I ) / real ( L , dp ) x_guess ( Nup + 1 : Nup + M ) = 0.0_dp x = x_guess call solve_newton ( x , I , J , L , U , converged ) end if solutions (:, 1 ) = x k = x ( 1 : Nup ) energies ( 1 ) = compute_energy ( k ) converged_flags ( 1 ) = converged ! For second site: site = 2 U = U_values ( 2 ) x_guess = solutions (:, 1 ) x = x_guess call solve_newton ( x , I , J , L , U , converged ) solutions (:, 2 ) = x k = x ( 1 : Nup ) energies ( 2 ) = compute_energy ( k ) converged_flags ( 2 ) = converged dU_old = U_values ( 2 ) - U_values ( 1 ) do site = 3 , n_points U = U_values ( site ) dU = U_values ( site ) - U_values ( site - 1 ) ! PREDITOR dxdU = estimate_dxdU ( solutions (:, site - 2 ), solutions (:, site - 1 ), dU_old ) x_guess = solutions (:, site - 1 ) + dU * dxdU ! CORRETOR x = x_guess call solve_newton ( x , I , J , L , U , converged ) solutions (:, site ) = x k = x ( 1 : Nup ) energies ( site ) = compute_energy ( k ) converged_flags ( site ) = converged if (. not . converged ) then print * , \"Warning: Failed at U =\" , U end if dU_old = dU end do deallocate ( x , x_guess , dxdU , k ) end subroutine !> Backward sweep in U with predictor-corrector method !! !! Identical to forward sweep, but in reverse direction (U_max → U_min). !! Useful for refinement and validation of forward sweep results. !! !! Algorithm: !! - Point n (U_max): Solve from scratch !! - Point n-1: Predictor = previous solution !! - Points n-2 to 1: Predictor = linear extrapolation (backward) !!                    x_guess = x_{i+1} - dU·(dx/dU) !! !! @param[in]  I                Charge quantum numbers !! @param[in]  J                Spin quantum numbers !! @param[in]  L                Number of lattice sites !! @param[in]  U_values         U values [U_min, ..., U_max] !! @param[out] solutions        Solutions x(U) - matrix (N↑+M, n_points) !! @param[out] energies         Ground state energies E(U) !! @param[out] converged_flags  Convergence flags !! !! @note U_values array order is the same as forward (U_min first) !! @note Solutions are filled in reverse order (from n_points to 1) !! @note Useful to detect multiple solutions or bifurcations !! !! @see sweep_U_forward, sweep_U_bidirectional subroutine sweep_U_backward ( I , J , L , U_values , solutions , energies , converged_flags ) real ( dp ), intent ( in ) :: U_values (:), I (:), J (:) integer , intent ( in ) :: L real ( dp ), intent ( out ) :: solutions (:, :), energies (:) logical , intent ( out ) :: converged_flags (:) real ( dp ), allocatable :: x (:), x_guess (:), dxdU (:), k (:) real ( dp ) :: U , dU , dU_old integer :: Nup , M , site , n_points logical :: converged Nup = size ( I ) M = size ( J ) n_points = size ( U_values ) allocate ( x ( Nup + M )) allocate ( x_guess ( Nup + M )) allocate ( dxdU ( Nup + M )) allocate ( k ( Nup )) ! For first site: site = n_points U = U_values ( n_points ) if ( U < U_SMALL ) then ! Analytical solution for U = 0 x_guess ( 1 : Nup ) = ( TWOPI * I ) / real ( L , dp ) x_guess ( Nup + 1 : Nup + M ) = 0.0_dp x = x_guess converged = . true . else ! Initial guess: Fermi gas x_guess ( 1 : Nup ) = ( TWOPI * I ) / real ( L , dp ) x_guess ( Nup + 1 : Nup + M ) = 0.0_dp x = x_guess call solve_newton ( x , I , J , L , U , converged ) end if solutions (:, n_points ) = x k = x ( 1 : Nup ) energies ( n_points ) = compute_energy ( k ) converged_flags ( n_points ) = converged ! For second site: site = n_points - 1 U = U_values ( n_points - 1 ) x_guess = solutions (:, n_points ) x = x_guess call solve_newton ( x , I , J , L , U , converged ) solutions (:, n_points - 1 ) = x k = x ( 1 : Nup ) energies ( n_points - 1 ) = compute_energy ( k ) converged_flags ( n_points - 1 ) = converged dU_old = U_values ( n_points ) - U_values ( n_points - 1 ) do site = n_points - 2 , 1 , - 1 U = U_values ( site ) dU = U_values ( site + 1 ) - U_values ( site ) ! PREDITOR dxdU = estimate_dxdU ( solutions (:, site + 2 ), solutions (:, site + 1 ), dU_old ) x_guess = solutions (:, site + 1 ) - dU * dxdU ! CORRETOR x = x_guess call solve_newton ( x , I , J , L , U , converged ) solutions (:, site ) = x k = x ( 1 : Nup ) energies ( site ) = compute_energy ( k ) converged_flags ( site ) = converged if (. not . converged ) then print * , \"Warning: Failed at U =\" , U end if dU_old = dU end do deallocate ( x , x_guess , dxdU , k ) end subroutine !> Bidirectional sweep with refinement (forward + backward average) !! !! Performs both forward and backward sweeps, then averages the results !! to obtain maximum accuracy and detect potential numerical issues. !! !! Algorithm: !! 1. Forward sweep: U_min → U_max (stores in sol_fwd) !! 2. Backward sweep: U_max → U_min (stores in sol_bwd) !! 3. Refinement: Average both results !!    - solutions = (sol_fwd + sol_bwd) / 2 !!    - energies = (E_fwd + E_bwd) / 2 !! 4. Validation: Check consistency !!    - If |E_fwd - E_bwd| > 1e-6, prints warning !!    - May indicate bifurcations or numerical instability !! 5. Convergence: Both sweeps must have converged !!    - converged_flags = flags_fwd AND flags_bwd !! !! @param[in]  I                Charge quantum numbers (N↑) !! @param[in]  J                Spin quantum numbers (M = N↓) !! @param[in]  L                Number of lattice sites !! @param[in]  U_values         U values [U_min, ..., U_max] (n_points) !! @param[out] solutions        Refined solutions (average) - matrix (N↑+M, n_points) !! @param[out] energies         Refined energies (average) - vector (n_points) !! @param[out] converged_flags  Convergence flags (true if BOTH converged) !! !! @note This is the most robust method but ~2x slower than single sweep !! @note Recommended for production runs and validation !! @note If forward/backward differ significantly, may indicate: !!       - Multiple solutions (bifurcation) !!       - Numerical instability !!       - Step size too large !! !! Advantages over single sweep: !! - Higher accuracy (averaging reduces numerical errors) !! - Error detection (large differences indicate problems) !! - Validation (if fwd ≈ bwd, solution is trustworthy) !! !! Example usage: !! @code !!   ! Generate table for U ∈ [0, 10] with 100 points !!   U_values = [(i*0.1_dp, i=0,100)] !!   allocate(solutions(Nup+M, 101), energies(101), flags(101)) !!   call sweep_U_bidirectional(I, J, L, U_values, solutions, energies, flags) !! !!   if (all(flags)) then !!       print *, \"All points converged successfully!\" !!   end if !! @endcode !! !! @see sweep_U_forward, sweep_U_backward subroutine sweep_U_bidirectional ( I , J , L , U_values , solutions , energies , converged_flags ) real ( dp ), intent ( in ) :: U_values (:), I (:), J (:) integer , intent ( in ) :: L real ( dp ), intent ( out ) :: solutions (:, :), energies (:) logical , intent ( out ) :: converged_flags (:) real ( dp ), allocatable :: sol_fwd (:, :), sol_bwd (:, :), E_fwd (:), E_bwd (:) logical , allocatable :: flags_fwd (:), flags_bwd (:) real ( dp ) :: max_diff integer :: Nup , M , n_points Nup = size ( I ) M = size ( J ) n_points = size ( U_values ) allocate ( sol_fwd ( Nup + M , n_points )) allocate ( E_fwd ( n_points )) allocate ( flags_fwd ( n_points )) allocate ( sol_bwd ( Nup + M , n_points )) allocate ( E_bwd ( n_points )) allocate ( flags_bwd ( n_points )) ! 1. Forward sweep call sweep_U_forward ( I , J , L , U_values , sol_fwd , E_fwd , flags_fwd ) ! 2. Backward sweep call sweep_U_backward ( I , J , L , U_values , sol_bwd , E_bwd , flags_bwd ) ! 3. Average (refinment) solutions = ( sol_fwd + sol_bwd ) / 2.0_dp energies = ( E_fwd + E_bwd ) / 2.0_dp ! 4. Convergence: both must have converged converged_flags = flags_fwd . and . flags_bwd ! 5. Check consistency max_diff = maxval ( abs ( E_fwd - E_bwd )) if ( max_diff > 1.0e-6_dp ) then print * , \"Warning: Forward/backward differ by\" , max_diff end if end subroutine end module continuation","tags":"","url":"sourcefile/continuation.f90.html"}]}